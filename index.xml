<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>nibbles</title>
    <link>https://0xnibbles.github.io/</link>
    <description>Recent content on nibbles</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Jan 2023 18:36:39 +0000</lastBuildDate><atom:link href="https://0xnibbles.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ZDI-17-836 - dbman Opcode 10012 Use-After-Free Remote Code Execution</title>
      <link>https://0xnibbles.github.io/posts/nday/zdi-17-836/</link>
      <pubDate>Wed, 25 Jan 2023 18:36:39 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/nday/zdi-17-836/</guid>
      <description>Introduction The present document analyzes previous disclosed use-after-free in Hewlett Packard Enterprise Intelligent Management Center, a network management platform. The vulnerability was reported by Steven Seeley to the Zero Day Initiative (ZDI) disclosure program identified as CVE-2017-12561.
The flaw allows to perform an unauthenticated remote attack and execute arbitrary code on vulnerable installations. HP fixed this vulnerability in October 2017, and all vulnerable instances should be updated to version HPE Intelligent Management Center (iMC) iMC Plat 7.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 7 - Custom Crypter</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_7/</link>
      <pubDate>Mon, 02 Jan 2023 00:27:36 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_7/</guid>
      <description>SLAE64 This post introduces the 7th and last mission of my SLAE64 journey.
As well as the SLAE32 - Custom Crypter decided to work with python3 and the majority of the work was dealing with conversion types between encrypting and decrypting the shellcode.
Introduction The SLAE32 7th assignment purpose is to create a custom crypter having as reference the one shown in the crypter lesson..
For this task there are no special requirements:</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 6 - Polymorphic Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_6/</link>
      <pubDate>Sun, 01 Jan 2023 22:40:23 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_6/</guid>
      <description>SLAE64 This post introduces my 6th mission to my SLAE64 journey.
Some existing tools, such as ADMutate, will XOR-encrypt existing shellcode and attach loader code. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.
There is a lot of overlap information with my post regarding the SLAE32 - Polymorphic Shellcode. I advise you to look at it if you haven’t done it already.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 5 - Msfvenom Shellcode Analysis </title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_5/</link>
      <pubDate>Sun, 01 Jan 2023 17:58:44 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_5/</guid>
      <description>SLAE64 This post introduces my 5th mission of my SLAE64 journey.
Introduction The SLAE64 5th assignment&amp;rsquo;s purpose is to select three msfvenom payloads, dissect them with gdb, and document my analysis.
For this task, I selected the following payloads:
linux/x86/shell_bind_tcp linux/x86/shell_reverse_tcp linux/x86/chmod Shellcode 1 - linux/x64/shell_bind_tcp The first step to do is to generate the shellcode using MSF. As usual, let’s check its arguments.
msfvenom -p linux/x64/shell_bind_tcp --list-options
-[~]$ msfvenom -p linux/x64/shell_bind_tcp --list-options Options for payload/linux/x64/shell_bind_tcp: ========================= Name: Linux Command Shell, Bind TCP Inline Module: payload/linux/x64/shell_bind_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 86 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LPORT 4444 yes The listen port RHOST no The target address Description: Listen for a connection and spawn a command shell Let&amp;rsquo;s get our bind shell using msfvenom.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_4/</link>
      <pubDate>Sun, 01 Jan 2023 17:27:17 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_4/</guid>
      <description>SLAE64 This post introduces my 4th mission of my SLAE64 journey.
Introduction The fourth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes, making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).
There is a lot of overlap information with my post regarding the SLAE32 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder).</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 3 - Egghunter Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_3/</link>
      <pubDate>Sun, 01 Jan 2023 16:15:00 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_3/</guid>
      <description>SLAE64 This post introduces my 3rd mission of my SLAE64 journey.
Introduction The primary goal for the third SLAE64 assignment is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Creating an Egghunter Shellcode There is a lot of overlap information with my post regarding the SLAE32 Egghunter Shellcode.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 2 - TCP Reverse Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_2/</link>
      <pubDate>Sun, 01 Jan 2023 02:30:49 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_2/</guid>
      <description>SLAE64 This post introduces my 2nd mission of my SLAE64 journey.
Introduction The main goal for the second SLAE64 assignment is to develop a reverse TCP shellcode with the following requirements:
The reverse shell connects to the configured IP and port; The user needs to provide a correct password Executing a shell on incoming connection if the password is valid; The shellcode should be null-free; Creating a TCP Reverse Shellcode There is a lot of overlap information with my post regarding the SLAE32 TCP Reverse Shellcode.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 1 - TCP Bind Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_1/</link>
      <pubDate>Fri, 30 Dec 2022 18:54:45 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_1/</guid>
      <description>SLAE64 This post introduces the first mission of my SLAE64 journey.
Introduction The main goal for the first SLAE64 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; Teh user needs to provide a correct password Executing a shell on incoming connection if thepassword is valid; The shellcode should be null-free; Past, present and Future The exercises of SLAE64 are identical to the ones of SLAE32, so for the 64-bit version, I will have a more simple approach.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 7 - Custom Crypter</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_7/</link>
      <pubDate>Fri, 30 Dec 2022 17:02:17 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_7/</guid>
      <description>SLAE32 This post introduces the 7th and last mission of my SLAE32 journey.
A different task as I decided to work with python3, and most of the work dealt with conversion types between encrypting and decrypting the shellcode.
Introduction The SLAE32 7th assignment&amp;rsquo;s purpose is to create a custom crypter that references the one shown in the crypter lesson.
For this task, there are no special requirements:
Can use any existing encryption schema Can use any programming language I decided to have a more straightforward approach to this task without going into as much detail as in previous assignments.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 6 - Polymorphic Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_6/</link>
      <pubDate>Thu, 29 Dec 2022 15:02:57 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_6/</guid>
      <description>SLAE32 This post introduces the 6th mission of my SLAE32 journey.
If the previous assignment was incredible, this one was even cooler because I could apply what I learned in the Msfvenom analysis assignment to develop polymorphic versions of existing shellcodes.
Some existing tools, such as ADMutate, will XOR-encrypt the existing shellcode and attach the loader code to it. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 5 - Msfvenom Shellcode Analysis</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_5/</link>
      <pubDate>Thu, 29 Dec 2022 10:58:18 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_5/</guid>
      <description>SLAE32 This post introduces the 5th mission of my SLAE32 journey.
An excellent task to see how a widely used tool by the offensive security community produces shellcode and compare it with my developed ones. New tricks and new cool learned.
Introduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.
For this task I selected the following payloads:
linux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_4/</link>
      <pubDate>Wed, 28 Dec 2022 16:39:09 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_4/</guid>
      <description>SLAE32 This post introduces the forth mission of my SLAE32 journey.
A real handful and a challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode
Introduction The fourth assignment goal was to create my custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh.
A shellcode encoder can be used for different purposes, mainly making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 3 - Egghunter Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/</link>
      <pubDate>Wed, 28 Dec 2022 14:12:10 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/</guid>
      <description>SLAE32 This post introduces the third mission of my SLAE32 journey.
A fantastic challenge not covered during the course made me research and understand the concept and which scenarios it&amp;rsquo;s applicable.
Introduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 2 - TCP Reverse Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_2/</link>
      <pubDate>Wed, 28 Dec 2022 01:59:06 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_2/</guid>
      <description>SLAE32 This post introduces the second mission of my SLAE32 journey.
I spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assignment.
I won&amp;rsquo;t be as much detailed this time but guess what?
The best part is that we can reuse most of the bind shellcode to create a reverse shellcode!
Introduction The second assignment for the SLAE32 is similar to the previous post one, but in this case, we need to develop a reverse TCP shellcode.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 1 - TCP Bind Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_1/</link>
      <pubDate>Mon, 26 Dec 2022 13:45:33 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae32/slae_32_assignment_1/</guid>
      <description>SLAE32 This post introduces the first mission of my SLAE32 journey.
Introduction The main goal for the first SLAE32 assignment is to develop a bind TCP shellcode with the following requirements:
Binds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.</description>
    </item>
    
    
    
  </channel>
</rss>
