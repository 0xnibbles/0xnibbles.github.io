<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on nibbles</title>
    <link>https://0xnibbles.github.io/posts/</link>
    <description>Recent content in Posts on nibbles</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Dec 2022 16:39:09 +0000</lastBuildDate><atom:link href="https://0xnibbles.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</title>
      <link>https://0xnibbles.github.io/posts/slae_32_assignment_4/</link>
      <pubDate>Wed, 28 Dec 2022 16:39:09 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae_32_assignment_4/</guid>
      <description>This post introduces the forth mission to my SLAE32 journey.
A really really handful and challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode
Introduction The forth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. AS ou may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes mainly make it harder to detect by AV engines or simply avoid bad characters (such as null-bytes).</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 3 - Egghunter Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae_32_assignment_3/</link>
      <pubDate>Wed, 28 Dec 2022 14:12:10 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae_32_assignment_3/</guid>
      <description>This post introduces the third mission to my SLAE32 journey.
A cool challenge not covered during the course which made me to research and understand the concept and which scenarios its applicable.
Introduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 2 - TCP Reverse Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae_32_assignment_2/</link>
      <pubDate>Wed, 28 Dec 2022 01:59:06 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae_32_assignment_2/</guid>
      <description>This post introduces the second mission to my SLAE32 journey.
I spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assigment. I won&amp;rsquo;t be as much detailed this time but guess what?
The best part is that we can reuse the majority of the bind shellcode to create a reverse shellcode!
Introduction The second assignment for the SLAE32 is similar to the previous post one but in this case we need to develop a reverse TCP shellcode.</description>
    </item>
    
    <item>
      <title>SLAE32 Assignment 1 - TCP Bind Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae_32_assignment_1/</link>
      <pubDate>Mon, 26 Dec 2022 13:45:33 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae_32_assignment_1/</guid>
      <description>This post introduces the first mission to my SLAE-32 journey.
Introduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.</description>
    </item>
    
  </channel>
</rss>
