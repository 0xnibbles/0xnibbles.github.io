<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>slae64 on nibbles</title>
    <link>https://0xnibbles.github.io/tags/slae64/</link>
    <description>Recent content in slae64 on nibbles</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Jan 2023 22:40:23 +0000</lastBuildDate><atom:link href="https://0xnibbles.github.io/tags/slae64/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Slae64 Assignment 6 - Polymorphic Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_6/</link>
      <pubDate>Sun, 01 Jan 2023 22:40:23 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_6/</guid>
      <description>This post introduces my 6th mission to my SLAE64 journey.
Some existing tools, such as ADMutate, that will XOR-encrypt existing shellcode and attach loader code to it. This is definitely useful, but writing polymorphic shellcode without a tool is a much better learning experience.
There is a lof of overlap information with my post regarding the SLAE32 - Polymorphic Shellcode. I advice you to take look at if haven&amp;rsquo;t done already.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 5 - Msfvenom Shellcode Analysis </title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_5/</link>
      <pubDate>Sun, 01 Jan 2023 17:58:44 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_5/</guid>
      <description>This post introduces my 5th mission to my SLAE64 journey.
Introduction The SLAE64 5th assignment purpose is to select 3 msfvenom payloads dissect them with gdb and document my own analysis of them.
For this task I selected the following payloads:
linux/x86/shell_bind_tcp linux/x86/shell_reverse_tcp linux/x86/chmod Shellcode 1 - linux/x64/shell_bind_tcp The first step to do is generate the shellcode using MSF. As usual, let&amp;rsquo;s check its arguments
msfvenom -p linux/x64/shell_bind_tcp --list-options</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_4/</link>
      <pubDate>Sun, 01 Jan 2023 17:27:17 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_4/</guid>
      <description>This post introduces my 4th mission to my SLAE64 journey.
Introduction The forth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. AS ou may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes mainly make it harder to detect by AV engines or simply avoid bad characters (such as null-bytes).
There is a lof of overlap information with my post regarding the SLAE32 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder).</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 3 - Egghunter Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_3/</link>
      <pubDate>Sun, 01 Jan 2023 16:15:00 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_3/</guid>
      <description>This post introduces my 3rd mission to my SLAE64 journey.
Introduction The main goal for the third SLAE64 assignment is to create an egghunter shellcode with the following requirements:
Create a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Creating an Egghunter Shellcode There is a lof of overlap information with my post regarding the SLAE32 Egghunter Shellcode. I advice you to take look at if haven&amp;rsquo;t done already.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 2 - TCP Reverse Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_2/</link>
      <pubDate>Sun, 01 Jan 2023 02:30:49 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_2/</guid>
      <description>This post introduces my 2nd mission to my SLAE64 journey.
Introduction The main goal for the second SLAE64 assignment is to develop a reverse TCP shellcode with the following requirements:
Reverse shell connects to the configured IP and port; User needs to provide a correct password Executing a shell on incoming connection if password is correct; The shellcode should be null-free; Creating a TCP Reverse Shellcode There is a lof of overlap information with my post regarding the SLAE32 TCP Reverse Shellcode.</description>
    </item>
    
    <item>
      <title>SLAE64 Assignment 1 - TCP Bind Shellcode</title>
      <link>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_1/</link>
      <pubDate>Fri, 30 Dec 2022 18:54:45 +0000</pubDate>
      
      <guid>https://0xnibbles.github.io/posts/slae64/slae_64_assignment_1/</guid>
      <description>This post introduces the first mission to my SLAE64 journey.
Introduction The main goal for the first SLAE64 assignment is to develop a shellcode for bind TCP shell with the following requirements:
Binds to a port; User needs to provide a correct password Executing a shell on incoming connection if password is correct; The shellcode should be null-free; Past, present and Future The exercises of SLAE64 are identical to the ones of SLAE32, so for the 64 bit version I will have a more simple approach.</description>
    </item>
    
  </channel>
</rss>
